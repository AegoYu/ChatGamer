[{"title":"\n  设顺序线性表的长度为30，分成5块，每块6个元素，如果采用分块查找，则其平均查找长度为（）。\n","choices":["\n6\n","\n11\n","\n5\n","\n6.5\n"],"correct_choice":"\n6.5\n"},{"title":"采用深度优先搜索或拓扑排序算法可以判断出一个有向图中是否有环(回路)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"折半查找法的查找速度一定比顺序查找法快 。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"顺序表查找指的是在顺序存储结构上进行查找。（\n）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n\n  设一个顺序有序表A[1:14]中有14个元素，则采用二分法查找元素A[4]的过程中比较元素的顺序为(  )。\n","choices":["\nA[1]，A[2]，A[3]，A[4]\n","\nA[1]，A[14]，A[7]，A[4]\n","\nA[7]，A[3]，A[5]，A[4]\n","\nA[7]，A[5] ，A[3]，A[4]\n"],"correct_choice":"\nA[7]，A[3]，A[5]，A[4]\n"},{"title":"\n  若有\n  18\n  个元素的有序表存放在一维数组\n  A[19]\n  中，第一个元素放\n  A[1]\n  中，现进行二分查找，则查找\n  A\n  ［\n  3\n  ］的比较序列的下标依次为\n  (      )\n\n","choices":["\n1，2，3\n","\n9，5，2，3\n","\n9，5，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"\n  \n    折半查找法适用于\n  \n  \n    （）。\n  \n","choices":["\n有序顺序表\n","\n有序单链表\n","\n有序顺序表和有序单链表都可以\n","\n无限制\n"],"correct_choice":"\n有序顺序表\n"},{"title":"  针对二分查找算法，假设一个有序数组有 136 个元素，那么要查找到第 10 个元素， 需要比较的元素为（）  ","choices":["\n68,34,17,9,13,11,10\n","\n68,34,17,8,12,10\n","\n69,35,18,10\n","\n68,34,18,9,13,11,10\n"],"correct_choice":"\n68,34,17,8,12,10\n"},{"title":"\n  设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（）。\n","choices":["\nlog2n+1\n","\nlog2n-1\n","\nlog2n\n","\nlog2(n+1)\n"],"correct_choice":"\nlog2n+1\n"},{"title":"如果要求一个线性表既能较快的查找，又能适应动态变化的要求，则可采用 （）查找法。","choices":["\n分块查找\n","\n顺序查找\n","\n折半查找\n","\n基于属性\n"],"correct_choice":"\n分块查找\n"},{"title":"设有序表中的元素为(13，18，24，35，47，50，62)，则在其中利用二分法查找值为24的元素需要经过(     )次比较。","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"\n  当采用分快查找时，数据的组织方式为 (    ) \n  \n","choices":["\n数据分成若干块，每块内数据有序\n","\n数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块\n","\n数据分成若干块，每块内数据有序，每块内最大（或最小）的数据组成索引块\n","\n数据分成若干块，每块（除最后一块外）中数据个数需相同\n"],"correct_choice":"\n数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块\n"},{"title":"当采用分块查找时,数据的组织方式为()","choices":["\n数据分成若干块,每块内数据有序\n","\n数据分成若干块,每块内数据不必有序,但块间必须有序,每块内最大(或最小)的数据组成索引块\n","\n数据分成若干块,每块内数据有序,每块内最大(或最小)的数据组成索引块\n","\n数据分成若干块,每块(除最后-块外)中数据个数需相同\n"],"correct_choice":"\n数据分成若干块,每块内数据不必有序,但块间必须有序,每块内最大(或最小)的数据组成索引块\n"},{"title":"已知二叉树后序遍历序列是bfegcda，中序遍历序列是badefcg，它的前序遍历序列是：","choices":["\nabcdefg\n","\nabdcefg\n","\nadbcfeg\n","\nabecdfg\n"],"correct_choice":"\nabdcefg\n"},{"title":"在有序表(12,24,36,48,60,72,84)中二分查找关键字72时所需进行的关键字比较次数是多少？","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n2\n"},{"title":"设有一组关键字序列{5,8,14,20,31,55,78,81,93,97,111}，使用二分（折半）法查找关键字93需要进行多少次比较（）","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n2\n"},{"title":"公司里面有1001个员工，现在要在公司里面找到最好的羽毛球选手，也就是第一名，每个人都必须参赛，问至少要比赛多少次才能够找到最好的羽毛球员工。","choices":["\n1001\n","\n1000\n","\n500\n","\n501\n"],"correct_choice":"\n1000\n"},{"title":"对于满足折半查找和分块查找条件的文件而言,无论它存在何种介质上,均能进行顺序查找,折半查找和分块查找()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"用向量和单链表示的有序表均可使用折半查找方法来提高查找速度()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"设有关键字n=2h\n -1,构成二叉排序树,每个关键字查找的概率相等,查找成功的ASL最大是n()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"给定的一个长度为N的字符串str,查找长度为P(P<N)的字符串在str中的出现次数.下面的说法正确的是()","choices":["\n不存在比最坏时间复杂度O(NP)好的算法\n","\n不存在比最坏时间复杂度O(N^2)好的算法\n","\n不存在比最坏时间复杂度O(P^2)好的算法\n","\n存在最坏时间复杂度为O(N+P)的算法\n","\n存在最坏时间复杂度为O(log(N+P))的算法\n","\n以上都不对\n"],"correct_choice":"\n存在最坏时间复杂度为O(N+P)的算法\n"},{"title":"广告系统为了做地理位置定向，将IPV4分割为627672个区间，并标识了地理位置信息，区间之间无重叠，用二分查找将IP地址映射到地理位置信息，请问在最坏的情况下，需要查找多少次?","choices":["\n17\n","\n18\n","\n19\n","\n20\n"],"correct_choice":"\n20\n"},{"title":"\n  已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个\n  L中\n  不存在的元素，则\n  关键字的\n  比较次数最多是（）\n","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n5\n"},{"title":"\n  已知字符串S 为“abaabaabacacaabaabcc”，模式串 t 为“abaabc”。采用 KMP 算法进行匹配，第一\n    次出现“失配”(s[i]≠t[j])  时，i=j=5，则下次开始匹配时，i 和 j 的值分别是\n  （）\n  。\n","choices":["\ni=1,j=0\n","\ni=5,j=0\n","\ni=5,j=2\n","\ni=6,j=2\n"],"correct_choice":"\ni=5,j=2\n"},{"title":"串′ababaaababaa′的next数组为()","choices":["\n012345678999\n","\n012121111212\n","\n011234223456\n","\n0123012322345\n"],"correct_choice":"\n011234223456\n"},{"title":"在序列 [22, 34, 55, 77, 89, 93, 99, 102, 120, 140] 中，采用二分查找，分别查找77,34,99，所需的查找次数分别为()","choices":["\n3,3,3\n","\n3,3,4\n","\n3,4,3\n","\n4,2,4\n"],"correct_choice":"\n4,2,4\n"},{"title":"使用KMP算法在文本串S中找模式串P是一种常见的方法。假设S=P={xyxyyxxyx}，亦即将S对自己进行匹配，匹配过程中正确的next数组是____。","choices":["\n0,1,1,2,2,1,2,2,3\n","\n0,1,2,2,3,1,2,2,3\n","\n0,1,1,2,3,1,2,2,3\n","\n0,1,1,2,3,1,1,2,3\n","\n0,1,2,2,3,1,1,2,3\n","\n0,1,2,2,2,1,1,2,3\n"],"correct_choice":"\n0,1,1,2,3,1,2,2,3\n"},{"title":"  考虑以下二分查找的代码： \n\n  #include <stdio.h>\nint bsearch(int array[], int n, int v)\n{\n    int left, right, middle;\n    left = 0, right = n - 1;\n    while (left <= right) {\n        middle = left + (right - left) / 2;\n        if (array[middle] > v ) {\n            right = middle;\n        } else if (array[middle] < v) {\n            left = middle;\n        } else {\n            return middle;\n        }\n  } \n    return -1;\n}\n\n  对于输入array为：{2, 6, 8, 10, 13, 25, 36, 45, 53, 76, 88, 100, 127}， n\n  = 13, v = 127时, \n  运行bsearch函数，while循环调用的次数为____。 ","choices":["\n1\n","\n3\n","\n4\n","\n5\n","\n6\n","\n无数次\n"],"correct_choice":"\n无数次\n"},{"title":"只要数据元素保持有序,则查找时就可以采用折半查找方法()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下面哪一方法可以判断出一个有向图是否有环(回路)()","choices":["\n深度优先遍历\n","\n拓扑排序\n","\nDijkstra求最短路径\n","\n求关键路径\n"],"correct_choice":"\n深度优先遍历\n\n拓扑排序\n"},{"title":"  二分查找要求节点（    ）  ","choices":["\n有序、顺序存储\n","\n有序、链接存储\n","\n无序、顺序存储\n","\n无序、链接存储\n"],"correct_choice":"\n有序、顺序存储\n"},{"title":"若在线性表中采用折半查找法查找元素，该线性表应该：（）","choices":["\n元素按值有序\n","\n构采用顺序存储结\n","\n元素按值有序且采用顺序存储结构\n","\n元素按值有序且采用链式存储结构\n"],"correct_choice":"\n元素按值有序且采用顺序存储结构\n"},{"title":"二叉查找树的查找效率与二叉树的树型有关，在（）时其查找效率最低","choices":["\n结点太多\n","\n完全二叉树\n","\n是单枝树\n","\n节点太复杂\n"],"correct_choice":"\n是单枝树\n"},{"title":"\n  在长度为\n  n\n  的顺序表中查找一个元素，假设需要查找的元素一定在表中，并且元素出现在表中每个位置上的可能性是相同的，则在平均情况下需要比较的次数为（\n  ）\n","choices":["\n(n+1)/2\n","\nn\n","\n3n/4\n","\nn/4\n"],"correct_choice":"\n(n+1)/2\n"},{"title":"用二分法查找长度为10的、排好序的线性表，查找不成功时，最多需要比较多少次？","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n4\n"},{"title":"\n  顺序查找法适用于存储结构为顺序或链接存储的线性表。\n\n\n  \n    \n  \n","choices":["\n是\n","\n否\n"],"correct_choice":"\n是\n"},{"title":"\n  下面关于二分查找的叙述正确的是 (    ) \n  \n","choices":["\n表必须有序，表可以顺序方式存储，也可以链表方式存储\n","\n表必须有序且表中数据必须是整型，实型或字符型\n","\n表必须有序，而且只能从小到大排列\n","\n表必须有序，且表只能以顺序方式存储\n"],"correct_choice":"\n表必须有序，且表只能以顺序方式存储\n"},{"title":"对一个排好序的线性表，用二分法检索表中的元素，被检索的表应当采用哪种存储表示？","choices":["\n顺序存储\n","\n链接存储\n","\n散列法存储\n","\n存储表示不受限制\n"],"correct_choice":"\n顺序存储\n"},{"title":"能用二分法进行查找的是","choices":["\n顺序存储的有序线性表\n","\n线性链表\n","\n二叉链表\n","\n有序线性链表\n"],"correct_choice":"\n顺序存储的有序线性表\n"},{"title":"有序数组1 2 3 4 5 6 7 8 9查找3的二分查找序列是:","choices":["\n1->2->3\n","\n5->2->3\n","\n9->5->3\n","\n5->1->4->3\n"],"correct_choice":"\n5->2->3\n"},{"title":"有一个有序表为{1,3,9,12,32,41,45,62,75,77,82,95,100}，当折半查找值为82的结点时，____次比较后查找成功。\n","choices":["\n1\n","\n4\n","\n2\n","\n8\n"],"correct_choice":"\n4\n"},{"title":"当在一个有序的顺序存储表上查找一个数据时,即可用折半查找,也可用顺序查找,但前者比后者的查找速度()","choices":["\n必定快\n","\n必定不快\n","\n在大部分情况下要快\n","\n取决于表递增还是递减\n"],"correct_choice":"\n在大部分情况下要快\n"},{"title":"查找n个元素的有序表时,最有效的查找方法是()","choices":["\n顺序查找\n","\n分块查找\n","\n折半查找\n","\n二叉排序树\n"],"correct_choice":"\n折半查找\n"},{"title":"对无序表用折半法查找比顺序查找快()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"折半查找的时间复杂性为()","choices":["\nO(n2)\n","\nO(n)\n","\nO(nlogn)\n","\nO(logn)\n"],"correct_choice":"\nO(logn)\n"},{"title":"在长度为n的有序线性表中进行二分查找，最坏情况下需要比较的次数是（  ）。 ","choices":["\nO(n)\n","\nO(n^2)\n","\nO(logn)\n","\nO(nlogn)\n"],"correct_choice":"\nO(logn)\n"},{"title":"\n  已知\n  10\n  个元素\n  (54,28,16,34,,73,62,95,60,26,43)\n  ，按照依次插入的方法生成一棵二叉排序树，查找值为\n  62\n  的结点所需比较次数为（）\n","choices":["\n4\n","\n3\n","\n2\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"若有序表的关键字序列为（b,c,d,e,f,g,q,r,s,t），则在二分查找关键字b的过程中，先后进行的关键字依次为：","choices":["\nf,c,b\n","\nf,d,b\n","\ng,c,b\n","\ng,d,b\n"],"correct_choice":"\nf,c,b\n"},{"title":"已知有序序列b c d e f g q r s t,则在二分查找关键字b的过程中，先后进行比较的关键字依次是多少?()","choices":["\nf d b\n","\nf c b\n","\ng c b\n","\ng d b\n"],"correct_choice":"\nf c b\n"},{"title":"执行()操作时,需要使用队列做辅助存储空间","choices":["\n查找哈希(Hash)表\n","\n广度优先搜索网\n","\n前序(根)遍历二叉树\n","\n深度优先搜索网\n"],"correct_choice":"\n广度优先搜索网\n"},{"title":"图的BFS生成树的树高比DFS生成树的树高()","choices":["\n小或相等\n","\n小\n","\n大或相等\n","\n大\n"],"correct_choice":"\n小或相等\n"},{"title":"一个长度为32的有序表，若采用二分查找一个不存在的元素，则比较次数最多是__","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n6\n"},{"title":"给定一个整数sum,从有N个有序元素的数组中寻找元素a,b,使得a+b的结果最接近sum,最快的平均时间复杂度是：","choices":["\nO(n)\n","\nO(nlogn)\n","\nO(n^2)\n","\nO(logn)\n"],"correct_choice":"\nO(n)\n"},{"title":"在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行（）次比较：","choices":["\n8\n","\n9\n","\n10\n","\n11\n"],"correct_choice":"\n9\n"},{"title":"二分查找要满足顺序存储、链存储、按value有序中的哪些条件？","choices":["\n顺序存储\n","\n链存储\n","\n按value有序\n","\n以上答案都不正确\n"],"correct_choice":"\n顺序存储\n\n按value有序\n"},{"title":"关于红黑树和AVL树，以下哪种说法不正确？","choices":["\n两者都属于自平衡二叉树\n","\n两者查找,插入，删除的时间复杂度相同\n","\n包含n个内部节点的红黑树的高度是O(log(n))\n","\nJDK的TreeMap是一个AVL的实现\n"],"correct_choice":"\nJDK的TreeMap是一个AVL的实现\n"},{"title":"\n  对线性表进行二分查找时，要求线性表必须（）\n","choices":["\n以顺序方式存储\n","\n以顺序方式存储,且数据元素有序\n","\n以链接方式存储\n","\n以链接方式存储,且数据元素有序\n"],"correct_choice":"\n以顺序方式存储,且数据元素有序\n"},{"title":"\n  #\n  判断正误\n  #\n\n\n  对无序表用二分法查找比顺序查找快。\n","choices":["\n√\n","\n×\n"],"correct_choice":"\n×\n"},{"title":"\n  用二分（对半）查找表的元素的速度比用顺序法(    )\n  \n","choices":["\n必然快\n","\n必然慢\n","\n相等\n","\n不能确定\n"],"correct_choice":"\n不能确定\n"},{"title":"  使用二分搜索算法在 1000 个有序元素表中搜索一个特定元素，在最坏情况下，搜索总共需要比较的次数为（ ）。  ","choices":["\n10\n","\n11\n","\n500\n","\n1000\n"],"correct_choice":"\n10\n"},{"title":"采用折半查找方法进行查找，数据文件应为（），且限于（）","choices":["\n有序表  顺序存储结构\n","\n有序表  链式存储结构\n","\n随机表  顺序存储结构\n","\n随机表  链式存储结构\n"],"correct_choice":"\n有序表  顺序存储结构\n"},{"title":"\n  用二分法查找表\n  (a0,a1,a2,a3,……a16)\n  ，需要比较\n  2\n  次才能找到的元素是（\n  ） \n","choices":["\na7和a16\n","\na11和a13\n","\na1和a14\n","\na3和a12\n"],"correct_choice":"\na3和a12\n"},{"title":"\n  二分查找要求元素\n  (   ) \n","choices":["\n有序、顺序存储\n","\n有序、链式存储\n","\n无序、顺序存储\n","\n无序、链式存储\n"],"correct_choice":"\n有序、顺序存储\n"},{"title":"\n  设顺序表的长度为n，则顺序查找的平均比较次数为（）。\n","choices":["\nn\n","\nn/2\n","\n(n+1)/2\n","\n(n-1)/2\n"],"correct_choice":"\n(n+1)/2\n"},{"title":"\n  设顺序线性表的长度为30，分成5块，每块6个元素，如果采用分块查找\n  并且索引表和块内均采用顺序查找\n  ，则其平均查找长度为\n  (     )\n  。\n","choices":["\n6\n","\n11\n","\n5\n","\n6.5\n"],"correct_choice":"\n6.5\n"},{"title":"  为了对某序列进行二分查找，则要求其（ ）。  ","choices":["\n可以是乱序\n","\n必须已排序\n","\n可以已排序也可以是乱序\n","\n必须转化为二叉树\n"],"correct_choice":"\n必须已排序\n"},{"title":"分块查找的平均查找长度不仅与索引表的长度有关，而且与块的长度有关。（\n）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"下列有关图的遍历说法中，不正确的是","choices":["\n有向图和无向图都可以进行遍历操作\n","\n基本遍历算法两种：深度遍历和广度遍历\n","\n图的遍历必须用递归实现\n","\n图的遍历算法可以执行在有回路的图中\n"],"correct_choice":"\n图的遍历必须用递归实现\n"},{"title":"对一个无向图进行先深搜索时,得到的先深序列是唯一的()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对长度为N的线性表进行顺序查找，在最坏情况下所需要的比较次数为___","choices":["\nN+1\n","\nN\n","\nN/2\n","\n(N+1)/2\n"],"correct_choice":"\nN\n"},{"title":"Suppose that a Selection Sort of 80 items has completed 32 iterations of\nthe main loop. How many items are now guaranteed to be in their final\nspot (never to be moved again)?","choices":["\n16\n","\n31\n","\n32\n","\n39\n","\n40\n"],"correct_choice":"\n32\n"},{"title":"下面关于二分查找的叙述中正确的是：","choices":["\n表必须有序,表可以顺序方式存储,也可以链表方式存储\n","\n表必须有序且表中数据必须是整型,实型或字符型\n","\n表必须有序,而且只能从小到大排列\n","\n表必须有序,且表只能以顺序方式存储\n"],"correct_choice":"\n表必须有序,且表只能以顺序方式存储\n"},{"title":"\n  能在O\n  (1)\n  时间内访问线性表的第i个元素的结构是（）\n","choices":["\n顺序表\n","\n单链表\n","\n单向循环链表\n","\n双向链表\n"],"correct_choice":"\n顺序表\n"},{"title":"在用Floyd算法求解各顶点间的最短路径时,每个表示两点间路径的path(k-1)\n[I,J]一定是path(k)\n[I,J]的子集(k=1,2,3,…,n)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"既希望较快的查找又便于线性表动态变化的查找方法是()","choices":["\n顺序查找\n","\n折半查找\n","\n分块查找\n","\n哈希法查找\n"],"correct_choice":"\n分块查找\n"},{"title":"  从n个数里面找最大的两个数理论最少需要比较","choices":["\n2logn\n","\n2 logn -1\n","\nn+ logn -2\n","\n2n-3\n"],"correct_choice":"\nn+ logn -2\n"},{"title":"对大小均为n的有序表和无序表分别进行顺序查找,在等概率查找的情况下,对于查找成功,它们的平均查找长度是相同的,而对于查找失败,它们的平均查找长度是不同的()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"适于对动态查找表进行高效率查找的组织结构是分块有序表()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"字符串′ababaabab′的nextval为()","choices":["\n(0,1,0,1,0,4,1,0,1)\n","\n(0,1,0,1,0,2,1,0,1)\n","\n(0,1,0,1,0,0,0,1,1)\n","\n(0,1,0,1,0,1,0,1,1)\n"],"correct_choice":"\n(0,1,0,1,0,4,1,0,1)\n"},{"title":"  为查找某一特定单词在文本中出现的位置，可应用的串运算是(     ）\n","choices":["\n插入\n","\n删除\n","\n串联接\n","\n子串定位\n"],"correct_choice":"\n子串定位\n"},{"title":"对线性表进行折半查找时，要求线性表必须         。","choices":["\n以顺序方式存储\n","\n以顺序方式存储，且结点按关键字有序排列\n","\n以链式方式存储\n","\n以链式方式存储，且结点按关键字有序排列\n"],"correct_choice":"\n以顺序方式存储，且结点按关键字有序排列\n"},{"title":"\n  二分查找的时间复杂度（）\n","choices":["\nO(N*log(N))\n","\nO(N)\n","\nO(log(N))\n","\nO(N^2)\n"],"correct_choice":"\nO(log(N))\n"},{"title":"在索引顺序表中,实现分块查找,在等概率查找情况下,其平均查找长度不仅与表中元素个数有关,而且与每块中元素个数有关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"将线性表中的结点信息组织成平衡的二叉树,其优点之一是总能保证任意检索长度均为log2\nn量级(n为线性表中的结点数目)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"对有序数组{2、11、15、19、30、32、61、72、88、90、96}进行二分查找，则成功找到15需比较（）次","choices":["\n3\n","\n4\n","\n2\n","\n5\n"],"correct_choice":"\n2\n"},{"title":"请问对一个排好序的数组进行查找，时间复杂度为（）","choices":["\nO(n)\n","\nO(lgn)\n","\nO(nlgn)\n","\nO(1)\n"],"correct_choice":"\nO(lgn)\n"},{"title":"  有个长度为12的无重复有序表，按折半查找法进行查找，在表内各元素等概率情况下，查找成功所需的平均比较（三元比较）的次数为（）","choices":["\n35/12\n","\n37/12\n","\n39/12\n","\n43/12\n"],"correct_choice":"\n37/12\n"},{"title":"折半查找与二元查找树的时间性能在最坏的情况下是相同的()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"KMP算法下，长为n的字符串中匹配长度为m的子串的复杂度为（）","choices":["\nO（N）\n","\nO（M+N）\n","\nO（M+LOGM）\n","\nO（N+LOGM）\n"],"correct_choice":"\nO（M+N）\n"},{"title":"\n  下列选项中，不能构成折半查找中关键字比较序列的是\n  （）。\n","choices":["\n500,200,450,180\n","\n500,450,200,180\n","\n180,500,200,450\n","\n180,200,500,450\n"],"correct_choice":"\n500,200,450,180\n"},{"title":"在154个元素组成有序表进行二分法查找，可能的比较次数为","choices":["\n10\n","\n8\n","\n4\n","\n1\n"],"correct_choice":"\n8\n\n4\n\n1\n"},{"title":"  下面是折半查找的实现，data是按升序排列的数据，x是查找下标，y是查找的上标， \n  v是查找的数值，返回v在data的索引，若没找到返回-1。代码不正确是____。 \npublic int bsearch(int[] data, int x, int y, int v) {\n    int m;\n    while(x<y){ //1\n        m = x + (y-x)/2; //2\n        if(data[m] == v) return m; //3\n        else if(data[m] > v) y = m; //4\n        else x = m; //5\n    }\n    return -1; //6\n}","choices":["\n1\n","\n2\n","\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n1\n\n4\n\n5\n"},{"title":"  对于静态表的顺序查找法，若在表头设置监视哨，则正确的查找方式为（）。 ","choices":["\n从第0个元素往后查找该数据元素\n","\n从第1个元素往后查找该数据元素\n","\n从第n个元素往开始前查找该数据元素\n","\n与查找顺序无关\n"],"correct_choice":"\n从第n个元素往开始前查找该数据元素\n"},{"title":"  若有一个顺序有序表A[1:18] 中有18个元素，现进行二分查找，则查找 A［3］的比较序列的下标依次为（ ）。  ","choices":["\n1，2，3\n","\n9，5，2，3\n","\n9，5，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"\n  如果要求一个线性表既能较快的查找，又能适应动态变化的要求，则可采用(    )查找法。\n\n\n  \n","choices":["\n分快查找\n","\n顺序查找\n","\n折半查找\n","\n基于属性\n"],"correct_choice":"\n分快查找\n"},{"title":"有一个有序表位{1,3,9,12,32,41,45,62,75,77,82,95,99}，当采用二分查找法查找关键字为82的元素时，（）次比较后查找成功。","choices":["\n1\n","\n2\n","\n4\n","\n8\n"],"correct_choice":"\n4\n"},{"title":"众里寻他千百度，蓦然回首，那人却在灯火阑珊处。——辛弃疾《青玉案》描述的是()","choices":["\n贪心\n","\n回溯\n","\n穷举\n","\n分治\n","\n递归\n"],"correct_choice":"\n回溯\n"},{"title":"在顺序表（3,6,8,10,12,15,16,18,21,25,30）中，用二分法查找关键码值11，所需的关键码比较次数为","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n4\n"},{"title":"顺序查找的平均时间是多少？","choices":["\nn/2\n","\nn\n","\nn * n\n","\nlog n\n"],"correct_choice":"\nn/2\n"},{"title":"需要借助于一个队列来实现DFS算法()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"有n个数存放在一维数组A[1,n]中,在进行顺序查找时,这n个数的排列有序或无序其平均查找长度不同()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  若有18个元素的有序表存放在一维数组A[19]中，第一个元素放A[1]中，现进行二分查找，则查找A[3]的比较序列的下标依次为（）\n","choices":["\n1，2，3\n","\n9，5，3\n","\n9，5，2，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"在索引顺序表中，实现分块查找，在等概率查找情况下，其平均查找长度不仅与表中元素个数有关，而且与每块中元素个数有关。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  对N个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找长度为(   ) \n  \n","choices":["\n（N+1）/2\n","\nN/2\n","\nN\n","\n[（1+N）*N ]/2\n"],"correct_choice":"\n（N+1）/2\n"},{"title":"设有100个元素，用二分法查找时，最大比较次数是（）","choices":["\n25\n","\n7\n","\n10\n","\n1\n"],"correct_choice":"\n7\n"},{"title":"\n  具有12个关键字的有序表，折半查找的平均查找长度（ \n  )\n","choices":["\n3.1\n","\n4\n","\n2.5\n","\n5\n"],"correct_choice":"\n3.1\n"},{"title":"\n  折半查找有序表（4,6,10,12,20,30,50,70,88,100）。若查找表中元素58，则它将依次与表中哪些元素比较大小，查找结果失败（）\n","choices":["\n20，50\n","\n30，88，70，50\n","\n30，88，50\n","\n20，70，30，50\n"],"correct_choice":"\n20，70，30，50\n"},{"title":"在ASC算法team日常开发中，常常面临一些数据结构的抉择，令人纠结。目前大家在策划一个FBI项目（Fast Binary Indexing），其中用到的词汇有6200条，词汇长度在10-15之间，词汇字符是英文字母，区分大小写。请在下面几个数据结构中选择一个使检索速度最快的：","choices":["\n二叉搜索树，比较函数开销：1次运算/每字符\n","\n哈希表，hash算法开销：10次运算/每字符\n","\n链表，比较函数开销：1次运算/每字符\n","\nTRIE树，寻找子节点开销：1次运算/每字符\n"],"correct_choice":"\nTRIE树，寻找子节点开销：1次运算/每字符\n"},{"title":"分块查找的基本思想是首先在索引表中进行查找，以便确定给定的关键字可能存在的块号，然后再在相应的块内进行顺序查找。（  ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"折半查找法的查找速度一定比顺序查找法快()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对线性表进行折半查找时,要求线性表必须()","choices":["\n以顺序方式存储\n","\n以顺序方式存储,且数据元素有序\n","\n以链接方式存储\n","\n以链接方式存储,且数据元素有序\n"],"correct_choice":"\n以顺序方式存储,且数据元素有序\n"},{"title":"\n  在顺序表\n  {\n  1\n  2\n  、1\n  5\n  、1\n  7\n  、2\n  0\n  、2\n  4\n  、30、3\n  8\n  、4\n  3\n  、4\n  5\n  、5\n  1\n  、\n  52}\n  中，用二分法查找关键码\n  2\n  0需做（  ） 次关键字比较。\n","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"顺序查找法适用于存储结构为顺序或链接存储的线性表。","choices":["\nT\n","\nF\n"],"correct_choice":"\nT\n"},{"title":"\n  若在线性表中采用折半查找法查找元素，该线性表应该：\n\n\n  \n","choices":["\n元素按值有序\n","\n采用顺序存储结构\n","\n. 元素按值有序且采用顺序存储结构\n","\n元素按值有序且采用链式存储结构\n"],"correct_choice":"\n. 元素按值有序且采用顺序存储结构\n"},{"title":"红黑树中已经有n个数据，寻找某个key是否存在的时间复杂度为()。","choices":["\no(logn)\n","\no(n)\n","\no(n二次方)\n","\no(1)\n"],"correct_choice":"\no(logn)\n"},{"title":"二分查找的时间复杂度（ ）","choices":["\nO(N*log(N))\n","\nO(N)\n","\nO(log(N))\n","\nO(N^2)\n"],"correct_choice":"\nO(log(N))\n"},{"title":"若查找每个记录的概率均等,则在具有n个记录的连续顺序文件中采用顺序查找法查找一个记录,其平均查找长度ASL为()","choices":["\n(n-1)/2\n","\nn/2\n","\n(n+1)/2\n","\nn\n"],"correct_choice":"\n(n+1)/2\n"},{"title":"\n  设有序表中有1000个元素，则用二分查找查找元素X最多需要比较（）次。\n","choices":["\n25\n","\n10\n","\n7\n","\n1\n"],"correct_choice":"\n10\n"},{"title":"","choices":["\n顺序 折半 哈希 分块\n","\n顺序 分块 折半 哈希\n","\n分块 折半 哈希 顺序\n","\n顺序 哈希 分块 折半\n"],"correct_choice":"\n顺序 分块 折半 哈希\n"},{"title":"下列说法中错误的是：（）","choices":["\n插入排序某些情况下复杂度为O（n）\n","\n排序二叉树元素查找的复杂度可能为O（n）\n","\n对于有序列表的排序最快的是快速排序\n","\n在有序列表中通过二分查找的复杂度一定是O（log2n）\n"],"correct_choice":"\n对于有序列表的排序最快的是快速排序\n"},{"title":"具有12个关键字的有序表,折半查找的平均查找长度()","choices":["\n3.1\n","\n4\n","\n2.5\n","\n5\n"],"correct_choice":"\n3.1\n"},{"title":"就平均查找长度而言,分块查找最小,折半查找次之,顺序查找最大()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  设有序表中的元素为(13，18，24，35，47，50，62)，则在其中利用二分法查找值为24的元素需要经过(\n  )次比较。\n\n\n  \n    \n  \n","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"\n  适用于折半查找的表的存储方式及元素排列要求为(     ) \n  \n","choices":["\n链接方式存储，元素无序\n","\n链接方式存储，元素有序\n","\n顺序方式存储，元素无序\n","\n顺序方式存储，元素有序\n"],"correct_choice":"\n顺序方式存储，元素有序\n"},{"title":"如果要求一个线性表既能较快地查找,又能适应动态变化的要求,可以采用下列哪一种查找方法。()","choices":["\n分块\n","\n顺序\n","\n折半\n","\n哈希\n"],"correct_choice":"\n分块\n"},{"title":"  对于下列二分搜索算法，正确的是（ ）。  ","choices":["\npublic static int binarySearch(int[] a, int x, int n)\n{\n         int left = 0, right = n-1;\nwhile(left <= right)\n{\nint middle = (left + right) / 2;\nif(x == a[middle]) return middle;\nif(x > a[middle]) left = middle;\nelse right = middle;\n         }//while\nreturn –1;\n}\n","\npublic static int binarySearch(int[] a, int x, int n)\n{\nint left = 0, right = n-1;\nwhile(left+1 != right)\n{\nint middle = (left + right) / 2;\nif(x >= a[middle]) left = middle;\nelse right = middle;\n}//while\nif(x == a[left]) return left;\nelse return –1;\n}\n","\npublic static int binarySearch (int[] a, int x, int n)\n       {\nint left = 0, right = n-1;\nwhile(left < right-1)\n{\nint middle = (left + right) / 2;\nif(x < a[middle])\nright = middle;\nelse left = middle;\n}//while\nif(x == a[left]) return left;\nelse return –1;\n}\n","\npublic static int binarySearch(int[] a, int x, int n)\n{\nif(n > 0 && x >= a[0])\n{\nint left = 0, right = n-1;\nwhile(left < right)\n{\nint middle = (left + right + 1) / 2;\nif(x < a[middle])\nright = middle - 1;\nelse left = middle;\n}//while\nif(x == a[left]) return left;\n}//if\nreturn –1;\n}\n"],"correct_choice":"\npublic static int binarySearch(int[] a, int x, int n)\n{\nif(n > 0 && x >= a[0])\n{\nint left = 0, right = n-1;\nwhile(left < right)\n{\nint middle = (left + right + 1) / 2;\nif(x < a[middle])\nright = middle - 1;\nelse left = middle;\n}//while\nif(x == a[left]) return left;\n}//if\nreturn –1;\n}\n"},{"title":"\n  设有序表中的元素为(13，18，24，35，47，50，62)，则在其中利用二分法查找值为24的元素需要经过（）次比较。\n","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"\n  设有序序列长度为\n  n\n  ，在最坏情况下，时间复杂度为\n  \n\n\n  的算法是（ ）。\n","choices":["\n二分法查找\n","\n顺序查找\n","\n分块查找\n","\n哈希查找\n"],"correct_choice":"\n二分法查找\n"},{"title":"采用折半查找法查找长度为 n 的线性表时，每个元素的平均查找长度为           。","choices":["\nO(n2)\n","\nO(nlog2n)\n","\nO(n)\n","\nO(log2n)\n"],"correct_choice":"\nO(log2n)\n"},{"title":"  二分查找要求节点 () ","choices":["\n有序、顺序存储\n","\n有序、链接存储\n","\n无序、顺序存储\n","\n无序、链接存储\n"],"correct_choice":"\n有序、顺序存储\n"},{"title":"  就平均查找速度而言，下列几种查找速度从慢至快的关系是___________。\n","choices":["\n顺序 折半 哈希 分块\n","\n顺序 分块 折半 哈希\n","\n分块 折半 哈希 顺序\n","\n顺序 哈希 分块 折半\n"],"correct_choice":"\n顺序 分块 折半 哈希\n"},{"title":"任一查找树(二叉分类树)的平均查找时间都小于用顺序查找法查找同样结点的线性表的平均查找时间()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  对于二分搜索法，下面描述正确的是（）\n","choices":["\n可用于数组\n","\n可用于单链表\n","\n只能在已排序的数据上进行\n","\n最坏情况下时间复杂度是O（N*LogN）\n"],"correct_choice":"\n可用于数组\n\n只能在已排序的数据上进行\n"},{"title":"\n  既希望较快的查找又便于线性表动态变化的查找方法是 (    ) \n  \n","choices":["\n顺序查找\n","\n折半查找\n","\n索引顺序查找\n","\n哈希法查找\n"],"correct_choice":"\n索引顺序查找\n"},{"title":"\n  当在一个有序的顺序存储表上查找一个数据时，即可用折半查找，也可用顺序查找，但前者比后者的查找速度(    ) \n  \n\n\n  \n","choices":["\n必定快\n","\n不一定\n","\n在大部分情况下要快\n","\n取决于表递增还是递减\n"],"correct_choice":"\n在大部分情况下要快\n"},{"title":"已知一个有序表为（12，18，24，35，47，50，62，83，90，115，134），当折半查找值为90的元素时，经过（）次比较后查找成功。","choices":["\n5\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n2\n"},{"title":"二元查找树的任何结点的左右子树都是二元查找树()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"\n  在长度为n的顺序线性表中顺序查找值为x的元素时，查找成功时的平均查找长度（假定查找每个元素的概率均相等）为（）。\n","choices":["\nn\n","\n(n-1)/2\n","\nn/2\n","\n(n+1)/2\n"],"correct_choice":"\n(n+1)/2\n"},{"title":"二分查找树里查询一个关键字的最坏时间复杂度是______","choices":["\nO(n)\n","\nO(n log n)\n","\nO(n^2)\n","\nO(n^3)\n","\nO(logn)\n","\n不确定\n"],"correct_choice":"\nO(n)\n"},{"title":"就平均查找长度而言，分块查找最小，折半查找次之，顺序查找最大。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"对无序表用二分法查找比顺序查找快。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"下面关于哈希(Hash,杂凑)查找的说法正确的是()","choices":["\n哈希函数构造的越复杂越好,因为这样随机性好,冲突小\n","\n除留余数法是所有哈希函数中最好的\n","\n不存在特别好与坏的哈希函数,要视情况而定\n","\n若需在哈希表中删去一个元素,不管用任何方法解决冲突都只要简单地将该元素删去即可\n"],"correct_choice":"\n不存在特别好与坏的哈希函数,要视情况而定\n"},{"title":"  适用于折半查找的表的存储方式及元素排列要求为（）。 ","choices":["\n链接方式存储，元素无序\n","\n链接方式存储，元素有序\n","\n顺序方式存储，元素无序\n","\n顺序方式存储，元素有序\n"],"correct_choice":"\n顺序方式存储，元素有序\n"},{"title":"设一组初始记录关键字序列为(13，18，24，35，47，50，62，83，90，115，134),则利用二分法查找关键字90需要比较的关键字个数为（）。","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n2\n"},{"title":"对线性表进行折半查找时，要求线性表必须以链式方式存储，且结点按关键字有序排列，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"查找效率最高的二叉排序树是        ","choices":["\n所有结点的左子树都为空的二叉排序树\n","\n所有结点的右子树都为空的二叉排序树\n","\n平衡二叉树\n","\n没有左子树的二叉排序树\n"],"correct_choice":"\n平衡二叉树\n"},{"title":"设顺序线性表的长度为30，分成5块，每块6个元素，如果采用分块查找并且索引表和块内均采用顺序查找，则其平均查找长度为(     )。","choices":["\n6\n","\n11\n","\n5\n","\n6.5\n"],"correct_choice":"\n6.5\n"},{"title":"\n   对线性表进行二分查找，其前提条件是\n  \n\n\n  \n","choices":["\n顺序表\n","\n有序的顺序表\n","\n链表\n","\n有序的链表\n"],"correct_choice":"\n有序的顺序表\n"},{"title":"\n  对线性表采用折半查找，该线性表必须_______。\n","choices":["\n元素按值有序排列\n","\n采用顺序结构\n","\n元素按值有序排列，并且采用顺序存储结构\n","\n元素按值有序排列，并且采用链式存储结构\n"],"correct_choice":"\n元素按值有序排列，并且采用顺序存储结构\n"},{"title":"具有12个关键字的有序表，折半查找的平均查找长度（）","choices":["\n3.1\n","\n4\n","\n2.5\n","\n5\n"],"correct_choice":"\n3.1\n"},{"title":"顺序查找法适用于存储结构为顺序或链接存储的线性表。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"在长度为n的顺序表中查找一个元素，假设需要查找的元素一定在表中，并且元素出现在表中每个位置上的可能性是相同的，则在平均情况下需要比较的次数为（  ）。","choices":["\n(n+1)/2\n","\nn\n","\n3n/4\n","\nn/4\n"],"correct_choice":"\n(n+1)/2\n"},{"title":"  对有18个元素的有序表r[0..17],进行二分查找，则查找r[3]的比较序列下标为      ","choices":["\n0、1、2\n","\n8、4、1、2\n","\n8、3\n","\n8、3、1、2\n"],"correct_choice":"\n8、3\n"},{"title":"\n  具有12个关键字的有序表，折半查找的平均查找长度（）\n","choices":["\n3.1\n","\n4\n","\n2.5\n","\n5\n"],"correct_choice":"\n3.1\n"},{"title":"  二分查找要求节点（） \n  \n","choices":["\n有序、顺序存储\n","\n有序、链接存储\n","\n无序、顺序存储\n","\n无序、链接存储\n"],"correct_choice":"\n有序、顺序存储\n"},{"title":"哈希表的平均查找长度与处理冲突的方法无关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对有18个元素的有序表做折半查找，则查找A[3]的比较序列的下标依次为（）","choices":["\n8-3\n","\n9-5-2-3\n","\n9-5-3\n","\n9-4-2-3\n"],"correct_choice":"\n8-3\n"},{"title":"下列二叉排序树中查找效率最高的是()","choices":["\n平衡二叉树\n","\n二叉查找树\n","\n没有左子树的二叉排序树\n","\n没有右子树的二叉排序树\n"],"correct_choice":"\n平衡二叉树\n"},{"title":"衡量查找算法效率的主要标准是（  ）。","choices":["\n元素个数\n","\n所需的存储量\n","\n均匀查找长度\n","\n算法难易程度\n"],"correct_choice":"\n均匀查找长度\n"},{"title":"\n  用概率查找改进查找效率，是经过多次查找以后使得（\n  ） \n","choices":["\n查找次数越少的元素查找速度越快\n","\n查找次数越少的元素越往前存放\n","\n查找次数越多的元素越往后存放\n","\n查找次数越多的元素查找速度越快\n"],"correct_choice":"\n查找次数越多的元素查找速度越快\n"},{"title":"使用二分查找算法在一个有序序列中查找一个元素的时间复杂度为（ ）","choices":["\nO(N)\n","\nO(logN)\n","\nO(N*N)\n","\nO(N*logN)\n"],"correct_choice":"\nO(logN)\n"}]