[{"title":"下列哪个算法是对一个list排序的最快方法？","choices":["\n快速排序\n","\n冒泡排序\n","\n二分插入排序\n","\n线性排序\n"],"correct_choice":"\n快速排序\n"},{"title":"拓扑排序的有向图中，最多存在一条环路。（  ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  已知用某种排序方法对关键字序列（51，35，93，24，13，68，56，42，77）进行排序时，前两趟排序的结果为\n  （35，51，24，13，68，56，42，77，93） （35，24，13，51，56，42，68，77，93） 所采用的排序方法是_________________\n","choices":["\n插入排序\n","\n冒泡排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n冒泡排序\n"},{"title":"\n  执行一趟快速排序能够得到的序列是（）。\n","choices":["\n[41，12，34，45，27] 55 [72，63]\n","\n[45，34，12，41] 55 [72，63，27]\n","\n[63，12，34，45，27] 55 [41，72]\n","\n[12，27，45，41] 55 [34，63，72]\n"],"correct_choice":"\n[41，12，34，45，27] 55 [72，63]\n"},{"title":"冒泡排序在初始关键字序列为逆序的情况下执行的交换次数最多。（\n）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  将5不同的数据进行交换排序，至多需要比较多少次 \n\n\n  \n","choices":["\n9\n","\n10\n","\n15\n","\n20\n"],"correct_choice":"\n10\n"},{"title":"对长度为n 的线性表作快速排序,在最坏情况下,比较次数为","choices":["\nn\n","\nn-1\n","\nn(n-1)\n","\nn(n-1)/2\n"],"correct_choice":"\nn(n-1)/2\n"},{"title":"若需在O(nlog2\nn)的时间内完成对数组的排序,且要求排序是稳定的,则可选择的排序方法是()","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n直接插入排序\n"],"correct_choice":"\n归并排序\n"},{"title":"对长度为n的线性表排序，在最坏情况下，比较次数不是n(n-1)/2的排序方法是","choices":["\n快速排序\n","\n冒泡排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"设一组初始记录关键字序列（5,2,6,3,8），以第一个记录关键字5为基准进行一趟快速排序的结果为（）","choices":["\n2，3，5，8，6\n","\n3，2，5，8，6\n","\n3，2，5，6，8\n","\n2，3，6，5，8\n"],"correct_choice":"\n3，2，5，6，8\n"},{"title":"平均速度最快的排序算法是？","choices":["\nShell排序\n","\n快速排序\n","\n冒泡排序\n","\n插入排序\n"],"correct_choice":"\n快速排序\n"},{"title":"设一组初始记录关键字序列(Q,H,C,Y,P,A,M,S,R,D,F,X),则按字母升序的第一趟冒泡排序结束后的结果是（）","choices":["\nF，H，C，D，P，A，M，Q，R，S，Y，X\n","\nP，A，C，S，Q，D，F，X，R，H，M，Y\n","\nA，D，C，R，F，Q，M，S，Y，P，H，X\n","\nH，C，Q，P，A，M，S，R，D，F，X，Y\n"],"correct_choice":"\nH，C，Q，P，A，M，S，R，D，F，X，Y\n"},{"title":"快速排序在下面哪种情况下优势最明显()","choices":["\n数据有多个相同数值\n","\n数据基本有序\n","\n数据基本无序\n","\n数据无任何相同数值\n"],"correct_choice":"\n数据基本无序\n"},{"title":"以下哪种排序算法需要开辟额外的存储空间（）","choices":["\n选择排序\n","\n归并排序\n","\n快速排序\n","\n堆排序\n"],"correct_choice":"\n归并排序\n"},{"title":"快速排序在已经有序的情况下效率最差，复杂度为（）\n","choices":["\nO(nlogn)\n","\nO(n^2)\n","\nO(n^1.5)\n"],"correct_choice":"\nO(n^2)\n"},{"title":"已知数据表A中每个元素距其最终位置不远，为了节省时间，应该采取的算法是()","choices":["\n直接选择排序\n","\n直接插入排序\n","\n堆排序\n","\n快速排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"下面给出的四种排序方法中,排序过程中的比较次数与序列初始状态无关\n 的是()","choices":["\n选择排序法\n","\n插入排序法\n","\n快速排序法\n","\n堆排序法\n"],"correct_choice":"\n选择排序法\n"},{"title":"以下哪种排序算法对(1,3,2,4,5,6,7,8,9)进行的排序最快？","choices":["\n冒泡\n","\n快排\n","\n归并\n","\n堆排\n"],"correct_choice":"\n冒泡\n"},{"title":"有一组数据(15,9,7,8,20,-1,7,4),用堆排序的筛选方法降序排序建立的初始堆为()","choices":["\n-1,4,8,9,20,7,15,7\n","\n-1,7,15,7,4,8,20,9\n","\n-1,4,7,8,20,15,7,9\n","\nABC均不对\n"],"correct_choice":"\n-1,4,7,8,20,15,7,9\n"},{"title":"假设你只有100Mb的内存，需要对1Gb的数据进行排序，最合适的算法是（）","choices":["\n归并排序\n","\n插入排序\n","\n快速排序\n","\n冒泡排序\n"],"correct_choice":"\n归并排序\n"},{"title":"下面哪种排序的平均比较次数最少（）","choices":["\n插入排序\n","\n选择排序\n","\n堆排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"如果待排序的数组已经近似递增排序，则此时快排算法的时间复杂度为()","choices":["\nO(n)\n","\nO(n^2)\n","\nO(nlogn)\n","\nO((n^2)*logn)\n"],"correct_choice":"\nO(n^2)\n"},{"title":"外排中使用置换选择排序的目的,是为了增加初始归并段的长度()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"基于比较的排序的时间复杂度下限是多少?","choices":["\nO(n)\n","\nO(n^2)\n","\nO(nlogn)\n","\nO(1)\n"],"correct_choice":"\nO(nlogn)\n"},{"title":"\n   下列选项中，不可能是快速排序第2趟排序结果的是\n  （）\n","choices":["\n2,3,5,4,6,7,9\n","\n2,7,5,6,4,3,9\n","\n3,2,5,4,7,6,9\n","\n4,2,3,5,7,6,9\n"],"correct_choice":"\n3,2,5,4,7,6,9\n"},{"title":"对n个数字进行排序，期中两两不同的数字的个数为k，n远远大于k，而n的取值区间长度超过了内存的大小，时间复杂度最小可以是?","choices":["\nO（nlogk）\n","\nO（nk）\n","\nO（n）\n","\nO（nlogn）\n"],"correct_choice":"\nO（n）\n"},{"title":"下面说法正确的是？","choices":["\n归并排序的平均复杂性为O(N*log(N))。\n","\n快速排序最坏情况下时间复杂度是O(N^2)。\n","\n堆排序在最好最坏情况下时间复杂度都是O(N*log(N))。\n","\n快速排序会比归并排序消耗更多的交换空间。\n"],"correct_choice":"\n归并排序的平均复杂性为O(N*log(N))。\n\n快速排序最坏情况下时间复杂度是O(N^2)。\n\n堆排序在最好最坏情况下时间复杂度都是O(N*log(N))。\n"},{"title":"下列排序算法中，哪些时间复杂度不会超过nlogn？","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n冒泡排序\n"],"correct_choice":"\n堆排序\n\n归并排序\n"},{"title":"在排序方法中，元素比较次数与元素的初始排列无关的是（）","choices":["\nShell 排序\n","\n归并排序\n","\n直接插入排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"下列排序算法不稳定的有?","choices":["\n插入排序\n","\n希尔排序\n","\n冒泡排序\n","\n堆排序\n","\n归并排序\n","\n快速排序\n","\n选择排序\n"],"correct_choice":"\n希尔排序\n\n堆排序\n\n快速排序\n\n选择排序\n"},{"title":"对长度为10的线性表进行冒泡排序,最坏情况下需要比较的次数为","choices":["\n9\n","\n10\n","\n45\n","\n90\n"],"correct_choice":"\n45\n"},{"title":"在所有的排序方法中，关键字比较的次数与记录的初始排列次序无关的是         。","choices":["\n希尔排序\n","\n冒泡排序\n","\n直接插入排序\n","\n直接选择排序\n"],"correct_choice":"\n直接选择排序\n"},{"title":"\n  在最好情况下，下列排序算法中\n  排序算法所需比较关键字次数最少。\n\n\n  \n","choices":["\n基数排序\n","\n直接插入排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"从未排序序列中依次取出一个元素与已排序序列中的元素依次进行比较,然后将其放在已排序序列的合适位置,该排序方法称为()排序法","choices":["\n插入\n","\n选择\n","\n希尔\n","\n二路归并\n"],"correct_choice":"\n插入\n"},{"title":"\n  设一组初始记录关键字序列为(45，80，55，40，42，85)，则以第一个记录关键字45为基准而得到一趟快速排序的结果是（）。\n","choices":["\n40，42，45，55，80，83\n","\n42，40，45，80，85，88\n","\n42，40，45，55，80，85\n","\n42，40，45，85，55，80\n"],"correct_choice":"\n42，40，45，55，80，85\n"},{"title":"所谓一个排序算法是否稳定,是指该算法在各种情况下的时间效率是否相差不大()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"采用计数排序算法对数组A = {1,0,3,1,0,1,1}进行排序，则辅助数组C的长度值为（      ）","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n4\n"},{"title":"直接插入排序在最好情况下的时间复杂度为()","choices":["\nO(logn)\n","\nO(n)\n","\nO(nlogn)\n","\nO(n2)\n"],"correct_choice":"\nO(n)\n"},{"title":"利用归并排序方法对数字序列：5，19，17，21，11，8，1进行排序，共需要进行（      ）次比较","choices":["\n10\n","\n11\n","\n12\n","\n14\n"],"correct_choice":"\n11\n"},{"title":"对长度为n的线性表排序，在最坏情况下，比较次数不是n（n－1）/2的排序方法是（  ）。","choices":["\n快速排序\n","\n冒泡排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"在下列的排序方法中,辅助空间为O(n)的是()","choices":["\n希尔排序\n","\n堆排序\n","\n选择排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"已知关键字序列为(51,22,83,46,75,18,68,30),按关键码字51进行一趟快速排序,完成后的序列为()","choices":["\n(30,22,18,46,51,75,68,83)\n","\n(30,18,22,46,51,75,83,68)\n","\n(30,18,22,46,51,75,68,83)\n","\n(18,22,30,46,51,68,75,83)\n"],"correct_choice":"\n(30,22,18,46,51,75,68,83)\n"},{"title":"\n  下面（）排序算法在输入数据逆序情况下排序速度最快。\n\n\n  \n","choices":["\n归并排序\n","\n直接插入排序\n","\n冒泡排序\n","\n简单选择排序\n"],"correct_choice":"\n归并排序\n"},{"title":"下标从1开始,在含有n个关键字的小根堆(堆顶元素最小)中,关键字最大的记录有可能存储在()位置上","choices":["\n[n/2]\n","\n[n/2]-1\n","\n1\n","\n[n/2]+2\n"],"correct_choice":"\n[n/2]+2\n"},{"title":"若要求排序是稳定的,且关键字为实数,则在下列排序方法中应选()排序为宜","choices":["\n直接插入\n","\n直接选择\n","\n堆\n","\n快速\n","\n基数\n"],"correct_choice":"\n直接插入\n"},{"title":"下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的是","choices":["\n插入排序\n","\n堆排序\n","\n冒泡排序\n","\n快速排序\n"],"correct_choice":"\n堆排序\n"},{"title":"已知数组元素基本有序的情况下，下面采用那个算法对数组排序时间复杂度最低()","choices":["\n直接选择排序\n","\n堆排序\n","\n快速排序\n","\n插入排序\n"],"correct_choice":"\n插入排序\n"},{"title":"在对一组记录(54,38,96,23,15,72,60,45,83)进行直接插入排序时,当把第7个记录60插入到有序表时,为寻找插入位置需比较()次","choices":["\n5\n","\n6\n","\n4\n","\n3\n"],"correct_choice":"\n3\n"},{"title":"以下哪种操作最适合先进行排序处理？","choices":["\n找最大、最小值\n","\n计算算术平均值\n","\n找中间值\n","\n找出现次数最多的值\n"],"correct_choice":"\n找中间值\n"},{"title":"在排序方法中，关键码比较次数与记录地初始排列无关的是：","choices":["\nShell 排序\n","\n归并排序\n","\n直接插入排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"将整数数组（7-6-3-5-4-1-2）按照堆排序的方式原地进行升序排列，请问在整个排序过程中，元素3的数组下标发生过____次改变。","choices":["\n0\n","\n1\n","\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n2\n"},{"title":"有字符序列（Q,H,C,Y,P,A,M,N,R,D,F,X）,新序列（M,H,C,D,F,A,Q,N,R,Y,P,X）是下列（）排序算法一趟扫描结果。","choices":["\n希尔排序\n","\n快速排序\n","\n堆排序\n","\n冒泡排序\n"],"correct_choice":"\n希尔排序\n"},{"title":"希望用最快的速度从一个无序数组中挑选出其中前十个最大的元素，在以下的排序方法中（）\n","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n堆排序\n"},{"title":"将N条长度均为M的有序链表进行合并，合并以后的链表也保持有序，时间复杂度为()?","choices":["\nO(N * M * logN)\n","\nO(N*M)\n","\nO(N)\n","\nO(M)\n"],"correct_choice":"\nO(N * M * logN)\n"},{"title":"对n个记录的线性表进行快速排序为减少算法的递归深度,以下叙述正确的是()","choices":["\n每次分区后,先处理较短的部分\n","\n每次分区后,先处理较长的部分\n","\n与算法每次分区后的处理顺序无关\n","\n以上三者都不对\n"],"correct_choice":"\n每次分区后,先处理较短的部分\n"},{"title":"\n  以下排序算法时间复杂度为\n  O(nlogn)\n  的是（）\n","choices":["\n冒泡排序\n","\n快速排序\n","\n堆排序\n","\n插入排序\n"],"correct_choice":"\n快速排序\n\n堆排序\n"},{"title":"有字符序列{Q, H, C, Y, P ,A, M, S, R, D, F, X}，新序列{F, H ,C, D, P, A, M, Q, R,\nS, Y, X}是下列______排序算法一趟扫描的结果。","choices":["\n二路归并排序\n","\n快速排序\n","\n步长为4的希尔排序\n","\n步长为2的希尔排序\n","\n冒泡排序\n","\n堆排序\n"],"correct_choice":"\n快速排序\n"},{"title":"0~999999之间的所有数字中，任何一位都不包括数字3的数字的总数为____。","choices":["\n99999\n","\n262144\n","\n381041\n","\n524288\n","\n531441\n","\n900000\n"],"correct_choice":"\n531441\n"},{"title":"将5不同的数据进行交换排序，至多需要比较多少次（） ","choices":["\n9\n","\n10\n","\n15\n","\n20\n"],"correct_choice":"\n10\n"},{"title":"\n  设\n  一组初始记录关键字序列为(50，40，95，20，15，70，60，45)，则以增量d=4的一趟希尔排序结束后前4条记录关键字为（）。\n","choices":["\n40，50，20，95\n","\n15，40，60，20\n","\n15，20，40，45\n","\n45，40，15，20\n"],"correct_choice":"\n15，40，60，20\n"},{"title":"\n  设一组初始记录关键字序列为(345，253，674，924，627)，则用基数排序需要进行（）趟的分配和回收才能使得初始关键字序列变成有序序列。\n","choices":["\n3\n","\n4\n","\n5\n","\n8\n"],"correct_choice":"\n3\n"},{"title":"  有一组数据“42,31,12,68,16”，用选择法由小到大排序，第2趟交换数据后数据的顺序是（）？  ","choices":["\n12，16，42，68，31\n","\n12，31，16，68，42\n","\n12，68，31，16，42\n","\n12，42，16，68，31\n"],"correct_choice":"\n12，16，42，68，31\n"},{"title":"排序算法中的比较次数与初始元素序列的排列无关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  以下哪种操作更适合使用排序处理(   )  ","choices":["\n找最大，最小值\n","\n找出现次数最多的值\n","\n找中间值\n","\n求算术平均值\n"],"correct_choice":"\n找中间值\n"},{"title":"二叉树为二叉排序树的充分必要条件是其任一结点的值均大于其左孩子的值、小于其右孩子的值，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"排序算法的稳定是指，关键码相同的记录排序前后相对位置不发生改变，下面哪种排序算法是不稳定的（）","choices":["\n插入排序\n","\n冒泡排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n快速排序\n"},{"title":"若一组记录的排序码为（46, 79, 56, 38, 40, 84），则利用快速排序，以第一个记录为基准得到的一次划分结果是 （） ","choices":["\n38, 40, 46, 56, 79, 84\n","\n40，38, 46 ,79, 56, 84\n","\n40, 38，46, 56, 79, 84\n","\n40, 38，46，84, 56, 79\n"],"correct_choice":"\n40, 38，46, 56, 79, 84\n"},{"title":"\n  下面排序算法中，\n  \n  算法可能会出现下面情况：初始数据有序时，花费的时间反而最多\n\n\n  \n","choices":["\n堆排序\n","\n冒泡排序\n","\n快速排序\n","\n希尔（Shell）排序\n"],"correct_choice":"\n快速排序\n"},{"title":"  快速排序在下列哪种情况下最易发挥其长处？ ","choices":["\n被排序的数据已基本有序\n","\n被排序的数据中含有多个相同排序码\n","\n被排序的数据完全无序\n","\n被排序的数据中的最大值和最小值相差悬殊\n"],"correct_choice":"\n被排序的数据完全无序\n"},{"title":"排序算法是稳定的意思是关键字相同的记录排序前后的相对位置不发生改变，对于下列排序算法： \n 1)插入排序 2)基数排序 3)归并排序 4)冒泡排序 5)堆排序 \n 包含所有稳定算法的选项为：","choices":["\n1)2)3)4)5)\n","\n5)\n","\n2)3)\n","\n1)2)3)4)\n"],"correct_choice":"\n1)2)3)4)\n"},{"title":"下述几种排序方法中，要求内存最大的是（）","choices":["\n快速排序\n","\n插入排序\n","\n选择排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序","choices":["\n400\n","\n500\n","\n600\n","\n700\n","\n800\n","\n900\n"],"correct_choice":"\n400\n"},{"title":"有些排序算法在每趟排序过程中,都会有一个元素被放置在其最终的位置上,下列算法不会出现此情况的是()","choices":["\n希尔排序\n","\n堆排序\n","\n起泡排序\n","\n快速排序\n"],"correct_choice":"\n希尔排序\n"},{"title":"用希尔(Shell)方法排序时,若关键字的初始排序杂乱无序,则排序效率就低()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"希尔排序法属于哪一种类型的排序法","choices":["\n插入类排序法\n","\n交换类排序法\n","\n选择类排序法\n","\n建堆排序法\n"],"correct_choice":"\n插入类排序法\n"},{"title":"在堆排序算法中我们用一个数组A来模拟二叉树T，如果该A[0]存放的是T的根节点，那么A[K](K>0)的父亲节点是","choices":["\n(K-1)/2\n","\nK/2\n","\n(K+1)/2\n","\n都不对\n"],"correct_choice":"\n(K-1)/2\n"},{"title":"排序时，若不采用计数排序等科技换时间的方法，合并m个长度为n的已排序数组的时间复杂度最优为（）","choices":["\nO(nm^2)\n","\nO(mn(logm))\n","\nO(nm)\n","\nO(mlog(n))\n"],"correct_choice":"\nO(mn(logm))\n"},{"title":"下面的排序方法中，关键字比较次数与记录的初始排列无关的是______。","choices":["\n希尔排序\n","\n冒泡排序\n","\n直接插入排序\n","\n直接选择排序\n"],"correct_choice":"\n直接选择排序\n"},{"title":"下列排序法中，每经过一次元素的交换会产生新的逆序的是（\n）","choices":["\n快速排序\n","\n冒泡排序\n","\n简单插入排序\n","\n简单选择排序\n"],"correct_choice":"\n快速排序\n"},{"title":"对于以下说法，错误的是________。","choices":["\nDijkstra算法用于求解图中两点间最短路径，其时间复杂度O(n^2)\n","\nFloyd-Warshall算法用于求解图中所有点对之间最短路径，其时间复杂度为O(n^3)\n","\n找出n个数字的中位数至少需要O(n*logn)的时间\n","\n基于比较的排序问题的时间复杂度下界是O(n*logn)\n"],"correct_choice":"\n找出n个数字的中位数至少需要O(n*logn)的时间\n"},{"title":"将整数数组（7-6-3-5-4-1-2）按照堆排序的方式原地进行升序排列，请问在第一轮排序结束之后，数组的顺序是_____。","choices":["\n2-6-3-5-4-1-7\n","\n6-2-3-5-4-1-7\n","\n6-5-3-2-4-1-7\n","\n1-5-3-2-4-6-7\n","\n5-4-3-2-1-6-7\n","\n5-1-3-2-4-6-7\n"],"correct_choice":"\n6-5-3-2-4-1-7\n"},{"title":"以下排序算法中，哪些是稳定的排序算法？","choices":["\n冒泡\n","\n插入\n","\n合并\n","\n希尔\n","\n快速排序\n"],"correct_choice":"\n冒泡\n\n插入\n\n合并\n"},{"title":"Which of the following statements are true?","choices":["\nWe can create a binary tree from given inorder and preorder traversal sequences.\n","\nWe can create a binary tree from given preorder and postorder traversal sequences.\n","\nFor an almost sorted array, insertion sort can be more effective than Quicksort.\n","\nSuppose T(n) is the runtime of resolving a problem with n elements, T(n) = Θ(1) if n = 1; T(n) = 2T(n/2) + Θ(n) if > 1; so T(n) is Θ(n log n).\n","\nNone of the above.\n"],"correct_choice":"\nWe can create a binary tree from given inorder and preorder traversal sequences.\n\nFor an almost sorted array, insertion sort can be more effective than Quicksort.\n\nSuppose T(n) is the runtime of resolving a problem with n elements, T(n) = Θ(1) if n = 1; T(n) = 2T(n/2) + Θ(n) if > 1; so T(n) is Θ(n log n).\n"},{"title":"拓扑排序算法适用于有向无环图。（  ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"如表r有100000个元素，前99999个元素递增有序，则采用（        ）方法比较次数较少。","choices":["\n折半插入排序\n","\n冒泡排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n折半插入排序\n"},{"title":"快速排序是基于比较的排序算法中平均性能最好的一种排序。（ ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  \n  对数据序列｛\n  15,9,7,8,20,-1,4\n  ｝进行排序，进行一趟后数据的排序变为｛\n  9,15,7,8,20,-1,4\n  ｝\n  ，则采用的是（\n  ）算法。\n","choices":["\n直接选择排序\n","\n冒泡排序\n","\n直接插入排序\n","\n希尔排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"快速排序总比简单排序快()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  归并排序是一种稳定的排序算法\n  。（     ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  对n个记录的文件进行快速排序，所需要的辅助存储空间大致为（    ）\n","choices":["\nO（1）\n","\nO（n）\n","\nO（1og2n）\n","\nO（n2）\n"],"correct_choice":"\nO（1og2n）\n"},{"title":"在下面几种排序方法中，空间复杂度最高的是（）","choices":["\n插入排序\n","\n选择排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"快速排序方法在()情况下最不利于发挥其长处","choices":["\n要排序的数据量太大\n","\n要排序的数据中含有多个相同值\n","\n要排序的数据个数为奇数\n","\n要排序的数据已基本有序\n"],"correct_choice":"\n要排序的数据已基本有序\n"},{"title":"以下排序中时间复杂度最差的是","choices":["\n归并排序\n","\n选择排序\n","\n希尔排序\n","\n堆排序\n"],"correct_choice":"\n选择排序\n"},{"title":"对一组数据(84,47,25,15,21)排序,数据的排列次序在排序的过程中的变化为(1)84 47 25 15 21 (2)15 47 25\n84 21 (3)15 21 25 84 47 (4)15 21 25 47 84则采用的排序方法是()","choices":["\n选择\n","\n起泡\n","\n快速\n","\n插入\n"],"correct_choice":"\n选择\n"},{"title":"在用邻接表表示图时，拓扑排序算法时间复杂度为（）","choices":["\nO(n)\n","\nO(n*n*n)\n","\nO(n*n)\n","\nO(n+e)\n"],"correct_choice":"\nO(n+e)\n"},{"title":"\n  下列排序法中，最坏情况下时间复杂度最小的是（\n  ）\n","choices":["\n堆排序\n","\n快速排序\n","\n希尔排序\n","\n冒泡排序\n"],"correct_choice":"\n堆排序\n"},{"title":"对关键码序列28,16,32,12,60,2,5,72快速排序,从小到大一次划分结果为()","choices":["\n(2,5,12,16)28(60,32,72)\n","\n(2,16,5,12)28(60,32,72)\n","\n(2,16,12,5)28(60,32,72)\n","\n(5,16,2,12)28(32,60,72)\n"],"correct_choice":"\n(2,16,5,12)28(60,32,72)\n"},{"title":"\n  用某种排序方法对关键字排序（25 、84、21、47、15、27、68、35、20）进行排序时，序列的变化情况如下：\n\n\n  \n    20、15、21、25、47、27、68、35、84\n  \n  \n    15、20、21、25、35、27、47、68、84\n  \n  \n    15、20、21、25、27、35、47、68、84\n  \n  \n    则采用的排序方法是（）\n  \n","choices":["\n选择排序\n","\n希尔排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"序列{2,1,4,9,8,10,6,20}是某排序算法第二轮排序的结果，则该算法只能是","choices":["\n快速排序\n","\n冒泡排序\n","\n选择排序\n","\n插入排序\n"],"correct_choice":"\n快速排序\n"},{"title":"输入若已经是排好序的，下列排序算法最快的是（）","choices":["\n插入排序\n","\nShell排序\n","\n合并排序\n","\n快速排序\n"],"correct_choice":"\n插入排序\n"},{"title":"\n  希尔排序的组内排序采用的是\n  （）\n  。\n","choices":["\n直接插入排序\n","\n折半插入排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"在下列排序算法中,哪一个算法的时间复杂度与初始排序无关()","choices":["\n直接插入排序\n","\n起泡排序\n","\n快速排序\n","\n直接选择排序\n"],"correct_choice":"\n直接选择排序\n"},{"title":"对于基本有序的序列，按照那种排序方式最快：","choices":["\n快速排序\n","\n冒泡排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n冒泡排序\n"},{"title":"  若有以下程序段： \n  …… \n  int a[]={4,0,2,3,1},i,j,t; \n  for(i=1;i<5;i++) \n  { \n  t=a[i]; \n  j=i-1; \n  while(j>=0&&t>a[j]) \n  { \n  a[j+1]=a[j]; \n  --j; \n  } \n  a[j+1]=t; \n  } \n  …… \n  则该程序段的功能是：       ","choices":["\n对数组a进行插入排序（升序）\n","\n对数组a进行插入排序（降序）\n","\n对数组a进行选择排序（升序）\n","\n对数组a进行选择排序（降序）\n"],"correct_choice":"\n对数组a进行插入排序（降序）\n"},{"title":"适合并行处理的排序算法是()","choices":["\n选择排序\n","\n快速排序\n","\n希尔排序\n","\n基数排序\n"],"correct_choice":"\n基数排序\n"},{"title":"对N个数进行排序,在各自最优条件下以下算法复杂度最低的是()","choices":["\n快速排序\n","\n堆排序\n","\n冒泡排序\n","\n插入排序\n","\n选择排序\n","\n归并排序\n"],"correct_choice":"\n插入排序\n"},{"title":"下面的排序算法中,不稳定的是()","choices":["\n起泡排序\n","\n折半插入排序\n","\n简单选择排序\n","\n希尔排序\n","\n基数排序\n","\n堆排序\n"],"correct_choice":"\n简单选择排序\n\n希尔排序\n\n堆排序\n"},{"title":"精俭排序，即一对数字不进行两次和两次以上的比较，以下是“精俭排序”的是","choices":["\n插入排序\n","\n归并排序\n","\n选择排序\n","\n堆排序\n"],"correct_choice":"\n插入排序\n\n归并排序\n"},{"title":"给出不同的输入序列建造二叉排序树，一定得到不同的二叉排序树。","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"\n  将7个不同的数据进行排序，至少需要比较\n  \n  次。\n\n\n  \n","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n6\n"},{"title":"下列排序算法中，某一趟结束后未必能选出一个元素放在其最终位置上的是（）","choices":["\n堆排序\n","\n冒泡排序\n","\n直接插入排序\n","\n快速排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"在以下排序算法中，关键字比较的次数与记录的初始排列次序无关的是（）。","choices":["\n希尔排序\n","\n冒泡排序\n","\n插入排序\n","\n直接选择排序\n"],"correct_choice":"\n直接选择排序\n"},{"title":"在任何情况下,归并排序都比简单插入排序快()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"用直接插入排序方法对下面4个序列进行排序(由小到大),元素比较次数最少的是()","choices":["\n94,32,40,90,80,46,21,69\n","\n32,40,21,46,69,94,90,80\n","\n21,32,46,40,80,69,90,94\n","\n90,69,80,46,21,32,94,40\n"],"correct_choice":"\n21,32,46,40,80,69,90,94\n"},{"title":"\n  下列四种排序中（）的空间复杂度最大。\n","choices":["\n插入排序\n","\n冒泡排序\n","\n堆排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"为实现快速排序算法，待排序序列宜采用的存储方式是链式存储。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"归并排序的时间复杂度（ ）","choices":["\nO(log(N))\n","\nO(N*log(N))\n","\nO(N)\n","\nO(N^2)\n"],"correct_choice":"\nO(N*log(N))\n"},{"title":"以下排序算法中是稳定的且时间复杂度最小的是：","choices":["\nbubble sort\n","\nheap sort\n","\nmerge sort\n","\nquick sort\n","\nshell sort\n"],"correct_choice":"\nmerge sort\n"},{"title":"  请指出选择排序，希尔排序，冒泡排序，快速排序的时间复杂度分别是（）  ","choices":["\nO(n^2)、O(n*log2n)、O(n^2)、O(n*log2n)\n","\nO(n^2)、O(n^2)、O(n^2)、O(n*log2n）\n","\nO(n)、O(n*log2n)、O(n^2)、O(n^2)\n","\nO(n*log2n)、O(n^2)、O(n^2)、O(n^2)\n"],"correct_choice":"\nO(n^2)、O(n*log2n)、O(n^2)、O(n*log2n)\n"},{"title":"对序列{15,9,7,8,20,-1,4}进行排序,进行一趟后数据的排列变为{4,9,-1,8,20,7,15};则采用的是()排序","choices":["\n选择\n","\n快速\n","\n希尔\n","\n起泡\n"],"correct_choice":"\n希尔\n"},{"title":"设一组初始记录关键字序列为（49,38,65,97,76,13,27,49），则以第一个关键字49为基准而得到的一趟快速排序结果是：（）","choices":["\n38，13，27，49，49，65，97，76\n","\n13，27，38，49，65，76，97，49\n","\n27，38，13，49，76，97，65，49\n","\n27，38，13，49，97，76，65，49\n"],"correct_choice":"\n27，38，13，49，76，97，65，49\n"},{"title":"两分法插入排序所需比较次数与待排序记录的初始排列状态相关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"排序方法中，从未排序序列中挑选元素，并将其一次插入已排序序列（初始时为空）的一端的方法，称为（）。","choices":["\n希尔排序\n","\n归并排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"对关键码序列28,16,32,12,60,2,5,72快速排序，从小到大一次划分结果为()","choices":["\n(5,16,2,12)28(60,32,72)\n","\n(2,5,12,16)28(60,32,72)\n","\n(2,16,12,5)28(60,32,72)\n","\n(5,16,2,12)28(32,60,72)\n"],"correct_choice":"\n(5,16,2,12)28(60,32,72)\n"},{"title":"已知待排序的n个元素可分为n/k个组,每个组包含k个元素,且任一组内的各元素均分别大于前一组内的所有元素和小于后一组内的所有元素,若采用基于比较的排序,其时间下界应为()","choices":["\nO(nlog2n)\n","\nO(nlog2k)\n","\nO(klog2n)\n","\nO(klog2k)\n"],"correct_choice":"\nO(nlog2k)\n"},{"title":"  下列排序算法中，初始化数组集的排序顺序对算法的性能无影响的是 ()  ","choices":["\n插入排序\n","\n选择排序\n","\nshell排序\n","\n快速排序\n"],"correct_choice":"\n选择排序\n"},{"title":"  冒泡排序算法的时间复杂度是什么？ ","choices":["\nO(N*N)\n","\nO(N)\n","\nO(log2​N)\n","\nO(Nlog2​N)\n"],"correct_choice":"\nO(N*N)\n"},{"title":"\n  对序列（\n  15\n  ，\n  9\n  ，\n  7\n  ，\n  8\n  ，\n  20\n  ，\n  -1\n  ，\n  4\n  ）进行排序，进行一趟排序后，数据的排列变为（\n  4\n  ，\n  9\n  ，\n  7\n  ，\n  8\n  ，\n  -1\n  ，\n  15\n  ，\n  20\n  ），则采用的是（ \n  ）排序。 \n","choices":["\n选择排序\n","\n快速排序\n","\n希尔排序\n","\n冒泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"快速排序的期望运行时间复杂度是__________。","choices":["\nO(n^2)\n","\nO(n log n)\n","\nO(n)\n","\nO(2^n)\n"],"correct_choice":"\nO(n log n)\n"},{"title":"\n    一组记录的值为(12,38,35,25,74,50,63,90),按2路归并排序方法对序列进行一趟归并后的结果为( \n       )\n","choices":["\n12,38,25,35,50,74,63,90\n","\n12,38,35,25,74,50,63,90\n","\n12,25,35,38,50,74,63,90\n","\n12,35,38,25,63,50,74,90\n"],"correct_choice":"\n12,38,25,35,50,74,63,90\n"},{"title":"  冒泡排序的时间复杂度（ ）。  ","choices":["\nO(n)\n","\nO(n^2)\n","\nO(nlog2(n))\n","\nO(log2(n))\n"],"correct_choice":"\nO(n^2)\n"},{"title":"\n  排序的方法有很多种，（）法是基于选择排序的一种方法，是完全二叉树结构的一个重要应用。\n","choices":["\n快速排序\n","\n插入排序\n","\n归并排序\n","\n选择排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"下列哪种排序方法在最坏情况下的时间复杂度是nlgn? ","choices":["\n归并排序\n","\n快速排序\n","\n冒泡排序\n","\n插入排序\n"],"correct_choice":"\n归并排序\n"},{"title":"就分类算法所用的辅助空间而言,堆分类、快速分类和归并分类的关系是()","choices":["\n堆分类<快速分类<归并分类\n","\n堆分类<归并分类<快速分类\n","\n堆分类>归并分类>快速分类\n","\n堆分类>快速分类>归并分类\n"],"correct_choice":"\n堆分类<快速分类<归并分类\n"},{"title":"设一组初始关键字记录关键字为（19,15,12,18,21,36,45,10),则以19位基准记录的一趟快速排序结束后的结果为()","choices":["\n10,15,12,18,19,36,45,21\n","\n10,15,12,18,19,45,36,21\n","\n15,10,12,18,19,36,45,21\n","\n10,15,12,19,18,45,36,21\n"],"correct_choice":"\n10,15,12,18,19,36,45,21\n"},{"title":"下列排序算法中,其中()是稳定的","choices":["\n堆排序,起泡排序\n","\n快速排序,堆排序\n","\n直接选择排序,归并排序\n","\n归并排序,起泡排序\n"],"correct_choice":"\n归并排序,起泡排序\n"},{"title":"稳定的排序方法是()","choices":["\n直接插入排序和快速排序\n","\n折半插入排序和起泡排序\n","\n简单选择排序和四路归并排序\n","\n树形选择排序和希尔排序\n"],"correct_choice":"\n折半插入排序和起泡排序\n"},{"title":"堆排序的时间复杂度是（），堆排序中建堆过程的时间复杂度是（）。","choices":["\nO(n2),O(n log n)\n","\nO(n),O(n log n)\n","\nO(n log n),(n)\n","\nO(n log n),O(n log n)\n"],"correct_choice":"\nO(n log n),(n)\n"},{"title":"使用堆排序方法排序（45，78，57，25，41，89），初始堆为（？）","choices":["\n78,45,57,25,41,89\n","\n89,78,57,25,41,45\n","\n89,78,25,45,41,57\n","\n89,45,78,41,57,25\n"],"correct_choice":"\n89,78,57,25,41,45\n"},{"title":"无向图G=（V E），其中V={a,b,c,d,e,f},E={<a,b>,<a,e>,<a,c>,<b,e>,<c,f>,<f,d>,<e,d>}对该图进行深度优先排序，得到的顶点序列正确的是（）","choices":["\na，b，e，c，d，f\n","\na，c，f，e，b，d\n","\na，e，b，c，f，d\n","\na，e，d，f，c，b\n"],"correct_choice":"\na，e，d，f，c，b\n"},{"title":"现有一数列{3, 2, 5, 7, 6, 8}，要求按升序排序，下面说法正确的是：","choices":["\n插入排序（从后向前）需要做6次比较\n","\n快速排序，每次选择最后一个元素作为支点，需要比较5次\n","\n快速排序，每次选择最后一个元素作为支点，需要比较9次\n","\n快速排序，每次选择最后一个元素作为支点，需要比较12次\n"],"correct_choice":"\n快速排序，每次选择最后一个元素作为支点，需要比较12次\n"},{"title":"对下列四种排序方法,在排序中关键字比较次数同记录初始排列无关的是()","choices":["\n直接插入\n","\n折半插入\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n折半插入\n"},{"title":"在含有10个结点的二叉排序树上，查找关键字为20的结点，则依次比较的关键字有可能是（      ）","choices":["\n25,10,15,20\n","\n25,10,15,18,20\n","\n10,30,20\n","\n10,30,25,20\n"],"correct_choice":"\n25,10,15,20\n\n25,10,15,18,20\n\n10,30,20\n\n10,30,25,20\n"},{"title":"\n  Shell排序是一种什么排序。 \n\n\n  \n","choices":["\n插入\n","\n.选择\n","\n交换\n","\n归并\n"],"correct_choice":"\n插入\n"},{"title":"\n  设一组初始记录关键字序列(5，2，6，3，8)，以第一个记录关键字5为基准进行一趟快速排序的结果为（）。\n","choices":["\n2，3，5，8，6\n","\n3，2，5，8，6\n","\n3，2，5，6，8\n","\n2，3，6，5，8\n"],"correct_choice":"\n3，2，5，6，8\n"},{"title":"假设二叉排序树的定义是：1、若它的左子树不为空，则左子树所有节点均小于它的根节点的值；2、若右子树不为空，则右子树所有节点的值均大于根节点的值；3、它的左右子树也分别为二叉排序树。下列哪种遍历之后得到一个递增有序数列（）","choices":["\n前序遍历\n","\n中序遍历\n","\n后序遍历\n","\n广度遍历\n"],"correct_choice":"\n中序遍历\n"},{"title":"在待排数据基本有序的情况下,快速排序效果最好()","choices":["\n错\n","\n对\n"],"correct_choice":"\n错\n"},{"title":"通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入的排序算法是（）","choices":["\n归并排序\n","\n选择排序\n","\n希尔排序\n","\n插入排序\n"],"correct_choice":"\n插入排序\n"},{"title":"排序算法的稳定性是指()","choices":["\n经过排序之后,能使值相同的数据保持原顺序中的相对位置不变\n","\n经过排序之后,能使值相同的数据保持原顺序中的绝对位置不变\n","\n算法的排序性能与被排序元素的数量关系不大\n","\n算法的排序性能与被排序元素的数量关系密切\n"],"correct_choice":"\n经过排序之后,能使值相同的数据保持原顺序中的相对位置不变\n"},{"title":"为提高排序速度,进行外排序时,必须选用最快的内排序算法()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"有字符序列（Q,H,C,Y,P,A,M,S,R,D,F,X）,新序列（F,H,C,D,P,A,M,Q,R,S,Y,X）是下列（）排序算法一趟扫描结果。","choices":["\n堆排序\n","\n快速排序\n","\n希尔排序\n","\n冒泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"已知有向图G=(V,E),其中V={V1\n,V2\n,V3\n,V4\n,V5\n,V6\n,V7\n},E={(V1\n,V2\n),(V1\n,V3\n),(V1\n,V4\n),(V2\n,V5\n),(V3\n,V5\n),(V3\n,V6\n),(V4\n,V6\n),(V5\n,V7\n),(V6\n,V7\n)},G的拓扑序列是()","choices":["\nV1,V3,V4,V6,V2,V5,V7\n","\nV1,V3,V2,V6,V4,V5,V7\n","\nV1,V3,V4,V5,V2,V6,V7\n","\nV1,V2,V5,V3,V4,V6,V7\n"],"correct_choice":"\nV1,V3,V4,V6,V2,V5,V7\n"},{"title":"\n  下列排序算法中，元素的移动次数与关键字的初始排列次序无关的是\n  （）\n  。\n","choices":["\n直接插入排序\n","\n起泡排序\n","\n基数排序\n","\n快速排序\n"],"correct_choice":"\n基数排序\n"},{"title":"在外排序过程中,对长度为n的初始序列进行\"置换-选择\"排序时,可以得到的最大初始有序段的长度不超过n/2()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  将整数数组（\n  7-6-3-5-4-1-2\n  ）按照堆排序的方式进行升序排列，请问在第一轮排序结束之后，数组的顺序是（）\n","choices":["\n1-2-3-4-5-6-7\n","\n2-6-3-5-4-1-7\n","\n6-5-3-2-4-1-7\n","\n5-4-3-2-1-6-7\n"],"correct_choice":"\n6-5-3-2-4-1-7\n"},{"title":"有字符序列（Q,H,C,Y,P,A,M,S,R,D,F,X）,新序列（F,H,C,D,A,M,P,S,R,Y,Q,X）是下列（ ）排序算法一趟扫描结果。","choices":["\n堆排序\n","\n快速排序\n","\n希尔排序\n","\n冒泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"下列哪个算法是对一个list排序的最快方法（）","choices":["\n快速排序\n","\n冒泡排序\n","\n二分插入排序\n","\n线性排序\n"],"correct_choice":"\n快速排序\n"},{"title":"  下列说法错误的是（）  ","choices":["\n已知一颗二叉树的前序遍历顺序和后序遍历顺序，可以唯一确定这棵二叉树\n","\n将一个递归算法改为非递归算法时，通常使用队列作为辅助结构\n","\n快速排序和堆排序都是不稳定排序\n","\n二分查找法，平均时间复杂度为O(n)\n"],"correct_choice":"\n已知一颗二叉树的前序遍历顺序和后序遍历顺序，可以唯一确定这棵二叉树\n\n将一个递归算法改为非递归算法时，通常使用队列作为辅助结构\n\n二分查找法，平均时间复杂度为O(n)\n"},{"title":"有关选择排序的叙述中正确的是（      ）","choices":["\n每扫描一遍数组，只需要一次交换\n","\n每扫描一遍数组，需要多次交换\n","\n选择排序是稳定的排序方法\n","\n空间复杂度为O(1)\n"],"correct_choice":"\n每扫描一遍数组，只需要一次交换\n\n空间复杂度为O(1)\n"},{"title":"在下列表述中,()是错误的","choices":["\n含有一个或多个空格字符的串称为空串\n","\n对n(n>0)个顶点的网,求出权最小的n-1条边便可构成其最小生成树\n","\n选择排序算法是不稳定的\n","\n平衡二叉树的左右子树的结点数之差的绝对值不超过1\n"],"correct_choice":"\n含有一个或多个空格字符的串称为空串\n\n对n(n>0)个顶点的网,求出权最小的n-1条边便可构成其最小生成树\n\n平衡二叉树的左右子树的结点数之差的绝对值不超过1\n"},{"title":"\n  在下述排序方法中，不属于内排序方法的是\n  \n\n\n  \n","choices":["\n插入排序法\n","\n选择排序法\n","\n拓扑排序法\n","\n归并排序法\n"],"correct_choice":"\n拓扑排序法\n"},{"title":"\n  对待排序的元素序列进行划分，将其分为左、右两个子序列，再对两个子序列施加同样的排序操作，直到子序列为空或只剩一个元素为止。这样的排序方法是 _________。\n","choices":["\n直接选择排序\n","\n直接插入排序\n","\n快速排序\n","\n起泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"任何有向图的结点都可以排成拓扑排序，而且拓扑序列不唯一。（  ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"在待排序的记录集中，存在多个具有相同键值的记录，若经过排序，这些记录的相对次序仍然保持不变，称这种排序为稳定排序，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n正确\n"},{"title":"冒泡排序算法在非有序的序列中时间复杂度是？（ ）\n","choices":["\nO(nlogn)\n","\nO(n^2)\n","\nO(n)\n","\nO(n^2logn)\n"],"correct_choice":"\nO(n^2)\n"},{"title":"若给定的关键字集合为{20,15,14,18,21,36,40,10}，一趟快速排序结束时，键值的排序为","choices":["\n10,15,14,18,20,36,40,21\n","\n10,15,14,18,20,40,36,21\n","\n10,15,14,20,18,40,36,21\n","\n15,10,14,18,20,36,40,21\n"],"correct_choice":"\n10,15,14,18,20,36,40,21\n"},{"title":"二叉排序树删除一个结点后，仍是二叉排序树。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  一组记录的关键字为（46，79，56，38，40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（）。 ","choices":["\n38，40，46，56，84，79\n","\n40，38，46，79，56，84\n","\n40，38，46，56，79，84\n","\n40，38，46，84，56，79\n"],"correct_choice":"\n40，38，46，56，79，84\n"},{"title":"若中序遍历平衡的二叉排序树,可得到排好序的关键码序列()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"下列排序算法中()排序在一趟结束后不一定能选出一个元素放在其最终位置上","choices":["\n选择\n","\n起泡\n","\n归并\n","\n堆\n"],"correct_choice":"\n归并\n"},{"title":"具有n个整数的数组A=[27，9，14，16，10]使用冒泡排序（Bubble\nSort）算法排序，算法伪代码如下：\n\n经过三趟排序后，数组A的排列状态将是（）","choices":["\n9，10，14，16，27\n","\n9，14，16，10，27\n","\n9，14，10，16，27\n","\n9，16，10，14，27\n"],"correct_choice":"\n9，10，14，16，27\n"},{"title":"有环图也能进行拓扑排序()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  为实现快速排序算法，待排序序列宜采用的存储方式是（）。\n  \n    \n  \n","choices":["\n顺序存储\n","\n散列存储\n","\n链式存储\n","\n索引存储\n"],"correct_choice":"\n顺序存储\n"},{"title":"对n个元素的数组进行快速排序，所需要的额外空间为?","choices":["\nO(1)\n","\nO(n)\n","\nO(logn)\n","\nO(n^2))\n"],"correct_choice":"\nO(logn)\n"},{"title":"下列四种排序中()的空间复杂度最大","choices":["\n快速排序\n","\n冒泡排序\n","\n希尔排序\n","\n堆\n"],"correct_choice":"\n快速排序\n"},{"title":"排序时，若不采用计数排序的等空间换时间的方法，合并m个长度为n的已排序数组的时间复杂度最优为（）\n","choices":["\nO(mn(logm))\n","\nO(mlog(n))\n","\nO(nm^2)\n","\nO(nm)\n"],"correct_choice":"\nO(mn(logm))\n"},{"title":"\n  #\n  判断正误\n  #\n\n\n  快速排序总比简单排序快。\n","choices":["\n√\n","\n×\n"],"correct_choice":"\n×\n"},{"title":"\n  对\n  n\n  个记录的文件进行快速排序，所需要的辅助存储空间大致为\n\n","choices":["\nO（1）\n","\nO（n）\n","\nO（1og2n）\n","\nO（n2）\n"],"correct_choice":"\nO（1og2n）\n"},{"title":"\n  下面的排序算法中，稳定是\n  \n\n\n  \n","choices":["\n直接插入排序法\n","\n快速排序法\n","\n直接选择排序法\n","\n堆排序法\n"],"correct_choice":"\n直接插入排序法\n"},{"title":"冒泡排序算法在非有序的序列中时间复杂度是？（）\n","choices":["\nO(nlogn)\n","\nO(n^2)\n","\nO(n)\n","\nO(n^2logn)\n"],"correct_choice":"\nO(n^2)\n"},{"title":"\n  一趟排序结束后不一定能够选出一个元素放在其最终位置上的是（）。\n","choices":["\n堆排序\n","\n冒泡排序\n","\n快速排序\n","\n希尔排序\n"],"correct_choice":"\n希尔排序\n"},{"title":"\n  排序方法中，将整个无序序列分割成若干小的子序列并分别进行插入排序的方法是（）\n","choices":["\n希尔排序\n","\n冒泡排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n希尔排序\n"},{"title":"快速排序和归并排序在最坏情况下的比较次数都是O(nlog2\nn)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"线性表的长度为10，在最坏情况下，冒泡排序需要比较次数为（）。","choices":["\n40\n","\n42\n","\n44\n","\n45\n"],"correct_choice":"\n45\n"},{"title":"下列排序方法中，属于稳定排序的是（）","choices":["\n选择排序\n","\n希尔排序\n","\n堆排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"用某种排序方法对关键字序列（25,84,21,47,15,27,68,35,20）进行排序，序列的变化情况采样如下：\n 20,15,21,25,47,27,68,35,84\n 15,20,21,25,35,27,47,68,84\n 15,20,21,25,27,35,47,68,84\n 请问采用的是以下哪种排序算法（）\n\n  \n","choices":["\n选择排序\n","\n希尔排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"\n  假设你只有100MB的内存，需要对1GB的数据进行排序，最合适的算法是（）\n","choices":["\n归并排序\n","\n插入排序\n","\n冒泡排序\n","\n快速排序\n"],"correct_choice":"\n归并排序\n"},{"title":"25，84，21，47，15，27，68，35，20进行排序时，变化为“20，15，21，25，47，27，68，35，84”“15，20，21，25，35，27，47，68，84”“15，20，21，25，27，35，47，68，84”的排序方法是（）？","choices":["\n选择排序\n","\n希尔排序\n","\n归并\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"关于排序算法的以下说法，错误的是______。","choices":["\n快速排序的平均时间复杂度为O（nlogn），最坏时间复杂度为O（n2）\n","\n堆排序的平均时间复杂度为O（nlogn），最坏时间复杂度为O（nlogn）\n","\n冒泡排序的平均时间复杂度为O（n2），最坏时间复杂度为O（n2）\n","\n归并排序的平均时间复杂度为O（nlogn），最坏时间复杂度为O（n2）\n"],"correct_choice":"\n归并排序的平均时间复杂度为O（nlogn），最坏时间复杂度为O（n2）\n"},{"title":"排序算法中，比较次数与初始序列无关的排序方法有哪些？","choices":["\nshell排序\n","\n快速排序\n","\n堆排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"下列排序算法中元素的移动次数和关键字的初始排列次序无关的是()","choices":["\n直接插入排序\n","\n起泡排序\n","\n基数排序\n","\n快速排序\n"],"correct_choice":"\n基数排序\n"},{"title":"某地电信局要对业务号码进行梳理，需要检测开通的市话号码是否存在某一个是另一个的前缀的情况，以简化电话交换机的逻辑。例如：某用户号码是“11001100”，但与\"110\"报警电话产生前缀配对。已知市话号码最长8位，最短3位，并且所有3位的电话号码都以1开头。由于市话号码众多，长度也未必一直，高效的算法可以用O(n)的时间复杂度完成检测（n为开通市话号码个数，数量是千万级的）。那么，该算法最坏情况下需要耗费大约________内存空间。","choices":["\n5GB\n","\n500MB\n","\n50MB\n","\n5MB\n"],"correct_choice":"\n50MB\n"},{"title":"在排序算法中每一项都与其他各项进行比较,计算出小于该项的项的个数,以确定该项的位置叫()","choices":["\n插入排序\n","\n枚举排序\n","\n选择排序\n","\n交换排序\n"],"correct_choice":"\n枚举排序\n"},{"title":"关于计数排序的叙述中正确的是（      ）","choices":["\n计数排序是一种基于比较的排序算法\n","\n计数排序的时间复杂度为O(n+k)\n","\n计数排序的空间复杂度为 O(k)\n","\n计数算法是原地排序算法\n"],"correct_choice":"\n计数排序的时间复杂度为O(n+k)\n\n计数排序的空间复杂度为 O(k)\n"},{"title":"\n  若一组记录的排序码为（46, 79, 56, 38, 40, 84），则利用快速排序，以第一个记录为基准得到的一次划分结果是 \n","choices":["\n38, 40, 46, 56, 79, 84\n","\n40，38, 46 ,79, 56, 84\n","\n40, 38，46, 56, 79, 84\n","\n40, 38，46，84, 56, 79\n"],"correct_choice":"\n40, 38，46, 56, 79, 84\n"},{"title":"  下面给出的四种排序法中（）排序法是不稳定性排序法。 ","choices":["\n插入\n","\n冒泡\n","\n归并\n","\n堆，希尔排序，快速排序\n"],"correct_choice":"\n堆，希尔排序，快速排序\n"},{"title":"\n  在最好情况下，下列排序算法中（）\n  排序算法所需比较关键字次数最少。\n\n\n  \n    \n  \n","choices":["\n基数排序\n","\n直接插入排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"若给定的关键字合集为{20,15,14,18,21,36,40,10}，一趟快速排序结束时，数据的排序为（）","choices":["\n10,15,14,18,20,36,40,21\n","\n10,15,14,18,20,40,36,21\n","\n10,15,14,20,18,40,36,21\n","\n15,10,14,18,20,36,40,21\n"],"correct_choice":"\n10,15,14,18,20,36,40,21\n"},{"title":"以下哪种排序算法对[1, 3, 2, 4, 5, 6, 7, 8, 9]进行排序最快","choices":["\n改良的冒泡排序\n","\n快速排序\n","\n归并排序\n","\n堆排序\n"],"correct_choice":"\n改良的冒泡排序\n"},{"title":"关于排序算法下列说法正确的是：","choices":["\n快速排序在被排序的数据完全无序时最易发挥其长处\n","\n快速排序是稳定的排序算法\n","\n堆排序最好情况和最坏情况下时间复杂度不同\n","\n快速排序所需的辅助空间少于堆排序\n"],"correct_choice":"\n快速排序在被排序的数据完全无序时最易发挥其长处\n"},{"title":"输入若已经是排好序的（升序），下列排序算法最快的是（） ","choices":["\n插入排序\n","\nShell排序\n","\n合并排序\n","\n快速排序\n"],"correct_choice":"\n插入排序\n"},{"title":"  下面排序算法属于稳定排序且时间复杂度为 O (nlogn)的是（）  ","choices":["\n快速排序\n","\n冒泡排序\n","\n堆排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"将一个从大到小的数组，用以下排序方法排序成从小到大的，（）最快。","choices":["\n插入排序\n","\n冒泡排序\n","\n快速排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"  假设你只有100Mb的内存，需要对1Gb的数据进行排序，最合适的算法是？ ","choices":["\n归并排序\n","\n插入排序\n","\n快速排序\n","\n冒泡排序\n"],"correct_choice":"\n归并排序\n"},{"title":"下列排序算法中,()算法可能会出现下面的情况:初始数据有序时,花费的时间反而最多","choices":["\n快速排序\n","\n堆排序\n","\n希尔排序\n","\n起泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"下列排序算法中，其时间复杂度和记录的初始排列无关的是","choices":["\n插入排序\n","\n堆排序\n","\n快速排序\n","\n冒泡排序\n"],"correct_choice":"\n堆排序\n"},{"title":"一组记录的关键码为(46,79,56,38,40,84),则利用快速排序的方法,以第一个记录为基准得到的一次划分结果为()","choices":["\n(38,40,46,56,79,84)\n","\n(40,38,46,79,56,84)\n","\n(40,38,46,56,79,84)\n","\n(40,38,46,84,56,79)\n"],"correct_choice":"\n(40,38,46,56,79,84)\n"},{"title":"下列哪种排序算法是不稳定算法","choices":["\n归并排序\n","\n插入排序\n","\n堆排序\n","\n快速排序\n"],"correct_choice":"\n堆排序\n\n快速排序\n"},{"title":"\n  由关键字序列（12，7，36，25，18，2）构造一棵二叉排序树（初始为空，第一个关键字作为根结点插入，此后对于任意关键字，若小于根结点的关键字，则插入左子树中；若大于根结点的关键字，则插入右子树中，且左、右子树均为二叉排序树），该二叉排序树的高度（层数）为（）。 ","choices":["\n6\n","\n5\n","\n4\n","\n3\n"],"correct_choice":"\n4\n"},{"title":"\n  排序算法中的比较次数与初始元素序列的排列无关。\n","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"对任何用顶点表示活动的网络（AOV网）进行拓扑排序的结果都是唯一的（）。 ","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"  能实现“在 n 个数中选出最大的 m 个数（ 3<m<n ）”的算法中，时间复杂度最小的算法是？  ","choices":["\nO(n)\n","\nO(nlogn)\n","\nO(mlogn)\n","\nO(logn)\n"],"correct_choice":"\nO(n)\n"},{"title":"当待排序记录已经从小到大排序或者已经从大到小排序时,快速排序的执行时间最省()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"体育课的铃声响了，同学们都陆续地奔向操场，按老师的要求从高到矮站成一排。每个同学按顺序来到操场时，都从排尾走向排头，找到第一个比自己高的同学，并站到他的后面，这种站队的方法类似下列哪种算法？","choices":["\n快速排序\n","\n插入排序\n","\n冒泡排序\n","\n归并排序\n"],"correct_choice":"\n插入排序\n"},{"title":"一个有向无环图的拓扑排序序列()是唯一的","choices":["\n一定\n","\n不一定\n"],"correct_choice":"\n不一定\n"},{"title":"下列序排算法中最坏复杂度不是n(n-1)/2的是？","choices":["\n快速排序\n","\n冒泡排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"下列排序算法中，在待排序数据有序的情况下，花费时间最多的是（ ）","choices":["\n快速排序\n","\n希尔排序\n","\n冒泡排序\n","\n堆排序\n"],"correct_choice":"\n快速排序\n"},{"title":"有字符序列 ｛Q,H,C,Y,P,A,M,S,R,D,F,X｝ ,新序列{F,H,C,D,P,A,M,Q,R,S,Y,X}，是下列____排序算法一趟扫描的结果。","choices":["\n二路归并排序\n","\n快速排序\n","\n步长为 4 的希尔排序\n","\n步长为 2 的希尔排序\n","\n冒泡排序\n","\n堆排序\n"],"correct_choice":"\n快速排序\n"},{"title":"哪种排序算法最坏情况下是最快的?()","choices":["\n冒泡排序\n","\n希尔排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n归并排序\n"},{"title":"下列说法中错误的是：（）","choices":["\n插入排序某些情况下复杂度为O（n）\n","\n排序二叉树元素查找的复杂度可能为O（n）\n","\n对于有序列表的排序最快的是快速排序\n","\n在有序列表中通过二分查找的复杂度一定是O（log2n）\n"],"correct_choice":"\n对于有序列表的排序最快的是快速排序\n"},{"title":"如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列,用()方法最快","choices":["\n起泡排序\n","\n快速排序\n","\n希尔排序\n","\n堆排序\n","\n简单选择排序\n"],"correct_choice":"\n堆排序\n"},{"title":"基于比较方法的n个数据的内部排序。最坏情况下的时间复杂度能达到的最好下界是()","choices":["\nO(nlogn)\n","\nO(logn)\n","\nO(n)\n","\nO(n*n)\n"],"correct_choice":"\nO(nlogn)\n"},{"title":"在执行某个排序算法过程中,出现了排序码朝着最终排序序列位置相反方向移动,则该算法是不稳定的()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"在排序算法中,每次从未排序的记录中挑出最小(或最大)关键码字的记录,加入到已排序记录的末尾,该排序方法是()","choices":["\n选择\n","\n起泡\n","\n插入\n","\n快排\n"],"correct_choice":"\n选择\n"},{"title":"以下属于稳定排序的是（）","choices":["\n归并排序和基数排序\n","\n快速排序和堆排序\n","\n选择排序和希尔排序\n","\n插入排序和冒泡排序\n"],"correct_choice":"\n归并排序和基数排序\n\n插入排序和冒泡排序\n"},{"title":"  现有N条词以及对应的拼音串，对其排序，排序规则：首先按拼音串的字母序排序，如果拼音串相同，则按当前词所在的顺序排序，下列哪些排序算法符合条件？（    ）  ","choices":["\n插入排序\n","\n快速排序\n","\n堆排序\n","\n冒泡排序\n"],"correct_choice":"\n插入排序\n\n冒泡排序\n"},{"title":"\n  关于数据结构，下面叙述中正确的是（）\n","choices":["\n直接选择排序是一种稳定的排序方法\n","\n哈弗曼树带权路径长度最短的树，路径上权值较大的结点离根较近\n","\n拓扑排序是指结点值得有序排序\n","\n当从一个最小堆中删除一个元素时，需要把堆尾元素填补到堆顶位置，然后再按条件把它逐层向下调整到合适位置\n"],"correct_choice":"\n哈弗曼树带权路径长度最短的树，路径上权值较大的结点离根较近\n\n当从一个最小堆中删除一个元素时，需要把堆尾元素填补到堆顶位置，然后再按条件把它逐层向下调整到合适位置\n"},{"title":"排序趟数与序列的原始状态有关的排序方法是()排序法","choices":["\n插入\n","\n选择\n","\n优化的起泡\n","\n快速\n"],"correct_choice":"\n优化的起泡\n\n快速\n"},{"title":"希尔排序每的最后一趟排序的地址增量一定是（      ）。","choices":["\nn\n","\nn/2\n","\n1\n","\n任意值\n"],"correct_choice":"\n1\n"},{"title":"以下哪种排序是不稳定排序：","choices":["\n冒泡\n","\n插入排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"下面的哪种排序算法在算复杂度平均不是O(nlogn)的?","choices":["\n快速排序\n","\n桶排序\n","\n合并排序\n","\n二叉树排序树排序\n","\n堆排序\n"],"correct_choice":"\n桶排序\n"},{"title":"\n  设一组初始关键字记录关键字为（\n  12,15,1,18,2,35,30,11\n  ），则以\n  12\n  为基准记录的一趟快速排序结束后的结果为\n","choices":["\n11，1，2，12，35，18，30，15\n","\n11，2，1，12，15，18，35，30\n","\n1，2，11，12，15，18，35，30\n","\n11，2，1，12，18，35，30，15\n","\n1，2，11，12，15，18，30，35\n","\n以上都不是\n"],"correct_choice":"\n11，2，1，12，18，35，30，15\n"},{"title":"()占用的额外空间的空间复杂性为O(1)","choices":["\n堆排序算法\n","\n归并排序算法\n","\n快速排序算法\n","\n以上答案都不对\n"],"correct_choice":"\n堆排序算法\n"},{"title":"已知数据表Ａ中每个元素距其最终位置不远，为了节省时间，应采用的算法是？\n","choices":["\n快速排序\n","\n直接选题排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"对下列关键字序列用快速排序法进行排序时,速度最快的情形是()","choices":["\n{21,25,5,17,9,23,30}\n","\n{25,23,30,17,21,5,9}\n","\n{21,9,17,30,25,23,5}\n","\n{5,9,17,21,23,25,30}\n"],"correct_choice":"\n{21,25,5,17,9,23,30}\n"},{"title":"任何一个基于\"比较\"的内部排序的算法，若对6个元素进行排序，则在最坏情况下所需的比较次数至少为？","choices":["\n9\n","\n10\n","\n11\n","\n36\n"],"correct_choice":"\n10\n"},{"title":"基于比较的排序算法是（      ）","choices":["\n基数排序\n","\n冒泡排序\n","\n桶排序\n","\n希尔排序\n"],"correct_choice":"\n冒泡排序\n\n希尔排序\n"},{"title":"下列排序算法的常规实现中，哪些空间复杂度是O(1)","choices":["\n冒泡\n","\n选择\n","\n归并\n","\n快排\n","\n堆排序\n"],"correct_choice":"\n冒泡\n\n选择\n\n堆排序\n"},{"title":"  某种排序方法对关键字序列（33,12,44,10,6,8,17）进行排序时，前三趟排序的结果如下：     6，12，44，10，33，8，17     6，8，44，10，33，12，17     6，8，10，44，33，12，17     则采用的排序方法是（）  ","choices":["\n希尔排序\n","\n归并排序\n","\n快速排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"\n  设有\n  1000\n  个基本有序的元素，希望用最快的速度挑选出其中前\n  10\n  个最大的元素，最后选用（ \n   ）排序法。\n","choices":["\n冒泡排序\n","\n快速排序\n","\n直接插入排序\n","\n归并排序\n"],"correct_choice":"\n冒泡排序\n"},{"title":"  排序方法中，从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已排序序列的正确位置上的方法，称为         。  ","choices":["\n希尔排序\n","\n冒泡排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n插入排序\n"},{"title":"下列排序算法中，某一趟结束后未必能选出一个元素放在其最终位置上的是（）。","choices":["\n堆排序\n","\n冒泡排序\n","\n快速排序\n","\n直接插入排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"对关键字序列（49，38，65，97，76，13，27，50）以49为枢轴进行快速排序，则第一趟排序结果序列是\n  {27，38，13}，49，{76，97，65，50}。 （）","choices":["\n是\n","\n否\n"],"correct_choice":"\n是\n"},{"title":"\n  对一组数据（2，12，16，88，5，10）进行排序，若前三趟排序结果如下（）\n\n\n  第一趟\n  ：\n  2，12，16，5，10，88\n\n\n  第二趟\n  ：\n  2，12，5，10，16，88\n\n\n  第三趟\n  ：\n  2，5，10，12，16，88\n\n\n  则采用的排序方法可能是\n  （）\n","choices":["\n冒泡排序\n","\n希尔排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n冒泡排序\n"},{"title":"采用简单选择排序,比较次数与移动次数分别为()","choices":["\nO(n),O(logn)\n","\nO(logn),O(n*n)\n","\nO(n*n),O(n)\n","\nO(nlogn),O(n)\n"],"correct_choice":"\nO(n*n),O(n)\n"},{"title":"有 1000 个无序的整数，希望使用最快的方式找出前 50 个最大的，最佳的选择是（ ）","choices":["\n冒泡排序\n","\n基数排序\n","\n堆排序\n","\n快速排序\n"],"correct_choice":"\n堆排序\n"},{"title":"下列哪种排序需要的附加存储开销最大（）","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n插入排序\n"],"correct_choice":"\n归并排序\n"},{"title":"在所有排序方法中，关键字比较的次数与记录的初始排列次序无关的是（）","choices":["\n希尔排序\n","\n冒泡排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n选择排序\n"},{"title":"归并排序在任何情况下都比所有简单排序速度快()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对序列{15,9,7,8,20,-1,4}用希尔排序方法排序,经一趟后序列变为{15,-1,4,8,20,9,7}则该次采用的增量是()","choices":["\n1\n","\n4\n","\n3\n","\n2\n"],"correct_choice":"\n4\n"},{"title":"在用邻接表表示图时,拓扑排序算法时间复杂度为()","choices":["\nO(n)\n","\nO(n+e)\n","\nO(n*n)\n","\nO(n*n*n)\n"],"correct_choice":"\nO(n+e)\n"},{"title":"设被排序的结点序列共有N个结点,在该序列中的结点已十分接近排序的情况下,用直接插入法,归并法和一般的快速排序法对其排序,这些算法的时间复杂性为()","choices":["\nO(N),O(N),O(N)\n","\nO(N),O(N*log2N),O(N*log2N)\n","\nO(N),O(N*log2N),O(N2)\n","\nO(N2),O(N*log2N),O(N2)\n"],"correct_choice":"\nO(N),O(N*log2N),O(N2)\n"},{"title":"基数分类只适用于以数字为关键字的情况,不适用于以字符串为关键字的情况()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"设某文件经内排序后得到100个初始归并段（初始顺串），若使用多路归并排序算法，且要求三趟归并完成排序，问归并路数最少为","choices":["\n8\n","\n7\n","\n6\n","\n5\n"],"correct_choice":"\n5\n"},{"title":"将一组无序的正整数重新排列成有序序列,其方法有()","choices":["\n拓扑排序\n","\n快速排序\n","\n堆排序\n","\n基数排序\n"],"correct_choice":"\n快速排序\n\n堆排序\n\n基数排序\n"},{"title":"\n  设一组初始记录关键字序列为(25，50，15，35，80，85，20，40，36，70)，其中含有5个长度为2的有序子表，则用归并排序的方法对该记录关键字序列进行一趟归并后的结果为（\n    ）。 ","choices":["\n15，25，35，50，20，40，80，85，36，70\n","\n15，25，35，50，80，20，85，40，70，36\n","\n15，25，35，50，80，85，20，36，40，70\n","\n15，25，35，50，80，20，36，40，70，85\n"],"correct_choice":"\n15，25，35，50，20，40，80，85，36，70\n"},{"title":"快速排序在下列哪种情况下最易发挥其长处\n","choices":["\n被排序的数据已基本有序\n","\n被排序的数据完全无序\n","\n被排序的数据中含有多个相同的排序码\n","\n被排序的数据中的最大值和最小值相差悬殊\n"],"correct_choice":"\n被排序的数据完全无序\n"},{"title":"下面给出的四种排序法中()排序法是不稳定性排序法","choices":["\n插入\n","\n起泡\n","\n二路归并\n","\n堆\n"],"correct_choice":"\n堆\n"},{"title":"将两个各有n个元素的有序表归并成一个有序表,最少的比较次数是()","choices":["\n2n\n","\n2n-1\n","\nn-1\n","\nn\n"],"correct_choice":"\nn\n"},{"title":"个数约为 50k 的数列需要从小到大排序， 数列特征是基本逆序 （多数数字从大到小，个别乱序） ，以下哪种排序算法在事先不了解数列特征的情况下性能大概率最优（不考虑空间限制）___.","choices":["\n冒泡排序\n","\n改进冒泡排序\n","\n选择排序\n","\n快速排序\n","\n堆排序\n","\n插入排序\n"],"correct_choice":"\n堆排序\n"},{"title":"现有1G数据需要排序，计算资源只有1G内存可用，下列排序方法中最可能出现性能问题的是____。","choices":["\n堆排序\n","\n插入排序\n","\n归并排序\n","\n快速排序\n","\n选择排序\n","\n冒泡排序\n"],"correct_choice":"\n归并排序\n"},{"title":"在一个元素个数为N的数组里，找到升序排在N/5位置的元素的最优算法时间复杂度是","choices":["\nO(n)\n","\nO(n log n)\n","\nO(n (log n)2)\n","\nO(n 3/2)\n"],"correct_choice":"\nO(n)\n"},{"title":"使下列算法的时间复杂度描述错误的有？","choices":["\n冒泡排序：O(n*n)\n","\n选择排序: O(n*n)\n","\n插入排序: O(n*n*n)\n","\n快速排序: O(nlogn)\n","\n堆排序: O(nlogn)\n","\n归并排序:O(n * n)\n"],"correct_choice":"\n插入排序: O(n*n*n)\n\n归并排序:O(n * n)\n"},{"title":"下面关于排序算法描述正确的是","choices":["\n冒泡排序算法平均时间复杂度是O（N的平方）\n","\n平均时间复杂度低的算法不一定是最优算法\n","\n原表（排序之前的表）是否有序对排序算法的影响不大\n","\n选择排序算法时，需要考虑表中元素的个数\n"],"correct_choice":"\n冒泡排序算法平均时间复杂度是O（N的平方）\n\n平均时间复杂度低的算法不一定是最优算法\n\n选择排序算法时，需要考虑表中元素的个数\n"},{"title":"\n  下列排序算法中，已基本有序却反而变得更复杂的排序算法是：（      ）。\n","choices":["\n冒泡排序\n","\n快速排序\n","\n堆排序\n","\n简单选择排序\n"],"correct_choice":"\n快速排序\n"},{"title":"  用某种排序方法对关键字序列（25,84,21,47,15,27,68,35,20）进行排序时，序列的变化情况如下： \n  20,15,21,25,47,27,68,35,84 \n  15,20,21,25,35,27,47,68,84 \n  15,20,21,25,27,35,47,68,84 \n  则所采用的排序方法是（        ） ","choices":["\n选择排序\n","\n希尔排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"要从1000个数据元素中选五个最小的，下面排序算法中，那个算法最快？（）","choices":["\n希尔排序\n","\n快速排序\n","\n堆排序\n","\n简单选择排序\n"],"correct_choice":"\n堆排序\n"},{"title":"下列排序方法中，最坏情况下比较次数最少的是（  ）。","choices":["\n冒泡排序\n","\n简单选择排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"影响外排序的时间因素主要是内存与外设交换信息的总次数()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"对任何用顶点表示活动的网络（AOV网）进行拓扑排序的结果都是唯一的。","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"\n  设一组\n  初始记录关键字序列为\n  (Q\n  ，\n  H\n  ，\n  C\n  ，\n  Y\n  ，\n  P\n  ，\n  A\n  ，\n  M\n  ，\n  S\n  ，\n  R\n  ，\n  D\n  ，\n  F\n  ，\n  X)\n  ，则按字母升序的第一趟冒泡排序结束后的结果是（\n  \n  ）。\n","choices":["\nF，H，C，D，P，A，M，Q，R，S，Y，X\n","\nP，A，C，S，Q，D，F，X，R，H，M，Y\n","\nA，D，C，R，F，Q，M，S，Y，P，H，X\n","\nH，C，Q，P，A，M，S，R，D，F，X，Y\n"],"correct_choice":"\nH，C，Q，P，A，M，S，R，D，F，X，Y\n"},{"title":"  拓扑排序运算只能用于（    ）  ","choices":["\n带权有向图\n","\n连通无向图\n","\n有向无环图\n","\n无向图\n"],"correct_choice":"\n有向无环图\n"},{"title":"\n  对数列\n  (25,84,21,47,15,27,68,35,20)\n  进行排序，元素序列的变化情况如下：\n\n\n   (1)25,84,21,47,15,27,68,35,20\n\n\n   (2)20,15,21,25,47,27,68,35,84\n\n\n   (3)15,20,21,25,35,27,47,68,84\n\n\n   (4)15,20,21,25,27,35,47,68,84\n","choices":["\n快速排序\n","\n简单选择排序\n","\n希尔排序\n","\n归并排序\n"],"correct_choice":"\n快速排序\n"},{"title":"堆排序是稳定的排序方法()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  以30为基准,设一组初始记录关键字序列为\n  (30,15,40,28,50,10,70),\n  则第一趟快速排序结果为（）\n","choices":["\n10，28，15，30，50，40，70\n","\n10，15，28，30,50，40，70\n","\n10，28，15，30，40，50，70\n","\n10，15，28，30，40，50，70\n"],"correct_choice":"\n10，15，28，30,50，40，70\n"},{"title":"在下列几种排序方法中，空间复杂度最高的是（）\n","choices":["\n归并排序\n","\n快速排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n归并排序\n"},{"title":"向一个有\n127\n个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素数是（）","choices":["\n8\n","\n63.5\n","\n64\n","\n7\n"],"correct_choice":"\n63.5\n"},{"title":"设有5000个待排序的记录的关键字，如果需要用最快的方法选出其中最小的10个记录关键字，则用下列哪个方法可以达到此目的()","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n插入排序\n"],"correct_choice":"\n堆排序\n"},{"title":"如果在一个排序算法的执行过程中，没有一对元素被比较过两次或以上，则称该排序算法为节俭排序算法，以下算法中是节俭排序算法的有________。","choices":["\n插入排序\n","\n选择排序\n","\n堆排序\n","\n归并排序\n"],"correct_choice":"\n插入排序\n\n归并排序\n"},{"title":"排序的稳定性是指排序算法中的比较次数保持不变,且算法能够终止()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"内部排序方法的稳定性是指该排序算法不允许有相同的关键字记录。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"对n个记录的文件进行堆排序,最坏情况下的执行时间是多少?()","choices":["\nO(log2n)\n","\nO(n)\n","\nO(nlog2n)\n","\nO(n*n)\n"],"correct_choice":"\nO(nlog2n)\n"},{"title":"在外部排序时,利用选择树方法在能容纳m个记录的内存缓冲区中产生的初始归并段的平均长度为2m个记录()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"排序算法中的比较次数与初始元素序列的排列无关。","choices":["\nT\n","\nF\n"],"correct_choice":"\nF\n"},{"title":"交换排序法是对序列中的元素进行一系列比较,当被比较的两个元素逆序时,进行交换,起泡排序和快速排序是基于这类方法的两种排序方法,起泡排序算法的最坏时间复杂性是O(n*n),而快速排序算法的最坏时间复杂性是O(nlog2\nn);所以快速排序比起泡排序效率更高()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"最坏情况下 insert sort, quick sort ,merge sort 的复杂度分别是多少？","choices":["\nO(n*n),O(nlogn),O(n*n)\n","\nO(n*n),O(n*n),O(nlogn)\n","\nO(n*n),O(nlogn),O(nlogn)\n","\nO(nlogn),O(nlogn),O(nlogn)\n"],"correct_choice":"\nO(n*n),O(n*n),O(nlogn)\n"},{"title":"\n  设有5000个待排序的记录关键字，如果需要用最快的方法选出其中最小的10个记录关键字，则用下列（）方法可以达到此目的。\n","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n插入排序\n"],"correct_choice":"\n堆排序\n"},{"title":"\n  设有5000个元素，希望用最快的速度挑选出前10个最大的，采用（    ）方法最好。\n","choices":["\n快速排序\n","\n堆排序\n","\n希尔排序\n","\n归并排序\n"],"correct_choice":"\n堆排序\n"},{"title":"外部排序是把外存文件调入内存,可利用内部排序的方法进行排序,因此排序所花的时间取决于内部排序的时间()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"堆排序平均执行的时间复杂度和需要附加的存储空间复杂度分别是（）","choices":["\nO(N2)和O(1)\n","\nO(Nlog2N)和O(1)\n","\nO(Nlog2N)和O(N)\n","\nO(N2)和O(N)\n"],"correct_choice":"\nO(Nlog2N)和O(1)\n"},{"title":"对{05,46,13,55,94,17,42}进行基数排序,一趟排序的结果是:()","choices":["\n05,46,13,55,94,17,42\n","\n05,13,17,42,46,55,94\n","\n42,13,94,05,55,46,17\n","\n05,13,46,55,17,42,94\n"],"correct_choice":"\n42,13,94,05,55,46,17\n"},{"title":"字符序列（‘D’,’Q’, ‘U’,  ‘I’, ‘A’, ’N'）只能是下列哪个排序算法两趟排序后的结果？","choices":["\n选择排序\n","\n冒泡排序\n","\n插入排序\n","\n堆排序\n"],"correct_choice":"\n插入排序\n"},{"title":"如果待排序序列中两个数据元素具有相同的值,在排序前后它们的相互位置发生颠倒,则称该排序算法是不稳定的()就是不稳定的排序方法","choices":["\n起泡排序\n","\n归并排序\n","\n希尔排序\n","\n直接插入排序\n","\n简单选择排序\n"],"correct_choice":"\n希尔排序\n\n简单选择排序\n"},{"title":"快速排序的平均时间复杂度和最坏时间复杂度是?","choices":["\nO(n^2), O(n^2)\n","\nO(n^2), O(nlgn)\n","\nO(nlgn) , O(nlgn)\n","\nO(nlgn) , O(n^2)\n"],"correct_choice":"\nO(nlgn) , O(n^2)\n"},{"title":"无环有向图才能进行拓扑排序。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"假设线性表的长度为n，则在最坏情况下，冒泡排序需要的比较次数为多少次？","choices":["\nnn的二次方\n","\nn的二次方/2\n","\nn(n-1)/2\n","\nn(n+1)/2\n"],"correct_choice":"\nn(n-1)/2\n"},{"title":"归并排序辅助存储为O(1)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对记录（54,38,96,23,15,72,60,45,83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（ ）次？（采用从后往前比较）","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n5\n"},{"title":"快速排序算法在序列已经有序的情况下的复杂度为（）","choices":["\nO(nlogn）\n","\nO(n^2)\n","\nO(n)\n","\nO(n^2  logn)\n"],"correct_choice":"\nO(n^2)\n"},{"title":"假设基准值为数组首元素的快速排序，要使得数组满足非降序排列，下列数据分布导致快排算法效率最低的是____。","choices":["\n2-6-3-7-5-1-4\n","\n6-2-3-5-4-1-7\n","\n7-5-3-2-4-1-6\n","\n1-5-7-2-4-6-3\n","\n1-2-3-4-5-6-7\n","\n4-1-3-7-5-6-2\n"],"correct_choice":"\n1-2-3-4-5-6-7\n"},{"title":"归并排序中,归并的趟数是()","choices":["\nO(n)\n","\nO(logn)\n","\nO(nlogn)\n","\nO(n*n)\n"],"correct_choice":"\nO(logn)\n"},{"title":"以下排序算法是非稳定排序的是（）","choices":["\n冒泡排序\n","\n归并排序\n","\n快速排序\n","\n堆排序\n","\n希尔排序\n"],"correct_choice":"\n快速排序\n\n堆排序\n\n希尔排序\n"},{"title":"Which of the following sorting algorithm(s) is(are) stable sorting?","choices":["\nbubble sort\n","\nquick sort\n","\nheap sort\n","\nmerge sort\n","\nSelection sort\n"],"correct_choice":"\nbubble sort\n\nmerge sort\n"},{"title":"\n  若二叉排序树（搜索树）中关键码互不相同，则其中最小元素和最大元素一定是叶子结点。\n  ( \n   )\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  下列排序方法中，比较次数与待排序记录的初始状态无关的是（）\n","choices":["\n插入排序和快速排序\n","\n归并排序和快速排序\n","\n选择排序和归并排序\n","\n插入排序和归并排序\n"],"correct_choice":"\n选择排序和归并排序\n"},{"title":"\n  已给下图，哪一项是该图的拓扑排序序列（ )\n  \n\n\n  \n    \n       \n    \n  \n","choices":["\n1，2，3，4，5\n","\n1，3，2，4，5\n","\n1，2，4，3，5\n","\n1，2，3，5，4\n"],"correct_choice":"\n1，2，3，4，5\n"},{"title":"设顺序表的长度为\nn\n。下列排序方法中，最坏情况下比较次数小于\nn(n-1)/2\n的是（\n）。","choices":["\n堆排序\n","\n快速排序\n","\n简单插入排序\n","\n冒泡排序\n"],"correct_choice":"\n堆排序\n"},{"title":"\n  下列排序算法中，（）在某趟排序结束后不一定能选出一个元素放到其最终位置上。\n","choices":["\n选择排序\n","\n冒泡排序\n","\n希尔排序\n","\n堆排序\n"],"correct_choice":"\n希尔排序\n"},{"title":"\n  若数据元素序列\n  11\n  ，\n  12\n  ，\n  13\n  ，\n  7\n  ，\n  8\n  ，\n  9\n  ，\n  23\n  ，\n  4\n  ，\n  5\n  是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是（）\n  。\n","choices":["\n冒泡排序\n","\n插入排序\n","\n选择排序\n","\n二路归并排序\n"],"correct_choice":"\n插入排序\n"},{"title":"\n  Shell排序是一种什么排序（）。 \n\n\n  \n    \n  \n\n\n  \n    \n  \n","choices":["\n插入\n","\n选择\n","\n交换\n","\n归并\n"],"correct_choice":"\n插入\n"},{"title":"具有 n 个结点的二叉排序树有多种，其中树高最小的二叉排序树是最佳的，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n正确\n"},{"title":"快速排序的速度在所有排序方法中为最快,而且所需附加空间也最少()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"最坏情况下时间复杂度不是n(n-1)/2的排序算法是？","choices":["\n快速排序\n","\n冒泡排序\n","\n直接插入排序\n","\n堆排序\n"],"correct_choice":"\n堆排序\n"},{"title":"设一组初始记录关键字序列为(65,56,72,99,86,25,34,66)，则以第一个关键字65为基准而得到的一趟快速排序结果是（）","choices":["\n34，56，25，65，86，99，72，66\n","\n25，34，56，65，99，86，72，66\n","\n34，56，25，65，66，99，86，72\n","\n34，56，25，65，99，86，72，66\n"],"correct_choice":"\n34，56，25，65，86，99，72，66\n"},{"title":"\n  设顺序表的长度为\n  n\n  。下列排序方法中，最坏情况下比较次数小于\n  n(n-1)/2\n  的是（\n  ）\n","choices":["\n堆排序\n","\n快速排序\n","\n简单插入排序\n","\n冒泡排序\n"],"correct_choice":"\n堆排序\n"},{"title":"在下列排序方法中,()方法可能出现这种情况:在最后一趟开始之前,所有的元素都不在其最终应在的正确位置上","choices":["\n快速排序\n","\n起泡排序\n","\n堆排序\n","\n插入排序\n"],"correct_choice":"\n插入排序\n"},{"title":"有一个小白程序员，写了一个只能对5个数字进行排序的函数。现在有25个不重复的数字，请问小白同学最少调几次该函数，可以找出其中最大的三个数？","choices":["\n5\n","\n6\n","\n7\n","\n8\n"],"correct_choice":"\n7\n"},{"title":"\n  有关插入排序的叙述，错误的是(    )\n","choices":["\n插入排序在最坏情况下需要O(n2)时间\n","\n插入排序在最佳情况可在O(n)时间内完成\n","\n插入排序平均需要O(nlog2n)时间\n","\n插入排序的空间复杂度为O(1)\n"],"correct_choice":"\n插入排序平均需要O(nlog2n)时间\n"},{"title":"优化过后的冒泡排序算法关键字比较的次数与记录的初始排列次序无关，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"\n  对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是\n  （）。\n  \n    \n  \n","choices":["\n排序的总趟数\n","\n元素的移动次数\n","\n使用辅助空间的数量\n","\n元素之间的比较次数\n"],"correct_choice":"\n元素之间的比较次数\n"},{"title":"在下列排序算法中,哪一个算法的时间复杂度与初始排序无关(     )。","choices":["\n直接插入排序\n","\n气泡排序\n","\n快速排序\n","\n直接选择排序\n"],"correct_choice":"\n直接选择排序\n"},{"title":"\n  设一组初始记录关键字序列为(60，80，55，40，42，85)，则以第一个关键字60为基准而得到的一趟快速排序结果是（）。\n","choices":["\n40，42，60，55，80，85\n","\n42，45，55，60，85，80\n","\n42，40，55，60，80，85\n","\n42，40，60，85，55，80\n"],"correct_choice":"\n42，40，55，60，80，85\n"},{"title":"拓扑排序运算只能用于（）","choices":["\n带权有向图\n","\n连通无向图\n","\n有向无环图\n","\n无向图\n"],"correct_choice":"\n有向无环图\n"},{"title":"若需在O(nlog2n)的时间内完成对数组的排序，且要求排序是稳定的，则可选择的排序方法是（）。","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n直接插入排序\n"],"correct_choice":"\n归并排序\n"},{"title":"优化的起泡排序的排序趟数与参加排序的序列原始状态有关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"\n  在二叉排序树（二叉搜索树）中，最小值结点的（    ）。\n","choices":["\n左孩子一定为空指针\n","\n右孩子一定为空指针\n","\n左、右指针均为空\n","\n左、右指针均不为空\n"],"correct_choice":"\n左孩子一定为空指针\n"},{"title":"\n  在待排序的元素序列基本有序的前提下，效率最高的排序方法是______\n  。\n","choices":["\n插入排序\n","\n选择排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n插入排序\n"},{"title":"在初始数据表已经有序时,快速排序算法的时间复杂度为O(nlog2\nn)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"快速排序在最坏情况下的时间复杂度为（）","choices":["\nO(log2n)\n","\nO(nlog2n)\n","\nO(n)\n","\nO(n*n)\n"],"correct_choice":"\nO(n*n)\n"},{"title":"在下列几种排序方法中，空间复杂度最高的是（）","choices":["\n归并排序\n","\n快速排序\n","\n插入排序\n","\n选择排序\n"],"correct_choice":"\n归并排序\n"},{"title":"\n  用希尔排序方法对一个数据序列进行排序时，若第1趟排序结果为9,1,4,13,7,8,20,23,15，则该趟排序采用的增量（间隔）可能是\n  （）\n","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"\n  用某种排序方法对关键字排序（25 、84、21、47、15、27、68、35、20）进行排序时，序列的变化情况如下：\n\n\n  20、15、21、25、47、27、68、35、84\n\n\n  15、20、21、25、35、27、47、68、84\n\n\n  15、20、21、25、27、35、47、68、84\n\n\n  则采用的排序方法是（）\n","choices":["\n选择排序\n","\n希尔排序\n","\n归并排序\n","\n快速排序\n"],"correct_choice":"\n快速排序\n"},{"title":"下列排序方法中，稳定的排序方法是（）","choices":["\n直接插入排序\n","\n归并排序\n","\n希尔排序\n","\n快速排序\n","\n基数排序\n"],"correct_choice":"\n直接插入排序\n\n归并排序\n\n基数排序\n"},{"title":"对记录（54,38,96,23,15,72,60,45,83）进行直接插入排序时，当把第八个记录45插入到有序表时，为找到插入位置需比较（）次","choices":["\n4\n","\n6\n","\n5\n","\n3\n"],"correct_choice":"\n5\n"},{"title":"  在寻找 n 个元素中第 k 小元素问题中，如使用快速排序算法思想，运用分治算法对 n 个元素进行划分，应如何选择划分基准？下面（ ） 答案解释最合理。  ","choices":["\n随机选择一个元素作为划分基准\n","\n取子序列的第一个元素作为划分基准\n","\n用中位数的中位数方法寻找划分基准\n","\n以上皆可行。但不同方法，算法复杂度上界可能不同\n"],"correct_choice":"\n以上皆可行。但不同方法，算法复杂度上界可能不同\n"},{"title":"\n  已给图，（）是该图的正确的拓扑排序序列\n\n\n  \n    \n    \n  \n","choices":["\n1，2，3，4，5\n","\n1，3，2，4，5\n","\n1，2，4，3，5\n","\n1，2，3，5，4\n"],"correct_choice":"\n1，2，3，4，5\n"},{"title":"在待排序的元素序列基本有序的前提下，效率最高的排序方法是？","choices":["\n插入排序\n","\n选择排序\n","\n快速排序\n","\n归并排序\n"],"correct_choice":"\n插入排序\n"},{"title":"The best time complexity of quick sort algorithm is:","choices":["\nO(lgn)\n","\nO(n)\n","\nO(nlgn)\n","\nO(n*n)\n"],"correct_choice":"\nO(nlgn)\n"},{"title":"拓扑排序算法把一个无向图中的顶点排成一个有序序列。（  ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"在下列排序算法中，在待排序的数据表已经为有序时，花费时间反而最多的是（）。","choices":["\n快速排序\n","\n希尔排序\n","\n冒泡排序\n","\n堆排序\n"],"correct_choice":"\n快速排序\n"},{"title":"当待排序的元素很大时，为了交换元素的位置，移动元素要占用较多的时间，这是影响时间复杂度的主要因素。\n（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  下列排序方法中，比较次数与待排序记录的初始状态无关的是\n\n\n  \n","choices":["\n插入排序和快速排序\n","\n归并排序和快速排序\n","\n选择排序和归并排序\n","\n插入排序和归并排序\n"],"correct_choice":"\n选择排序和归并排序\n"},{"title":"快速排序与堆排序的平均时间复杂度相同，这种说法（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"数据序列(8,9,10,4,5,6,20,1,2)只能是下列排序算法中的()的两趟排序后的结果","choices":["\n选择排序\n","\n起泡排序\n","\n插入排序\n","\n堆排序\n"],"correct_choice":"\n插入排序\n"},{"title":"已知数据表A中每个元素距其最终位置不远，为节省时间排序，应采用什么方法排序？","choices":["\n堆排序\n","\n插入排序\n","\n快速排序\n","\n直接选择排序\n"],"correct_choice":"\n插入排序\n"},{"title":"以下哪种排序算法的最坏时间复杂度可以做到 O(nlogn)：","choices":["\n归并排序\n","\n快速排序\n","\n冒泡排序\n","\n插入排序\n"],"correct_choice":"\n归并排序\n"},{"title":"设有5000个无序的元素，希望用最快的速度排出其中前50个最大的元素，最好选用哪种排序方法？","choices":["\n冒泡排序\n","\n快速排序\n","\n堆排序\n","\n基数排序\n"],"correct_choice":"\n堆排序\n"},{"title":"将两个各有N个元素的有序表归并成一个有序表,其最少的比较次数是()","choices":["\nN\n","\n2N-1\n","\n2N\n","\nN-1\n"],"correct_choice":"\nN\n"},{"title":"下列排序算法中,占用辅助空间最多的是()","choices":["\n归并排序\n","\n快速排序\n","\n希尔排序\n","\n堆排序\n"],"correct_choice":"\n归并排序\n"},{"title":"基于比较的排序算法是（）","choices":["\n基数排序\n","\n冒泡排序\n","\n桶排序\n","\n希尔排序\n"],"correct_choice":"\n冒泡排序\n\n希尔排序\n"},{"title":"\n  阅读以下\n  foo\n  函数，请问它的时间复杂度是：\n\n\n  int foo(intarray[], int n, int key) \n\n\n  { \n\n\n   int n1=0,n2=n-1,m; \n\n\n   while(n1<=n2) \n\n\n  { \n\n\n   m=(n1+n2)/2; \n\n\n   if(array[m]==key) \n\n\n   return m; \n\n\n   if(array[m]>key) \n\n\n   n2=m-1; \n\n\n   else \n\n\n   n1=m+1; \n\n\n  } \n\n\n  return -1; \n\n\n  } \n","choices":["\nO(n2)\n","\nO(n)\n","\nO(log(n))\n","\nO(n)\n"],"correct_choice":"\nO(log(n))\n"},{"title":"以下排序方式中占用O（n）辅助存储空间的是","choices":["\n简单排序\n","\n快速排序\n","\n堆排序\n","\n归并排序\n"],"correct_choice":"\n归并排序\n"},{"title":"以下哪种排序是稳定的？","choices":["\n希尔排序\n","\n堆排序\n","\n冒泡排序\n","\n快速排序\n"],"correct_choice":"\n冒泡排序\n"},{"title":"请问对一个排好序的数组进行查找，时间复杂度为（）","choices":["\nO(n)\n","\nO(lgn)\n","\nO(nlgn)\n","\nO(1)\n"],"correct_choice":"\nO(lgn)\n"},{"title":"  直接选择排序的时间复杂度为         。（ n  为元素个数）  ","choices":["\nO（n)\n","\nO(log2n)\n","\nO(nlog2n)\n","\nO(n2)\n"],"correct_choice":"\nO(n2)\n"},{"title":"\n  \n    \n      \n        \n            下列排序算法中，在待排序数据已有序时，花费时间反而最多的是()排序。\n          \n        \n    \n  \n","choices":["\n冒泡\n","\n希尔\n","\n快速\n","\n堆\n"],"correct_choice":"\n快速\n"},{"title":"对n个元素的数组进行（），其平均时间复杂度和最坏情况下的时间复杂度都是O（nlogn）.","choices":["\n希尔排序\n","\n快速排序\n","\n堆排序\n","\n选择排序\n"],"correct_choice":"\n堆排序\n"},{"title":"就平均性能而言,目前最好的内排序方法是()排序法","choices":["\n起泡\n","\n希尔插入\n","\n交换\n","\n快速\n"],"correct_choice":"\n快速\n"},{"title":"  下列哪些排序算法不是稳定的？ ","choices":["\n快速排序\n","\n冒泡排序\n","\n选择排序\n","\n归并排序\n"],"correct_choice":"\n快速排序\n\n选择排序\n"},{"title":"堆排序是不稳定的排序方法，这种说法（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"在文件\"局部有序\"或文件长度较小的情况下,最佳内部排序的方法是()","choices":["\n直接插入排序\n","\n冒泡排序\n","\n简单选择排序\n","\n快速排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"下列哪种排序算法不是稳定的？","choices":["\n基数排序\n","\n冒泡排序\n","\n选择排序\n","\n归并排序\n"],"correct_choice":"\n选择排序\n"},{"title":"归并排序的时间复杂度（）","choices":["\nO(log(N))\n","\nO(N*log(N))\n","\nO(N)\n","\nO(N^2)\n"],"correct_choice":"\nO(N*log(N))\n"},{"title":"\n  将7个不同的数据进行排序，至少需要比较（）\n  次\n","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n6\n"},{"title":"在下列排序方法中，不稳定的方法有","choices":["\n归并排序与基数排序\n","\n插进排序与希尔排序\n","\n堆排序与快速排序\n","\n选择排序与冒泡排序\n"],"correct_choice":"\n堆排序与快速排序\n"},{"title":"  直接插入排序的平均时间复杂度为（）。 ","choices":["\nO（logn）\n","\nO（n）\n","\nO（nlogn）\n","\nO（n²）\n"],"correct_choice":"\nO（n²）\n"},{"title":"关于排序算法的以下说法，正确的是？","choices":["\n快速排序的平均时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)\n","\n堆排序的平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)\n","\n冒泡排序的平均时间复杂度为O(n^2)，最坏时间复杂度为O(n^2)\n","\n归并排序的平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)\n"],"correct_choice":"\n冒泡排序的平均时间复杂度为O(n^2)，最坏时间复杂度为O(n^2)\n"},{"title":"\n   排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序方法中，每一趟排序结束时都至少能够确定一个元素最终位置的方法是（）。\n  \n    \n  \n\n\n  Ⅰ．简单选择排序 \n\n\n  Ⅱ．希尔排序 \n\n\n  Ⅲ．快速排序\n\n\n  Ⅳ．堆排序   \n\n   Ⅴ．二路归并排序\n","choices":["\n仅Ⅰ、 Ⅲ、 Ⅳ\n","\n仅Ⅰ、 Ⅲ、 Ⅴ\n","\n仅Ⅱ、 Ⅲ、 Ⅳ\n","\n仅Ⅲ、 Ⅳ、 Ⅴ\n"],"correct_choice":"\n仅Ⅰ、 Ⅲ、 Ⅳ\n"},{"title":"一个排序算法的时间复杂度与()有关","choices":["\n排序算法的稳定性\n","\n所需比较关键字的次数\n","\n所采用的存储结构\n","\n所需辅助存储空间的大小\n"],"correct_choice":"\n所需比较关键字的次数\n"},{"title":"  对数列(25,84,21,47,15,27,68,35,20)进行排序，元素序列的变化情况如下: \n  1.25,84,21,47,15,27,68,35,20 \n  2.20,15,21,25,47,27,68,35,84 \n  3.15,20,21,25,35,27,47,68,84 \n  4.15,20,21,25,27,35,47,68,84 ","choices":["\n简单选择排序\n","\n快速排序\n","\n归并排序\n","\n希尔排序\n"],"correct_choice":"\n快速排序\n"},{"title":"下面哪些是稳定排序","choices":["\n冒泡排序\n","\n快速排序\n","\n堆排序\n","\n归并排序\n","\n选择排序\n"],"correct_choice":"\n冒泡排序\n\n归并排序\n"},{"title":"在分配排序时,最高位优先分配法比最低位优先分配法简单()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"由于希尔排序的最后一趟与直接插入排序过程相同,因此前者一定比后者花费的时间更多()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  设有n个待排序的记录关键字，则在堆排序中需要（）个辅助记录单元。\n","choices":["\n1\n","\nn\n","\nnlog2n\n","\nn^2\n"],"correct_choice":"\n1\n"},{"title":"希尔 冒泡 快速 插入 哪个平均速度最快？","choices":["\n希尔\n","\n冒泡\n","\n快速\n","\n插入\n"],"correct_choice":"\n快速\n"},{"title":"  已知表 A 中每个元素距其最终位置不远，则以下哪种排序最省时间（ ）。  ","choices":["\n冒泡排序\n","\n直接插入排序\n","\n快速排序\n","\n堆排序\n"],"correct_choice":"\n直接插入排序\n"},{"title":"\n  设一组初始记录关键字的长度为8，则最多经过（）趟插入排序可以得到有序序列。\n","choices":["\n6\n","\n7\n","\n8\n","\n9\n"],"correct_choice":"\n7\n"},{"title":"外部排序常用的算法是？","choices":["\n归并排序\n","\n快速排序\n","\n堆排序\n","\n希尔排序\n"],"correct_choice":"\n归并排序\n"},{"title":"拓扑排序是按 AOE 网中每个结点事件的最早发生时间对结点进行排序，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"内排序要求数据一定要以顺序方式存储()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"}]