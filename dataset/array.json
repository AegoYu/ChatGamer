[{"title":"  如有定义：char str[20];，能将从键盘输入的字符串“How are you”保存到 str 数组的语句是（   ）\n","choices":["\nscanf(\"%s\", str);\n","\nstr[] = getch();\n","\ngets(str);\n","\nstr = gets();\n"],"correct_choice":"\ngets(str);\n"},{"title":"数组就是矩阵，矩阵就是数组，这种说法（   ）。","choices":["\n正确\n","\n错误\n","\n前句对，后句错\n","\n后句对\n"],"correct_choice":"\n错误\n"},{"title":"  有一个 100 × 90 的稀疏矩阵，非 0 元素有 10 ，设每个整型数占 2 个字节，则用三元组表示该矩阵时，所需的字节数是         。  ","choices":["\n20\n","\n66\n","\n18 000\n","\n33\n"],"correct_choice":"\n66\n"},{"title":"  在 C 语言中，一维数组的定义方式为： \n  元素类型 数组名[E]; \n  E 为（   ）。\n","choices":["\n常量表达式\n","\n整型表达式\n","\n整型常量或整型表达式\n","\n整型常量表达式\n"],"correct_choice":"\n整型常量表达式\n"},{"title":"在 n 个结点的线性表的数组实现中，算法的时间复杂度是 O （ 1 ）的操作是           。","choices":["\n访问第i（1<=i<=n）个结点和求第i个结点的直接前驱（1<i<=n）\n","\n在第i（1<=i<=n）个结点后插入一个新结点\n","\n删除第i（1<=i<=n）个结点\n","\n以上都不对\n"],"correct_choice":"\n访问第i（1<=i<=n）个结点和求第i个结点的直接前驱（1<i<=n）\n"},{"title":"\n  向一个长度为n的向量的第i个元素(1≤i≤n+1)之前插入一个元素时，需向后移动（）\n  \n  个元素。\n\n\n  \n","choices":["\nn-i\n","\nn-i+1\n","\nn-i-1\n","\ni\n"],"correct_choice":"\nn-i+1\n"},{"title":"设二维数组A[0..m-1][0..n-1]按行优先顺序存储，则元素A[i][j]的地址为（）","choices":["\nLOC(A[0][0])+(i*m+j)\n","\nLOC(A[0][0])+(i*n+j)\n","\nLOC(A[0][0])+[(i-1)*n+j-1]\n","\nLOC(A[0][0])+[(i-1)*m+j-1]\n"],"correct_choice":"\nLOC(A[0][0])+(i*n+j)\n"},{"title":"\n  \n  线性表的顺序存储结构是一种（）\n  的存储结构，线性表的链式存储结构是一种顺序存取\n  的存储结构。\n","choices":["\n随机存取\n","\n顺序存取\n","\n索引存取\n","\n散列存取\n"],"correct_choice":"\n随机存取\n"},{"title":"  以下不合法的数组定义是（    ）\n","choices":["\nchar a[] = \"good\"\n","\nint s[5] = {1, 2, 3, 4};\n","\nchar s = \"good\";\n","\nchar s[] = {0, 1, 2, 3, 4};\n"],"correct_choice":"\nchar s = \"good\";\n"},{"title":"  若二维数组 a 有 m 列，则计算任一元素 a[i][j] 在数组中的位置公式为（    ）。  （假设 a[0][0] 位于数组的第一个位置上）\n","choices":["\ni*m+j\n","\nj*m+i\n","\ni*m+j-1\n","\ni*m+j+1\n"],"correct_choice":"\ni*m+j+1\n"},{"title":"  以下是一个二维数组求和函数： \n  int sum-array-rows ( int V [M] [N] ) \n  { \n      int i, j, sum=0; \n      for ( i=0; i< M; i++) \n          for (j=0; j < N; j++) \n              sum + =V[i] [j]; \n      return sum; \n  } \n  假设M=2、N=3，则数组V的访问顺序是(   )时, 其访问局部性达到最好。（说明：二维数组存放时，一般同一行元素连续存放。）\n","choices":["\nV00、V01、V02、V10、V11、V12\n","\nV00、V10、V01、V11、V02、V12\n","\nV00、V11、V01、V10、V02、V12\n","\nV00、V01、V11、V10、V02、V12\n"],"correct_choice":"\nV00、V01、V02、V10、V11、V12\n"},{"title":"线性表中每个元素都有一个直接前驱和一个直接后继()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"对矩阵进行压缩存储是为了             。","choices":["\n方便运算\n","\n方便存储\n","\n提高运算速度\n","\n减少存储空间\n"],"correct_choice":"\n减少存储空间\n"},{"title":"  给出以下定义：     Char x[]=”abcdefg”;     Char y[]={‘a’,’b’,’c’,’d’,’e’,’f’,’g’}; ","choices":["\n数组X和数组Y等价\n","\n数组X和数组Y的长度相同\n","\n数组X的sizeof运算值大于数组Y的sizeof运算值\n","\n数组X的sizeof运算值小于数组Y的sizeof运算值\n"],"correct_choice":"\n数组X的sizeof运算值大于数组Y的sizeof运算值\n"},{"title":"在C语言中，设有数组定义：char arrays[]=\"China\"；则数组array所占用的空间为（）。","choices":["\n4个字节\n","\n5个字节\n","\n6个字节\n","\n7个字节\n"],"correct_choice":"\n6个字节\n"},{"title":"假定一个二维数组的定义语句为“int a[3][4]={{3,4},{2,8,6}};”，则元素a[1][2]的值为","choices":["\n6\n","\n4\n","\n2\n","\n8\n"],"correct_choice":"\n6\n"},{"title":"有两个从小到大排好序的数组，长度分别为N和M，将这两个数组合并成一个有序数组的最小比较次数是？","choices":["\nMin(N, M)\n","\nM + N -1\n","\nN + M\n","\nMax(N, M)\n"],"correct_choice":"\nMin(N, M)\n"},{"title":"C#程序段的结果： int[][] array = new int[3][]{       new int[3]{5,6,2}, new\nint[5]{6,9,7,8,3},       new int[2]{3,2}  }; array[2][2] 返回（）","choices":["\n9\n","\n6\n","\n2\n","\n溢出\n"],"correct_choice":"\n溢出\n"},{"title":"  For the following Java or C# code(3 Points)，What will my\n  Array3[2][2] returns? \nint [][] myArray3 =  \nnew int[3][]{  \nnew int[3]{5,6,2},  \nnew int[5]{6,9,7,8,3},  \nnew int[2]{3,2}\n};  \n\n","choices":["\n9\n","\n2\n","\n6\n","\noverflow\n"],"correct_choice":"\noverflow\n"},{"title":"对于一个线性表既要求能够进行较快速地的插入和删除,又要求存储结构能反映数据之间的逻辑关系,则应该用()","choices":["\n顺序存储方式\n","\n链式存储方式\n","\n散列存储方式\n","\n以上均可以\n"],"correct_choice":"\n链式存储方式\n"},{"title":"用向量和单链表示的有序表均可使用折半查找方法来提高查找速度()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"请问对一个排好序的数组进行查找，时间复杂度为（）","choices":["\nO(n)\n","\nO(lgn)\n","\nO(nlgn)\n","\nO(1)\n"],"correct_choice":"\nO(lgn)\n"},{"title":"若对n阶对称矩阵A(下标从1,1开始）以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1…(n(n+1))/2]中,则在B中确定aij\n   (i<j)的位置k的关系为()","choices":["\ni*(i-1)/2+j\n","\nj*(j-1)/2+i\n","\ni*(i+1)/2+j\n","\nj*(j+1)/2+i\n"],"correct_choice":"\nj*(j-1)/2+i\n"},{"title":"下列数组定义及赋值，错误的是","choices":["\nint intArray[ ];\n","\nint intArray=new int[3]; intArray[1]=1; intArray[2]=2;\n","\nint a[ ]={1, 2, 3, 4, 5};\n","\nint a[ ] [ ]=new int[2] [ ]; a[0]=new int[3]; a[1]=new int[3];\n"],"correct_choice":"\nint intArray=new int[3]; intArray[1]=1; intArray[2]=2;\n"},{"title":"关于 int a[10]; 问下面哪些不可以表示 a[1] 的地址？","choices":["\na+sizeof(int)\n","\n&a[0]+1\n","\n(int*)&a+1\n","\n(int*)((char*)&a+sizeof(int))\n"],"correct_choice":"\na+sizeof(int)\n"},{"title":"广义表(((a,b,c),d,e,f))的长度是4()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"在一个元素个数为N的数组里，找到升序排在N/5位置的元素的最优算法时间复杂度是","choices":["\nO(n)\n","\nO(n log n)\n","\nO(n (log n)2)\n","\nO(n 3/2)\n"],"correct_choice":"\nO(n)\n"},{"title":"数组必须是同类型值的集合()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"已知数组D的定义是int D[4][8];,现在需要把这个数组作为实参传递给一个函数进行处理。下列说明汇总可以作为对应的形参变量说明的是（）。","choices":["\nint D[4][]\n","\nint *s[8]\n","\nint(*s)[8]\n","\nint D[][8]\n"],"correct_choice":"\nint(*s)[8]\n\nint D[][8]\n"},{"title":"  在Java中,下列说法错误的有（ ） ","choices":["\n数组是一种对象\n","\n数组属于一种原生类\n","\nint number = []{31,23,33,43,35,63};\n","\n数组的大小可以任意改变\n"],"correct_choice":"\n数组属于一种原生类\n\nint number = []{31,23,33,43,35,63};\n\n数组的大小可以任意改变\n"},{"title":"\n  设二维数组A[m][n]，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc(a[0][0]),求按行优先顺序存放的数组元素a[i][j](0\n  ≤i≤m-1,0≤j≤n-1\n  )的存储地址为\n  \n\n\n  \n","choices":["\nLoc(a[0][0])+((i-1)*n-1)*k\n","\nLoc(a[0][0])+(i*n+j)*k\n","\nLoc(a[0][0])+(j*m+i)*k\n","\nLoc(a[0][0])+((j-1)*m+i-1)*k\n"],"correct_choice":"\nLoc(a[0][0])+(i*n+j)*k\n"},{"title":"若有定义：byte[]x={11,22,33,﹣66}；其中0≤k≤3，则对x数组元素错误的引用是（）","choices":["\nx[5-3]\n","\nx[k]\n","\nx[k+5]\n","\nx[0]\n"],"correct_choice":"\nx[k+5]\n"},{"title":"设A是n*n的对称矩阵，将A的对角线及对角线上方的元素以列为主的次序存放在一维数组B[1..n（n+1）/2]中，对上述任一元素aij\n  (1≤i，j≤n，且i≤j)在B中的位置为（）","choices":["\ni（i-1）/2+j\n","\nj（j-1）/2+i\n","\nj（j-1）/2+i-1\n","\ni（i-1）/2+j-1\n"],"correct_choice":"\nj（j-1）/2+i\n"},{"title":"设有数组A[i，j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以行为内存放时，元素A[5，8]的存储首地址为（）","choices":["\nBA+141\n","\nBA+180\n","\nBA+222\n","\nBA+225\n"],"correct_choice":"\nBA+141\n"},{"title":"\n  在表长为n的顺序表上做插入运算，平均要移动的结点数为（ \n  ）\n  。\n","choices":["\nn/4\n","\nn/3\n","\nn/2\n","\nn\n"],"correct_choice":"\nn/2\n"},{"title":"在以下的叙述中，正确的是         。","choices":["\n线性表的顺序存储结构优于链表存储结构\n","\n二维数组是其数据元素为线性表的线性表\n","\n栈的操作方式是先进先出\n","\n队列的操作方式是先进后出\n"],"correct_choice":"\n二维数组是其数据元素为线性表的线性表\n"},{"title":"顺序存储方式插入和删除时效率太低，因此它不如链式存储方式好。  ","choices":["\nT\n","\nF\n"],"correct_choice":"\nF\n"},{"title":"  若有说明：int a[10];，则对数组元素的正确引用是（  ）。\n","choices":["\na[10]\n","\na[3,5]\n","\na(5)\n","\na[10-10]\n"],"correct_choice":"\na[10-10]\n"},{"title":"  以下数组定义中错误的是（   ）\n","choices":["\nint x[][3] = {0};\n","\nint x[2][3] = {{1,2},{3,4},{5,6}};\n","\nint x[][3] = {{1,2,3},{4,5,6}};\n","\nint x[2][3] = {1,2,3,4,5,6};\n"],"correct_choice":"\nint x[2][3] = {{1,2},{3,4},{5,6}};\n"},{"title":"  设有1000个无序的元素，希望用最快的速度挑选出其中前10个最大的元素，最好选用______________排序法。 \n","choices":["\n冒泡排序\n","\n快速排序\n","\n堆排序\n","\n选择排序\n"],"correct_choice":"\n堆排序\n"},{"title":"若有说明：int a[3][4]={0};，则下面叙述正确的是（）","choices":["\n只有数组元素 a[0][0] 可以得到初值 0\n","\n此说明语句不正确\n","\n数组 a 中各元素都可以得到初值，但其值不一定为 0\n","\n数组 a 中每个元素均被初始化为 0\n"],"correct_choice":"\n数组 a 中每个元素均被初始化为 0\n"},{"title":"对矩阵压缩存储是为了()","choices":["\n方便运算\n","\n方便存储\n","\n提高运算速度\n","\n减少存储空间\n"],"correct_choice":"\n减少存储空间\n"},{"title":"线性表就是顺序存储的表()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。","choices":["\nn-i，n-i+1\n","\nn-i+1，n-i\n","\nn-i，n-i\n","\nn-i+1，n-i+1\n"],"correct_choice":"\nn-i，n-i+1\n"},{"title":"线性表采用链表存储时,结点和结点内部的存储空间可以是不连续的()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"给出以下定义: \n char acX[]=\"abcdefg\"; \n char acY[]={'a', 'b', 'c',  'd', 'e', 'f', 'g'}; \n 则正确的叙述为","choices":["\n数组acX和数组acY等价\n","\n数组acX和数组acY的长度相同\n","\n数组acX的长度大于数组acY的长度\n","\n数组acX的长度小于数组acY的长度\n"],"correct_choice":"\n数组acX的长度大于数组acY的长度\n"},{"title":"有一个用数组C[1..m]表示的环形队列，m为数组的长度。假设f为队头元素在数组中的位置，r为队尾元素的后一位置（按顺时针方向）。若队列非空，则计算队列中元素个数的公式应为？","choices":["\n（m+r-f）mod m\n","\nr-f\n","\n(m-r+f) mod m\n","\n(m-r-f) mod m\n","\n(r-f) mod m\n","\n需要判断边界\n"],"correct_choice":"\n（m+r-f）mod m\n"},{"title":"线性表是具有n个()的有限序列(n>0)","choices":["\n表元素\n","\n字符\n","\n数据元素\n","\n数据项\n","\n信息项\n"],"correct_choice":"\n数据元素\n"},{"title":"数组A[0..4,-1..-3,5..7]中含有元素的个数()","choices":["\n55\n","\n45\n","\n36\n","\n16\n"],"correct_choice":"\n45\n"},{"title":"希望用最快的速度从一个无序数组中挑选出其中前十个最大的元素，在以下的排序方法中（）\n","choices":["\n快速排序\n","\n堆排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n堆排序\n"},{"title":"\n给定一个m行n列的整数矩阵（如图），每行从左到右和每列从上到下都是有序的。判断一个整数k是否在矩阵中出现的最优算法，在最坏情况下的时间复杂度是________。 \n  \n","choices":["\nO(m*n)\n","\nO(m+n)\n","\nO(log(m*n))\n","\nO(log(m+n))\n"],"correct_choice":"\nO(m+n)\n"},{"title":"下列数据结构具有记忆功能的是？","choices":["\n队列\n","\n循环队列\n","\n栈\n","\n顺序表\n"],"correct_choice":"\n栈\n"},{"title":"数组指针和指针数组有什么区别 ？","choices":["\n数组指针只是一个指针变量，它占有内存中一个指针的存储空间\n","\n指针数组只是一个指针变量，它占有内存中一个指针的存储空间\n","\n指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间\n","\n数组指针是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间\n"],"correct_choice":"\n数组指针只是一个指针变量，它占有内存中一个指针的存储空间\n\n指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间\n"},{"title":"线性结构的是（）","choices":["\n串\n","\n链式存储栈\n","\n顺序存储栈\n","\n顺序存储二叉树\n"],"correct_choice":"\n串\n\n链式存储栈\n\n顺序存储栈\n"},{"title":"以下操作中，数组比链表速度更快的是____","choices":["\n原地逆序\n","\n头部插入\n","\n返回中间节点\n","\n返回头部节点\n","\n选择随机节点\n"],"correct_choice":"\n原地逆序\n\n返回中间节点\n\n选择随机节点\n"},{"title":"下列关于数组与指针的区别描述正确的是？","choices":["\n数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。\n","\n用运算符sizeof 可以计算出数组的容量（字节数）\n","\n指针可以随时指向任意类型的内存块。\n","\n用运算符sizeof 可以计算出指针所指向内容的容量（字节数）\n"],"correct_choice":"\n用运算符sizeof 可以计算出数组的容量（字节数）\n"},{"title":"下列说法错误的有（）","choices":["\n数组是一种对象\n","\n数组属于一种原生类\n","\nint number=[]={31,23,33,43,35,63}\n","\n数组的大小可以任意改变\n"],"correct_choice":"\n数组属于一种原生类\n\nint number=[]={31,23,33,43,35,63}\n\n数组的大小可以任意改变\n"},{"title":"便于插入和删除的容器是（）","choices":["\nlist\n","\nvector\n","\nmap\n","\nset\n"],"correct_choice":"\nlist\n\nmap\n\nset\n"},{"title":"稀疏矩阵一般的压缩存储方式有两种，即         。","choices":["\n二维数组和三维数组\n","\n三元组和散列\n","\n三元组和十字链表\n","\n散列和十字链表\n"],"correct_choice":"\n三元组和十字链表\n"},{"title":"\n  设一维数组中有n个数组元素，则读取第i个数组元素的平均时间复杂度为（）。\n","choices":["\nO(n)\n","\nO(nlog2n)\n","\nO(1)\n","\nO(n2)\n"],"correct_choice":"\nO(1)\n"},{"title":"二维数组和多维数组均不是特殊的线性结构。（\n）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"设二维数组A[0…m-1][0…n-1]按行优先顺序存储在内存中，第一个元素的地址为p，每个元素占k个字节，则元素aij的地址为（   ）","choices":["\np+[(i*n+j)]*k\n","\np+[(i-1)*n+j-1]*k\n","\np+[(j-1)*n+i-1]*k\n","\np+[j*n+i-1]*k\n"],"correct_choice":"\np+[(i*n+j)]*k\n"},{"title":"\n  线性表L=(a\n  \n    1\n  \n  ,a\n  \n    2\n  \n  ,\n  …\n  ,a\n  \n    n\n  \n  )，下列陈述正确的是______。\n","choices":["\n每个元素都有一个直接前驱和一个直接后继\n","\n线性表中至少有一个元素\n","\n表中诸元素的排列必须是由小到大或由大到小\n","\n除第一个和最后一个元素外，其余每个元素都有且仅有一个直接前驱和直接后继\n"],"correct_choice":"\n除第一个和最后一个元素外，其余每个元素都有且仅有一个直接前驱和直接后继\n"},{"title":"以下叙述中正确的是（）","choices":["\n线性表的线性存储结构优于链表存储结构\n","\n二维数组是它的每个数据元素为一个线性表的线性表\n","\n栈的操作方式是先进先出\n","\n队列的操作方式先进后出\n"],"correct_choice":"\n二维数组是它的每个数据元素为一个线性表的线性表\n"},{"title":"  数组Ｑ［0..m-1］用来表示一个循环队列， 用front指向队头元素，rear指向队尾元素的后一个位置 ，则当前队列中的元素数是。（队列总的元素数不会超过队列大小）     ","choices":["\n(rear-front+m)% m\n","\nrear-front+1\n","\nrear-front-1\n","\nrear-front\n"],"correct_choice":"\n(rear-front+m)% m\n"},{"title":"  32系统，函数 \nvoid Func(char str[100]){}\n  中sizeof(str)= ","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n4\n"},{"title":"java中，以下能对二维数组 a 进行正确初始化的语句是（）","choices":["\nint a[2][]={{1,0,1},{5,2,3}};\n","\nint a[][]={{1,2,3},{4,5,6}};\n","\nint a[2][4]={1,2,3},{4,5},{6}};\n","\nint a[][3]={{1,0,1},{},{1,1}};\n"],"correct_choice":"\nint a[][]={{1,2,3},{4,5,6}};\n"},{"title":"\n  在表结构中最常用的是线性表，栈和队列不太常用。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"下列叙述中正确的是（  ）。","choices":["\n顺序存储结构的存储一定是连续的，链式存储结构的存储空间不一定是连续的\n","\n顺序存储结构只针对线性结构，链式存储结构只针对非线性结构\n","\n顺序存储结构能存储有序表，链式存储结构不能存储有序表\n","\n链式存储结构比顺序存储结构节省存储空间\n"],"correct_choice":"\n顺序存储结构的存储一定是连续的，链式存储结构的存储空间不一定是连续的\n"},{"title":"\n  设\n  int x[]={1,2,3,4,5,6},*p=x;\n  则值为\n  3\n  的表达式是\n","choices":["\np+=2,*++p;\n","\np+=2,*p++\n","\np+=3,*p\n","\np+=2,++*p\n"],"correct_choice":"\np+=2,*p++\n"},{"title":"设有一个二维数组A[m][n]，假设A[0][0]存放位置在644(10)，A[2][2]存放位置在676(10)，每个元素占一个空间，问A[3][3](10)存放在什么位置？\n 脚注(10)表示用10进制表示","choices":["\n688\n","\n678\n","\n692\n","\n696\n"],"correct_choice":"\n692\n"},{"title":"数组通常具有的两种基本操作是()","choices":["\n查找和修改\n","\n查找和索引\n","\n索引和修改\n","\n建立和删除\n"],"correct_choice":"\n查找和修改\n"},{"title":"\n  在面向对象的程序设计中，关于数组，下列说法正确的有\n","choices":["\n数组属于一种原生类\n","\n数组是一种对象\n","\nint number=[]={31,23,33,43,35,63}\n","\n数组的大小可以任意改变\n"],"correct_choice":"\n数组是一种对象\n"},{"title":"给定如下代码： int x[4]={0}; int y[4]={1}; 数组x和y的值为（）","choices":["\n{0，0，0，0}，{1，1，1，1}\n","\n{0，0，0，0}，{1，0，0，0}\n","\n{0，不确定}，{1，不确定}\n","\n与编译器相关\n"],"correct_choice":"\n{0，0，0，0}，{1，0，0，0}\n"},{"title":"下列叙述中正确的是（\n）。","choices":["\n有一个以上根结点的数据结构不一定是非线性结构\n","\n只有一个根结点的数据结构不一定是线性结构\n","\n循环链表是非线性结构\n","\n双向链表是非线性结构\n"],"correct_choice":"\n只有一个根结点的数据结构不一定是线性结构\n"},{"title":"int (*p)[3] p的含义是什么?","choices":["\n一个指向int元素大小为3的指针数组\n","\n一个指向元素个数为3的int数组的指针\n","\n不合法\n","\n以上说法都不正确\n"],"correct_choice":"\n一个指向元素个数为3的int数组的指针\n"},{"title":"(1)静态链表既有顺序存储的优点,又有动态链表的优点。所以,它存取表中第i个元素的时间与i无关。\n  (2)静态链表中能容纳的元素个数的最大数在表定义时就确定了,以后不能增加.\n  (3)静态链表与动态链表在元素的插入、删除上类似,不需做元素的移动。\n  以上错误的是()","choices":["\n(1),(2)\n","\n(1)\n","\n(1),(2),(3)\n","\n(2)\n"],"correct_choice":"\n(1)\n"},{"title":"假设以行优先顺序存储三维数组A[5][6][7],其中元素A[0][0][0]的地址为1100，且每个元素占2个存储单元，则A[4][3][2]的地址是()","choices":["\n1150\n","\n1291\n","\n1380\n","\n1482\n"],"correct_choice":"\n1482\n"},{"title":"在C++语言中，下面关于数组的描述错误的是（）","choices":["\n数组的名字就是指向该数组第一个元素的指针\n","\n长度为n的数组，下标的范围是0-n-1\n","\n数组的大小必须在编译时确定\n","\n数组可通过值参数、地址指针、引用参数三种方式传递给函数\n"],"correct_choice":"\n数组的大小必须在编译时确定\n"},{"title":"  对于一个具有n个顶点的无向图，若采用邻接表表示，则存放表头节点的数组大小为（）\n","choices":["\nn\n","\nn+1\n","\nn-1\n","\nn+1边数\n"],"correct_choice":"\nn\n"},{"title":"Asume you have an object to describe customer  data:{     ID（5 digit numeric）     Family Name（string）     Account Balance（currency）  }  If you have 500,000 Chinese customers records represented by instances of this object type ,  what set of data structures is best to get fast retrieval of customers (1) get IDs from Name and (2) get Name from ID?","choices":["\n(1) Tree with Hash(100 bucket) at leaves(2) Tree with linked list at leaves.\n","\n(1) Tree with linked list at leaves(2) Array.\n","\n(1) Tree with linked list at leaves(2) Hash(10,000 buckets)\n","\n(1) Sort linked list(2) Array.\n"],"correct_choice":"\n(1) Tree with linked list at leaves(2) Array.\n"},{"title":"稀疏矩阵压缩的存储方法是：（）","choices":["\n三元组\n","\n二维数组\n","\n散列\n","\n十字链表\n"],"correct_choice":"\n三元组\n\n十字链表\n"},{"title":"\n  若要删除\n  book\n  表中的所有数据，如下哪些语法是错误的？\n","choices":["\ndrop table book;\n","\ntruncate table book;\n","\ndelete from book;\n","\ndelelet *from book;\n"],"correct_choice":"\ndrop table book;\n\ndelelet *from book;\n"},{"title":"\n  对于不同的使用者，一个表结构既可以是栈，也可以是队列，也可以是线性表。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"取线性表的第i个元素的时间同i的大小有关。","choices":["\nT\n","\nF\n"],"correct_choice":"\nF\n"},{"title":"\n  c中，二维数组初始化的方法是:int a[3][3]={{1},{2},{3}};说法是否正确？ \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  设有一个二维数组A[m][n]，假设A[0][0]存放位置在 644，A[2][2]存放位置在676，每个元素占一个空间，问A[3][3]存放的位置在（ ）。  ","choices":["\n688\n","\n678\n","\n692\n","\n696\n"],"correct_choice":"\n692\n"},{"title":"设有一个长度为n的顺序表，要在第i个元素之前（也就是插入元素作为新表的第i个元素），则移动元素个数为（   ）。","choices":["\nn-i+1\n","\nn-i\n","\nn-i-1\n","\ni\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n  设有\n  一个二维数组\n  \n    A\n  \n  [m][n]\n  ，假设\n  \n    A\n  \n  [0][0]\n  存放位置在\n  644(10)\n  \n  ，\n  \n    A\n  \n  [2][2]\n  存放位置在\n  676(10)\n  \n  ，每个元素占一个空间，问\n  \n    A\n  \n  [3][3](10)\n  \n  存放在什么位置？脚注\n  \n    (10)\n  \n  表示用\n  10\n  进制表示。\n","choices":["\n688\n","\n678\n","\n692\n","\n696\n"],"correct_choice":"\n692\n"},{"title":"当在一个有序的顺序存储表上查找一个数据时,即可用折半查找,也可用顺序查找,但前者比后者的查找速度()","choices":["\n必定快\n","\n必定不快\n","\n在大部分情况下要快\n","\n取决于表递增还是递减\n"],"correct_choice":"\n在大部分情况下要快\n"},{"title":"\n  在C语言中，若有定义：int a[4][10](其中0<=i<4,0<=j<10);则下列选项中对数组元素a[i][j]引用错误的是（）\n","choices":["\n*(a+i)+j\n","\n*(&a[0][0]+10*i+j)\n","\n*(a[i]+j)\n","\n*(*(a+i)+j)\n"],"correct_choice":"\n*(a+i)+j\n"},{"title":"  设以下c语句中，对数组array定义后，数组元素array[1][2]的值为：（）  int array[2][3]={1,2,3,4,5}; ","choices":["\n2\n","\n3\n","\n5\n","\n0\n"],"correct_choice":"\n0\n"},{"title":"\n 下列给定程序中，函数fun的功能是:求ss所指字符串数组中长度最短的字符串所在的行下标，作为函数值返回，并把其串长放在形参n所指的变量中。ss所指字符串数数组中共有M个字符串，且串长小于N。 \n  请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。 \n  试题程序。 \n#define M 5\n #define N 20\n int fun(char(* ss)[N], int *n)\n {\n     int i, k = 0, len = N;\n     for (i = 0; i < ______; i++)\n     {\n         len = strlen(ss[i]);\n         if (i == 0)\n             *n = len;\n         if (len ____ * n)\n         {\n             *n = len;\n             k = i;\n         }\n     }\n     return ( _____ );\n }\n main( )\n {\n     char ss[M][N] = {\"shanghai\", \"guangzhou\", \"beijing\", \"tianjing\", \"chongqing\"};\n     int n, k, i;\n     printf(\"\\nThe originalb stringsare:\\n\");\n     for (i = 0; i < M; i++)\n         puts(ss[i]);\n     k = fun(ss, &n);\n     printf(\"\\nThe length of shortest string is: % d\\n\", n);\n     printf(\"\\nThe shortest string is: % s\\n\", ss[k]);\n }\n","choices":["\nN，< ，k\n","\nN， >，k\n","\nM，<，k\n","\nM，>，k\n"],"correct_choice":"\nM，<，k\n"},{"title":"假设以行序为主序存储二维数组A=array[100][100]，设每个数据元素占2个存储单元，基地址A[0][0]为10，则A[5，5]的地址为（）。","choices":["\n1,020\n","\n818\n","\n808\n","\n1,010\n"],"correct_choice":"\n1,020\n"},{"title":"\n  数组定义为“ int a [ 4 ] ;\n      ”，表达式 ( ) 是错误的。\n\n\n  \n","choices":["\n*a\n","\na [ 0 ]\n","\na\n","\na++\n"],"correct_choice":"\na++\n"},{"title":"\n  一个n*n的对称矩阵，如果以行主序存储，每一个元素占一个单元，\n  则其需要的最少需要的存储空间为（）\n","choices":["\nn×n.\n","\nn×n/2\n","\n(n+1)×n/2\n","\n(n+1)×(n+1)/2\n"],"correct_choice":"\n(n+1)×n/2\n"},{"title":"广义表中的元素或者是一个不可分割的原子,或者是一个非空的广义表()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  已知一稀疏矩阵的三组元表为：（1，2，3），（1，6，1），（3，1，5）（3，2，-1），（5，4，5）（5，1，-3），则其转置矩阵的三元组表中第3个三元组为（）\n","choices":["\n(2, 1, 3)\n","\n(3, 1, 5)\n","\n(3, 2, -1)\n","\n(2, 3, -1)\n"],"correct_choice":"\n(2, 1, 3)\n"},{"title":"有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是()","choices":["\n60\n","\n66\n","\n18000\n","\n33\n"],"correct_choice":"\n66\n"},{"title":"用数组r存储静态链表,结点的next域指向后继,工作指针j指向链中结点,使j沿链移动的操作为()","choices":["\nj=r[j].next\n","\nj=j+1\n","\nj=j->next\n","\nj=r[j]->next\n"],"correct_choice":"\nj=r[j].next\n"},{"title":"在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行（）次比较：","choices":["\n8\n","\n9\n","\n10\n","\n11\n"],"correct_choice":"\n9\n"},{"title":"\n  下面哪几个语句正确的声明一个整型的二维数组（）\n","choices":["\nint a[][]=new int[][]\n","\nint b[10][10]=new int[][]\n","\nint c[][]=new int[10][10]\n","\nint []d[]=new int[10][10]\n"],"correct_choice":"\nint c[][]=new int[10][10]\n\nint []d[]=new int[10][10]\n"},{"title":"下列关于线性表中的链表描述正确的是？","choices":["\n适用于数据项数量不能预知的情况。\n","\n逻辑相邻的2元素的存储空间可以是不连续的。\n","\n链表节点一般有数据元素和指针域两部分组成。\n","\n存储空间需要动态分配。\n"],"correct_choice":"\n适用于数据项数量不能预知的情况。\n\n逻辑相邻的2元素的存储空间可以是不连续的。\n\n链表节点一般有数据元素和指针域两部分组成。\n\n存储空间需要动态分配。\n"},{"title":"下列叙述哪些是对的?","choices":["\n线性表的逻辑顺序与物理顺序总是一致的。\n","\n线性表的顺序存储表示优于链式存储表示。\n","\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n","\n二维数组是每个元素都为顺序表的顺序表 .\n","\n每种数据结构都应具备三种基本运算：插入、删除和搜索。\n"],"correct_choice":"\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n\n二维数组是每个元素都为顺序表的顺序表 .\n"},{"title":"\n  设有\n  一个二维数组\n  \n    A\n  \n  [\n  \n    m\n  \n  ][\n  \n    n\n  \n  ]\n  ，假设\n  \n    A\n  \n  [0][0]\n  存放位置在\n  644\n  \n    (10)\n  \n  ，\n  \n    A\n  \n  [2][2]\n  存放位置在\n  676\n  \n    (10)\n  \n  ，每个元素占一个空间，问\n  \n    A\n  \n  [3][3]\n  \n    (10)\n  \n  存放在什么位置？脚注\n  \n    (10)\n  \n  表示用\n  10\n  进制表示。\n\n","choices":["\n688\n","\n678\n","\n692\n","\n696\n"],"correct_choice":"\n692\n"},{"title":"\n  有一随机数组(25,84,21,46,13,27,68,35,20),采用某种方法对它们进行排序,其每趟排序\n\n\n  结果如下,\n  \n\n\n    则该排序方法是（）。 \n  \n    初\n    始:25,84,21,46,13,27,68,35,20 \n    \n  \n  \n    第一趟:20,13,21,25,46,27,68,35,84\n    \n  \n  \n    第二趟:13,20,21,25,35,27,46,68,84 \n    \n  \n  \n    第三趟:13,20,21,25,27,35,46,68,84 \n    \n  \n  \n    \n  \n","choices":["\n基数排序\n","\n插入排序\n","\n快速排序\n","\n起泡排序\n"],"correct_choice":"\n快速排序\n"},{"title":"\n\n  设一组初始关键字记录关键字为(20，15，14，18，21，36，40，10)，则以20为基准记录的一趟快速排序结束后的结果为(  )。\n","choices":["\n10，15，14，18，20，36，40，21\n","\n10，15，14，18，20，40，36，21\n","\n10，15，14，20，18，40，36，2l\n","\n15，10，14，18，20，36，40，21\n"],"correct_choice":"\n10，15，14，18，20，36，40，21\n"},{"title":"设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a11为第一元素，其存储地址为1，每个元素占一个地址空间，则a85的地址为(  \n  )。","choices":["\n13\n","\n33\n","\n18\n","\n40\n"],"correct_choice":"\n33\n"},{"title":"数组 A[0  …  4 ， -1  …  -3 ， 5   … 7] 中含有的元素个数是         。","choices":["\n55\n","\n45\n","\n36\n","\n16\n"],"correct_choice":"\n45\n"},{"title":"\n  已知\n  10*12\n  的二维数组\n  A\n  ，以行序为主序进行存储，每个元素占\n  1\n  个存储单元，已知\n  A[1][1]\n  的存储地址为\n  420\n  ，则\n  A[5][5]\n  的存储地址为\n  （\n  ）\n","choices":["\n470\n","\n471\n","\n472\n","\n473\n"],"correct_choice":"\n472\n"},{"title":"  若要定义一个具有 5 元素的整型数组，以下错误的定义语句是（   ）。\n","choices":["\nint a[5] = {0};\n","\nint a[] = {0, 0, 0, 0, 0};\n","\nint a[2+3];\n","\nint i = 5, a[i];\n"],"correct_choice":"\nint i = 5, a[i];\n"},{"title":"\n  若有\n  18\n  个元素的有序表存放在一维数组\n  A[19]\n  中，第一个元素放\n  A[1]\n  中，现进行二分查找，则查找\n  A\n  ［\n  3\n  ］的比较序列的下标依次为\n  (      )\n","choices":["\n1，2，3\n","\n9，5，2，3\n","\n9，5，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"如何跳出Array的forEach循环？（）\n","choices":["\nbreak\n","\nreturn true\n","\nreturn false\n","\n以上都不是\n"],"correct_choice":"\nbreak\n"},{"title":"int A[2][3]={1,2,3,4,5,6};,则A[1][0]和*(*(A+1)+1)的值分别是（）","choices":["\n4 5\n","\n4 3\n","\n3 5\n","\n3 4\n"],"correct_choice":"\n4 5\n"},{"title":"假设要存储一个数据集，数据维持有序，对其的操作只有插入、删除和顺序遍历，综合存储效率和运行速度，下列哪种数据结构是最适合的是？","choices":["\n数组\n","\n链表\n","\n哈希表\n","\n队列\n"],"correct_choice":"\n链表\n"},{"title":"声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）","choices":["\n（int *p[10]）（int*）\n","\nint [10]*p（int *）\n","\nint (*(*p)[10])(int *)\n","\nint ((int *)[10])*p\n","\n以上选项都不正确\n"],"correct_choice":"\nint (*(*p)[10])(int *)\n"},{"title":"  若有以下定义和语句： \nint a[10]={1,2,3,4,5,6,7,8,9,10},*p=a;\n  则不能表示a数组元素的表达式是 ","choices":["\n*p\n","\na[10]\n","\n*a\n","\na[p-a]\n"],"correct_choice":"\na[10]\n"},{"title":"最坏情况下，合并两个大小为n的已排序数组所需要的比较次数_____。","choices":["\n2n\n","\n2n-1\n","\n2n+1\n","\n2n-2\n"],"correct_choice":"\n2n-1\n"},{"title":"稀疏矩阵一般的压缩存储方法有两种,即()","choices":["\n二维数组和三维数组\n","\n三元组和散列\n","\n三元组和十字链表\n","\n散列和十字链表\n"],"correct_choice":"\n三元组和十字链表\n"},{"title":"对n个记录的线性表进行快速排序为减少算法的递归深度,以下叙述正确的是()","choices":["\n每次分区后,先处理较短的部分\n","\n每次分区后,先处理较长的部分\n","\n与算法每次分区后的处理顺序无关\n","\n以上三者都不对\n"],"correct_choice":"\n每次分区后,先处理较短的部分\n"},{"title":"图的广度优先搜索算法需使用的辅助数据结构为（）","choices":["\n三元组\n","\n队列\n","\n二叉树\n","\n栈\n"],"correct_choice":"\n队列\n"},{"title":"  以下能对一维数组 a 进行正确初始化的语句是（   ） ","choices":["\nint a[10]=(0, 0, 0, 0, 0);\n","\nint a[10]={  };\n","\nint a[]={0};\n","\nint a[10]={10*a};\n"],"correct_choice":"\nint a[10]={  };\n\nint a[]={0};\n"},{"title":"  若有说明：int a[3][4];，则对 a 数组元素的非法引用是（   ）\n  \n","choices":["\na[0][2*1]\n","\na[1][3]\n","\na[4-2][0]\n","\na[0][2+2]\n"],"correct_choice":"\na[0][2+2]\n"},{"title":"关于顺序表叙述，正确的是（）","choices":["\n不可随机访问任意节点\n","\n插入需要移动元素\n","\n删除不需要移动元素\n","\n存储空间可以离散分布\n"],"correct_choice":"\n存储空间可以离散分布\n"},{"title":"\n  对一维整型数组a的正确说明是\n  #define SIZE 10  (换行)  int a[SIZE];说法是否正确？\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"假定在数组A中，每个元素的长度为3个字节，行下标i从1到8，列下标j从1到10，从首地址SA开始连续存放在存储器内，存放该数组至少需要的单元数为（   ）。    ","choices":["\n80\n","\n100\n","\n240\n","\n270\n"],"correct_choice":"\n240\n"},{"title":"线性表L＝（a1,a2,a3,……ai,……an），下列说法正确的是？","choices":["\n每个元素都有一个直接前件和直接后件\n","\n线性表中至少要有一个元素\n","\n表中诸元素的排列顺序必须是由小到大或由大到小\n","\n除第一个和最后一个元素外，其余每个元素都有一个且只有一个直接前件和直接后件\n"],"correct_choice":"\n除第一个和最后一个元素外，其余每个元素都有一个且只有一个直接前件和直接后件\n"},{"title":"矩阵不仅是表示多维数组，而且是表示图的重要工具，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n正确\n"},{"title":"\n  数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素的公式为（）。 ","choices":["\nr－f\n","\n（n＋f－r）% n\n","\nn＋r－f\n","\n（n＋r－f）% n\n"],"correct_choice":"\n（n＋r－f）% n\n"},{"title":"下列哪些不是线性表？","choices":["\n队列\n","\n栈\n","\n关联数组\n","\n链表\n"],"correct_choice":"\n关联数组\n"},{"title":"有一个二维数组A[10][5]，每个数据元素占1个字节，且A[0][0]的存储地址是1000，则A[i][j]的地址是多少 ？","choices":["\n1000+10i+j\n","\n1000+i+j\n","\n1000+5i+j\n","\n1000+10i+5j\n"],"correct_choice":"\n1000+5i+j\n"},{"title":"若一个广义表的表头为空表,则此广义表亦为空表()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"数组定义为”int\n    a[4][5];”, 引用”*(a+1)+2″表示（）","choices":["\na[1][0]+2\n","\na数组第1行第2列元素的地址\n","\na[0][1]+2\n","\na数组第1行第2列元素的值\n"],"correct_choice":"\na数组第1行第2列元素的地址\n"},{"title":"\n  下面（）数据结构常用于函数调用。\n","choices":["\n队列\n","\n栈\n","\n链表\n","\n数组\n"],"correct_choice":"\n栈\n"},{"title":"有两个N*N的矩阵A和B，想要在PC上按矩阵乘法基本算法编程实现计算A*B。假设N较大，本机内存也很大，可以存下A、B和结果矩阵。那么，为了计算速度，A和B在内存中应该如何存储（按行存指先存储第一行，再第二行，直到最后一行；按列存指先存储第一列，再第二列，直到最后一列）？","choices":["\nA按行存，B按行存。\n","\nA按行存，B按列存。\n","\nA按列存，B按行存。\n","\nA按列存，B按列存。\n"],"correct_choice":"\nA按行存，B按列存。\n"},{"title":"\n 下列给定程序中，函数fun的功能是：把形参a所指数组中的奇数按原顺序依次存放到a[0]、a[1]、a[2]…中，把偶数从数组中删除，奇数个数通过函数值返回。\n例如，若a所指数组中的数据最初排列为：9,1,4,2,3,6,5,8,7，删除偶数后，a所指数组中的数据为：9,1,3,5,7，返回值为5。 \n  请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。\n  试题程序： #include<stdio.h>\n#define N9\nint fun (int a[], int n)\n{ \n    int i, j;\n    j=0;\n    for (i=0; i<n; i++)\n    /**********found**********/\n    if (a[i]%2== _________ )\n    {\n        /**********found**********/\n        a[j]=a[i];   \n        _________;\n    }\n    /**********found**********/\n    return _________;\n}\nmain( )\n{ \n    int b[N]={9,1,4,2,3,6,5,8,7}, i, n;\n    printf(\"\\nThe original data:\\n\");\n    for(i=0; i<N; i++)\n        printf(\"% 4d\", b[i]);\n    printf(\"\\n\");\n    n=fun(b, N);\n    printf(\"\\nThe number of odd:% d\\n\", n);\n    printf(\"\\nThe odd number: \\n\");\n    for(i=0; i<n; i++)\n        printf(\"%4d\",b[i]);\n    printf(\"\\n\");\n}\n\n","choices":["\n0  j++  j\n","\n1 j++ j+1\n","\n0 j++ j+1\n","\n1 j++ j\n"],"correct_choice":"\n1 j++ j\n"},{"title":"下面描述中正确的为?","choices":["\n线性表的逻辑顺序与物理顺序总是一致的。\n","\n线性表的顺序存储表示优于链式存储表示。\n","\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n","\n二维数组是其数组元素为线性表的线性表。\n"],"correct_choice":"\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n\n二维数组是其数组元素为线性表的线性表。\n"},{"title":"下列哪两个数据结构，同时具有较高的查找和删除性能？（）","choices":["\n有序数组\n","\n有序链表\n","\nAVL树\n","\nHash表\n"],"correct_choice":"\nAVL树\n\nHash表\n"},{"title":"  选项代码中能正确操作数组元素的是() \nint main(){\n  int a[N][N]={{0,0},{0,0}};\n  for(int i=0;i<N;i++){\n     for(int j=0;j<N;j++){\n       //访问二维数组a的值\n       //选项代码\n      }\n    }\n}","choices":["\n*(*(a+i)+j)=1\n","\n*(a[i]+j)=1\n","\n**(a+i)[j]=1\n","\n*((a+i)+j)=1\n"],"correct_choice":"\n*(*(a+i)+j)=1\n\n*(a[i]+j)=1\n"},{"title":"  下列程序的功能是求两个 2 行 3 列的数组的和，即数组对应位置的元素—相加，请为横线处选择合适的程序（）                        ","choices":["\nvoid M::\n","\nfriend M\n","\nM\n","\nM M::\n"],"correct_choice":"\nM M::\n"},{"title":"  数组元素的地址计算与数组的存储方式无关。请问这句话的说法是正确的吗？     ","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"数组A[1..5,1..6]的每个元素占5个单元，将其按行优先顺序存储在起始地址为1000的连续的内存单元中，则元素A[5,5]的地址为（）。 ","choices":["\n1140\n","\n1145\n","\n1120\n","\n1125\n"],"correct_choice":"\n1140\n"},{"title":"下面哪项不是链表优于数组的特点?","choices":["\n方便删除\n","\n方便插入\n","\n长度可变\n","\n存储空间小\n"],"correct_choice":"\n存储空间小\n"},{"title":"线性表是________。","choices":["\n一个有限序列，可以为空\n","\n一个有限序列，不可以为空\n","\n一个无限序列，可以为空\n","\n一个无限序列，不可以为空\n"],"correct_choice":"\n一个有限序列，可以为空\n"},{"title":"若已定义： int a[]=[0,1,2,3,4,5,6,7,8,9],*p=a,i; 其中0≤i≤9，则对a数组错误的引用是（）","choices":["\na[p-a]\n","\n*(&a[i])\n","\np[i]\n","\na[10]\n"],"correct_choice":"\na[10]\n"},{"title":"一个栈的输入序列为123、、、、、n，若输出序列的第一个元素是n，输出第i（1<=i<=n）个元素是（）","choices":["\n不确定\n","\nn-i+1\n","\ni\n","\nn-i\n"],"correct_choice":"\nn-i+1\n"},{"title":"int a[][3]={{1},{3,2},{6,7,8},{9}};中a[2][1]的值是（）","choices":["\n3\n","\n6\n","\n2\n","\n7\n"],"correct_choice":"\n7\n"},{"title":"数组不适合作为任何二叉树的存储结构()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"一个稀疏矩阵Am*n\n 采用三元组形式表示,若把三元组中有关行下标与列下标的值互换,并把m和n的值互换,则就完成了Am*n\n 的转置运算()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"若某线性表最常用得操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用哪种存储方式最节省时间？","choices":["\n顺序表\n","\n双链表\n","\n带头结点的双循环链表\n","\n单循环链表\n"],"correct_choice":"\n顺序表\n"},{"title":"\n下列给定程序中，函数fun的功能是：把形参a所指数组中的最小值放在元素a[0]中，接着把a所指数组中的最大值放在a[1]元素中;再把a所指数组元素中的次小值放在a[2]中，把a索取数组元素中的次大值放在a[3]，以此类推。 \n 例如:若a所指数组中的数据最初排列为：9,1,4,2,3,6,5,8,7;按规则移动后，数据排列为:1,9,2,8,3,7,4,6,5。形参n中存放a所指数组中数据的个数。\n 规定fun函数中的max存放的当前所找的最大值,px存放当前所找最大值得下标。\n请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。 \n  试题程序。 \n#include<stdio.h>\n#define N 9\nvoid fun(int a[ ], int n)\n{\n    int i, j, max, min, px, pn, t;\n    for (i = 0; i < n - 1; i += 2)\n    {\n\n        max = min = __;\n        px = pn = i;\n        for (j = i + 1; j < n; j++)\n        {\n\n            if (max <  __)\n            {\n                max = a[j];\n                px = j;\n            }\n\n            if (min > __ )\n            {\n                min = a[j];\n                pn = j;\n            }\n        }\n        if (pn != i)\n        {\n            t = a[i];\n            a[i] = min;\n            a[pn] = t;\n            if (px == i)\n                px = pn;\n        }\n        if (px != i + 1)\n        {\n            t = a[i + 1];\n            a[i + 1] = max;\n            a[px] = t;\n        }\n    }\n}\nint main( )\n{\n    int b[N] = {9, 1, 4, 2, 3, 6, 5, 8, 7};\n    printf(\"\\nThe original data:\\n\");\n    for (int i = 0; i < N; i++)\n        printf(\"% 4d\", b[i]);\n    printf(\"\\n\");\n    fun(b, N);\n    printf(\"\\nThe data after mocinng \\n\");\n    for (int i = 0; i < N; i++)\n        printf(\"% 4d\", b[i]);\n    printf(\"\\n\");\n}\n\n","choices":["\n0 a[i] a[i]\n","\na[i] a[j] a[j]\n","\n0 a[j] a[j]\n","\na[i] a[i] a[i]\n"],"correct_choice":"\na[i] a[j] a[j]\n"},{"title":"设有一个n行n列的对称矩阵A,将其下三角部分按行存放在一个一维数组B中,A[0][0]存放于B[0]中,那么第i行的对角元素A[i][i]存放于B中()处","choices":["\n(i+3)*i/2\n","\n(i+1)*i/2\n","\n(2n-i+1)*i/2\n","\n(2n-i-1)*i/2\n"],"correct_choice":"\n(i+3)*i/2\n"},{"title":"\n  若有18个元素的有序表存放在一维数组A[19]中，第一个元素放A[1]中，现进行二分查找，则查找A[3]的比较序列的下标依次为（）\n","choices":["\n1，2，3\n","\n9，5，3\n","\n9，5，2，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"设有一个n阶的下三角矩阵A，如果按照行的顺序将下三角矩阵中的元素（包括对角线 上元素）存放在n(n+1)个连续的存储单元中，则A[i][j]与 A[0][0]之间有[$##$]个数据元素（即不算A[i][j]和A[0][0]）。","choices":["\nj<=i ? i*(i+1)/2 +j-1: i*(i+1)/2+i\n","\nj>=i ? i*(i+1)/2 +j-1: i*(i+1)/2+i\n","\nj>=i ? i*(i+1)/2 +j: i*(i+1)/2+1\n","\nj<=i ? i*(i+1)/2 +j+1: i*(i+1)/2+1\n"],"correct_choice":"\nj<=i ? i*(i+1)/2 +j-1: i*(i+1)/2+i\n"},{"title":"  以下能对二维数组 a 进行正确初始化的语句是（   ）。\n","choices":["\nint a[2][]={{1,0,1},{5,2,3}};\n","\nint a[][3]={{1,2,3},{4,5,6}};\n","\nint a[2][4]={1,2,3},{4,5},{6}};\n","\nint a[][3]={{1,0,1},{},{1,1}};\n"],"correct_choice":"\nint a[][3]={{1,2,3},{4,5,6}};\n\nint a[][3]={{1,0,1},{},{1,1}};\n"},{"title":"  在以下的叙述中，正确的是（）。 ","choices":["\n线性表的顺序存储结构优于链表存储结构\n","\n线性表的顺序存储结构适用于频繁插入/删除数据元素的情况\n","\n线性表的链表存储结构适用于频繁插入/删除数据元素的情况\n","\n线性表的链表存储结构优于顺序存储结构\n"],"correct_choice":"\n线性表的链表存储结构适用于频繁插入/删除数据元素的情况\n"},{"title":"\n  从一个长度为n的顺序表中删除第i个元素(1≤i≤n)时,需向前移动（）_个元素。\n\n\n  \n","choices":["\nn-i\n","\nn-i+1\n","\nn-i-1\n","\ni\n"],"correct_choice":"\nn-i\n"},{"title":"  对一组数据（2，12，16，88，5，10）进行排序，若前三趟排序结果如下（ ） \n  第一趟：2，12，16，5，10，88 \n  第二趟：2，12，5，10，16，88 \n  第三趟：2，5，10，12，16，88 \n  则采用的排序方法可能是（        ） ","choices":["\n起泡排序\n","\n希尔排序\n","\n归并排序\n","\n基数排序\n"],"correct_choice":"\n起泡排序\n"},{"title":"在前提:var arr=[1,3,2]下，下面哪个操作会返回一个数组，并且不是arr？","choices":["\narr.push(3)\n","\narr.reverse()\n","\n[].concat.call(arr,[])\n","\n[].sort.call(arr)\n"],"correct_choice":"\n[].concat.call(arr,[])\n"},{"title":"已知二维数组A10×10中，元素a20的地址为560，每个元素占4个字节，则元素a10的地址为（   ）。","choices":["\n520\n","\n522\n","\n524\n","\n518\n"],"correct_choice":"\n520\n"},{"title":"集合与线性表的区别在于是否按关键字排序()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"在n个结点的线性表的数组实现中,算法的时间复杂性是O(1)的操作是()","choices":["\n访问第i个结点(1<=i<=n)和求第i个结点的直接前驱(2<=i<=n)\n","\n在第i个结点后插入一个新结点(1<=i<=n)\n","\n删除第i个结点(1<=i<=n)\n","\n以上都不对\n"],"correct_choice":"\n访问第i个结点(1<=i<=n)和求第i个结点的直接前驱(2<=i<=n)\n"},{"title":"A[N,N]是对称矩阵,将下面三角(包括对角线)以行序存储到一维数组T[N(N+1)/2]中,则对任一上三角元素a[i][j]对应T[k]的下标k是()","choices":["\ni(i+1)/2+j\n","\nj(j+1)/2+i\n","\ni(j+i)/2+1\n","\nj(i+1)/2+1\n"],"correct_choice":"\nj(j+1)/2+i\n"},{"title":"二维以上的数组其实是一种特殊的广义表()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"循环队列SQ的存储空间是数组d[m]，队头、队尾指针分别是front和rear，则执行出队后其头指针front值是（）","choices":["\nfront=front+1\n","\nfront=(front+1)%(m-1)\n","\nfront=(front-1)%m\n","\nfront=(front+1)%m\n"],"correct_choice":"\nfront=(front+1)%m\n"},{"title":"在一个长度为n的顺序表中删除第i个元素(1<=i<=n)时，需向前移动 （） 个元素","choices":["\nn-i\n","\nn-i+l\n","\nn-i-1\n","\ni\n"],"correct_choice":"\nn-i\n"},{"title":"若下三角矩阵An×n，按列顺序压缩存储在数组Sa[0…(n+1)n/2]中，则非零元素aij的地址为（   ）。（设每个元素占d个字节）    ","choices":["\n[(j-1)*n+i-1]*d\n","\n[(j-1)*n+i]*d\n","\n[(j-1)*n+i+1]*d\n","\n[(j-1)*n+i-2]*d\n"],"correct_choice":"\n[(j-1)*n+i]*d\n"},{"title":"若数组A[0…m][0…n]按列优先顺序存储，则aij地址为（   ）。    ","choices":["\nLOC(a00)+[j*m+i]\n","\nLOC(a00)+[j*n+i]\n","\nLOC(a00)+[(j-1)*n+i-1]\n","\nLOC(a00)+[(j-1)*m+i-1]\n"],"correct_choice":"\nLOC(a00)+[j*m+i]\n"},{"title":"  若声明一个浮点数数组如下： float average[]=new float[30];     假设该数组的内存起始位置为200， average[15]的内存地址是  ","choices":["\n214\n","\n215\n","\n260\n","\n256\n"],"correct_choice":"\n260\n"},{"title":"已知\n声明并初始化二维数组\nint a[ ][ ]={{1,2},{3,4},{5,6}}\n，则\na[1][1]\n的值为（）","choices":["\n1\n","\n2\n","\n4\n","\n5\n"],"correct_choice":"\n4\n"},{"title":"数组Q[n]用来表示一个循环队列,f为当前队列头元素的前一位置,r为队尾元素的位置,假定队列中元素的个数小于n,计算队列中元素的公式为（）\n","choices":["\nr-f\n","\n(n+f-r)%n\n","\nn+r-f\n","\n(n+r-f)%n\n"],"correct_choice":"\n(n+r-f)%n\n"},{"title":"对有序数组{2、11、15、19、30、32、61、72、88、90、96}进行二分查找，则成功找到15需比较（）次","choices":["\n3\n","\n4\n","\n2\n","\n5\n"],"correct_choice":"\n2\n"},{"title":"设二维数组A[1..m][1..n](即m行n列)按行存储在数组B[1..m*n]中,则二维数组元素A[i][j]在一维数组B中的下标为()","choices":["\n(i-1)*n+j\n","\n(i-1)*n+j-1\n","\ni*(j-1)\n","\nj*m+i-1\n"],"correct_choice":"\n(i-1)*n+j\n"},{"title":"数组可看成线性结构的一种推广,因此与线性表一样,可以对它进行插入,删除等操作()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"一个有序数列，序列中的每一个值都能够被2或者3或者5所整除，这个序列的初始值从1开始，但是1并不在这个数列中。求第1500个值是多少？","choices":["\n2040\n","\n2042\n","\n2045\n","\n2050\n"],"correct_choice":"\n2045\n"},{"title":"下列代码的输出为：\n#include \"iostream\"  \n#include \"vector\"  \nusing namespace std;  \n  \nint main(void)  \n{  \n    vector<int>array;  \n    array.push_back(100);  \n    array.push_back(300);  \n    array.push_back(300);  \n    array.push_back(500);  \n    vector<int>::iterator itor;  \n    for(itor=array.begin();itor!=array.end();itor++)  \n    {  \n        if(*itor==300)  \n        {  \n            itor = array.erase(itor);  \n        }  \n    }  \n    for(itor=array.begin();itor!=array.end();itor++)  \n    {  \n        cout<<*itor<<\" \";  \n    }  \n    return 0;  \n}  \n\n","choices":["\n100   300   300   500\n","\n100    300     500\n","\n100    500\n","\n程序错误\n"],"correct_choice":"\n100    300     500\n"},{"title":"【0、2、1、4、3、9、5、8、6、7】是以数组形式存储的最小堆，删除堆顶元素0后的结果是（）","choices":["\n【2、1、4、3、9、5、8、6、7】\n","\n【1、2、5、4、3、9、8、6、7】\n","\n【2、3、1、4、7、9、5、8、6】\n","\n【1、2、5、4、3、9、7、8、6】\n"],"correct_choice":"\n【1、2、5、4、3、9、7、8、6】\n"},{"title":"  下面描述中正确的为：","choices":["\n线性表的逻辑顺序与物理顺序总是一致的。\n","\n线性表的顺序存储表示优于链式存储表示。\n","\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n","\n二维数组是其数组元素为线性表的线性表。\n"],"correct_choice":"\n线性表若采用链式存储表示时所有结点之间的存储单元地址可连续可不连续。\n\n二维数组是其数组元素为线性表的线性表。\n"},{"title":"\n以下能正确定义一维数组的选项是\n( )","choices":["\nint a[5］={0,1,2,3,4,5}\n","\nchar a={′A′,′B′,′C′}\n","\nint a[5]=\"0123\"\n","\nchar a[]={′0′,′1′,′2′,′3′,′4′,′5′,′＼0′}\n"],"correct_choice":"\nchar a[]={′0′,′1′,′2′,′3′,′4′,′5′,′＼0′}\n"},{"title":"长度为n 的非空顺序表，若在第i个位置插入新的元素X，则i的取值范围是 1≤i≤n+1，需要移动的元素个数为（     ）。","choices":["\ni\n","\nn-i-1\n","\nn-i\n","\nn-i+1\n"],"correct_choice":"\nn-i+1\n"},{"title":"设循环队列中数组的下标范围是1~n，其头尾指针分别为f和r，则其元素个数为（）。","choices":["\nr-f\n","\nr-f+1\n","\n(r-f) mod n +1\n","\n(r-f+n) mod n\n"],"correct_choice":"\n(r-f+n) mod n\n"},{"title":"\n  以下\n  C\n  语言指令：\n\n\n   int a[5] = {1,3,5,7,9};\n\n\n   int *p = (int *)(&a+1);\n\n\n   printf(“%d,%d”,*(a+1)\n  ，\n  *(p-1));\n\n\n  运行结果是什么？\n","choices":["\n2,1\n","\n3,1\n","\n3,9\n","\n运行时崩溃\n"],"correct_choice":"\n3,9\n"},{"title":"多维数组可以看作数据元素也是基本线性表的基本线性表，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n正确\n"},{"title":"  如有定义：char str[20];，能将从键盘输入的字符串“How are you”保存到 str 数组的语句是（   ）\n","choices":["\nscanf(\"%s\", str);\n","\nstr[] = getch();\n","\ngets(str);\n","\nstr = gets();\n"],"correct_choice":"\ngets(str);\n"},{"title":"顺序存储方式只能用于存储线性结构()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"将一个A[1..100,1..100]的三对角矩阵,按行优先存入一维数组B[1..298]中,A中元素A6665\n (即该元素下标i=66,j=65),在B数组中的位置K为()供选择的答案:","choices":["\n198\n","\n195\n","\n197\n"],"correct_choice":"\n195\n"},{"title":"用一维数组存储二叉树时,总是以前序遍历顺序存储结点()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"若6行5列的数组以列序为主序顺序存储,基地址为1000,每个元素占2个存储单元,则第3行第4列的元素(假定无第0行第0列)的地址是()","choices":["\n1040\n","\n1042\n","\n1026\n","\n备选答案A,B,C都不对\n"],"correct_choice":"\n1040\n"},{"title":"\n  将整数数组（\n  7-6-3-5-4-1-2\n  ）按照堆排序的方式进行升序排列，请问在第一轮排序结束之后，数组的顺序是（）\n","choices":["\n1-2-3-4-5-6-7\n","\n2-6-3-5-4-1-7\n","\n6-5-3-2-4-1-7\n","\n5-4-3-2-1-6-7\n"],"correct_choice":"\n6-5-3-2-4-1-7\n"},{"title":"线性表的顺序存储结构是一种()","choices":["\n随机存取的存储结构\n","\n顺序存取的存储结构\n","\n索引存取的存储结构\n","\nHash存取的存储结构\n"],"correct_choice":"\n随机存取的存储结构\n"},{"title":"广义表的取表尾运算,其结果通常是个表,但有时也可是个单元素值()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下列说法正确的是（）","choices":["\n二维以上的数组其实是一种特殊的广义表\n","\n数组一旦建立，结构的元素个数和元素间的物理存储关系就不再变化\n","\n数组是一种线性结构，因此只能用来存储线性表\n","\n数组采用顺序存储方式表示\n"],"correct_choice":"\n二维以上的数组其实是一种特殊的广义表\n\n数组一旦建立，结构的元素个数和元素间的物理存储关系就不再变化\n\n数组采用顺序存储方式表示\n"},{"title":"线性表的顺序存储结构是一种（        ）的存储结构。","choices":["\n随机存取\n","\n顺序存取\n","\n索引存取\n","\n散列存取\n"],"correct_choice":"\n随机存取\n"},{"title":"  合法的数组说明语句是（  ） ","choices":["\nint a[] = \"string\";\n","\nint a[5] = {0.1, 2, 3, 4};\n","\nchar a = \"string \";\n","\nchar a[] = {0, 1, 2, 3, 4, 5};\n"],"correct_choice":"\nchar a[] = {0, 1, 2, 3, 4, 5};\n"},{"title":"矩阵中的行列数往往是不相等的，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"\n  线性表的顺序存储结构是一种\n  (\n  )\n  的存储结构。\n","choices":["\n随机存取\n","\n顺序存取\n","\n索引存取\n","\n散列存取\n"],"correct_choice":"\n随机存取\n"},{"title":"  若二维数组 a 有 m 列，则在数组元素 a[i][j] 前的元素个数为（   ）\n  \n","choices":["\nj * m + i\n","\ni * m + j\n","\ni * m + j - 1\n","\nj * m + i - 1\n"],"correct_choice":"\ni * m + j\n"},{"title":"取顺序表的第i个元素的时间同i的大小有关()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下面哪项是数组优于链表的特点?","choices":["\n方便删除\n","\n方便插入\n","\n长度可变\n","\n存储空间小\n"],"correct_choice":"\n存储空间小\n"},{"title":"下述哪一条是顺序存储结构的优点?()","choices":["\n插入运算方便\n","\n可方便地用于各种逻辑结构的存储表示\n","\n存储密度大\n","\n删除运算方便\n"],"correct_choice":"\n存储密度大\n"},{"title":"Which statement is true for the class java.util.ArrayList?","choices":["\nThe elements in the collection are ordered.\n","\nThe collection is guaranteed to be immutable.\n","\nThe elements in the collection are guaranteed to be unique.\n","\nThe elements in the collection are accessed using a unique key.\n","\nThe elements in the collections are guaranteed to be synchronized.\n"],"correct_choice":"\nThe elements in the collection are ordered.\n"},{"title":"在一个长为33厘米的光滑凹轨上，在第3厘米、第6厘米、第19厘米、第22\n厘米、第26厘米处各有一个钢珠，凹轨很细，不能同时通过两个钢珠，开始时，钢珠运动方向是任意的。两个钢珠相撞后，以相同速度反向运动。假设所有钢珠初 始速度为每秒运动1厘米，那么所有钢珠离开凹轨的最长可能时间是（）","choices":["\n30\n","\n26\n","\n38\n","\n33\n"],"correct_choice":"\n30\n"},{"title":"下面有关数据结构的说法是正确的？","choices":["\n数组和链表都可以随机访问\n","\n数组的插入和删除可以 O(1)\n","\n哈希表没有办法做范围检查\n","\n以上说法都不正确\n"],"correct_choice":"\n数组的插入和删除可以 O(1)\n"},{"title":"线性表的长度是线性表所占用的存储空间的大小。 ","choices":["\nT\n","\nF\n"],"correct_choice":"\nF\n"},{"title":"\n\n  假定有k个关键字互为同义词，若用线性探测法把这k个关键字存入散列表中，至少要进行多少次探测？(   \n      ) \n  \n\n\n  \n","choices":["\nk-1次\n","\nk次\n","\nk+1次\n","\nk（k+1）/2次\n"],"correct_choice":"\nk（k+1）/2次\n"},{"title":"  如有定义：char str[20];，能将从键盘输入的字符串“How are you”保存到 str 数组的语句是（   ）\n","choices":["\nscanf(\"%s\", str);\n","\nstr[] = getch();\n","\ngets(str);\n","\nstr = gets();\n"],"correct_choice":"\ngets(str);\n"},{"title":"需要频繁的插入删除操作使用什么结构比较合适?","choices":["\n数组\n","\n队列\n","\n链表\n","\n栈\n"],"correct_choice":"\n链表\n"},{"title":"\n  假设有60行70列的二维数组\n  a[1\n  …60, 1…70\n  ]\n  以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素\n  a[\n  32,58\n  ]\n  的存储地址为\n","choices":["\n16902\n","\n16904\n","\n14454\n","\n以上答案均不对\n"],"correct_choice":"\n16902\n"},{"title":"\n  对于一维整形数组\n  a\n  ，以下描述正确的是（）\n","choices":["\nint a(10)\n","\nint n=10,a[n]\n","\nint n\nscanf(“%d”, &n)\nint a[n]\n","\n#define SIZE 10\nint a[SIZE]\n"],"correct_choice":"\n#define SIZE 10\nint a[SIZE]\n"},{"title":"在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（）","choices":["\n没区别\n","\n行优先快\n","\n列优先快\n","\n2种读取方式速度为随机值，无法判断\n"],"correct_choice":"\n行优先快\n"},{"title":"  A为整数数组， N为A的数组长度，请问执行以下代码，最坏情况下的时间复杂度为____。 \n\n  void fun(int A[], int n) {                                                                        \n    for (int i = n - 1; i >= 1; i--) {                                                           \n        for (int j = 0; j < i; j++) {                                                             \n            if (A[j] > A[j+1]) {                                                                 \n                int tmp = A[j + 1];                                                               \n                A[j + 1] = A[j];\n                A[j] = tmp;\n         }\n      }\n   }\n}\n","choices":["\nO(N)\n","\nO(N^2)\n","\nO(Nlog(N))\n","\nO(log(N))\n","\nO(N^3)\n","\n无法确定\n"],"correct_choice":"\nO(N^2)\n"},{"title":"数组A[0..5,0..6]的每个元素占5个字节,将其按列优先次序存储在起始地址为1000的内存单元中,则元素A[5,5]的地址是()","choices":["\n1175\n","\n1180\n","\n1205\n","\n1210\n"],"correct_choice":"\n1175\n"},{"title":"设A是n*n的对称矩阵,将A的对角线及对角线上方的元素以列为主的次序存放在一维数组B[1..n(n+1)/2]中,对上述任一元素aij\n (1<=i,j<=n,且i<=j)在B中的位置为()","choices":["\ni(i-1)/2+j\n","\nj(j-1)/2+i\n","\nj(j-1)/2+i-1\n","\ni(i-1)/2+j-1\n"],"correct_choice":"\nj(j-1)/2+i\n"},{"title":"  若有以下程序段： \n  …… \n  int a[]={4,0,2,3,1},i,j,t; \n  for(i=1;i<5;i++) \n  { \n  t=a[i]; \n  j=i-1; \n  while(j>=0&&t>a[j]) \n  { \n  a[j+1]=a[j]; \n  --j; \n  } \n  a[j+1]=t; \n  } \n  …… \n  则该程序段的功能是：       ","choices":["\n对数组a进行插入排序（升序）\n","\n对数组a进行插入排序（降序）\n","\n对数组a进行选择排序（升序）\n","\n对数组a进行选择排序（降序）\n"],"correct_choice":"\n对数组a进行插入排序（降序）\n"},{"title":"设有数组A[i,j],数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5,8]的存储首地址为()。","choices":["\nBA+180\n","\nBA+225\n","\nBA+222\n","\nBA+141\n"],"correct_choice":"\nBA+180\n"},{"title":"Which statement declares a variable a which is suitable for referring to\nan array of 50 string objects?","choices":["\nchar a[][];\n","\nString a[];\n","\nString[] a;\n","\nObject a[50];\n","\nString a[50];\n","\nObject a[];\n"],"correct_choice":"\nString a[];\n\nString[] a;\n\nObject a[];\n"},{"title":"  假设以数组Data[0..m-1]存放循环队列的元素，其头尾指针分别为front和rear，则当前队列中的元素个数为 \n\n  \n","choices":["\n（rear-front+m）%m\n","\nrear-front+1\n","\n（front-rear+m）%m\n","\n（rear-front）%m\n"],"correct_choice":"\n（rear-front+m）%m\n"},{"title":"\n  数组\n  A[0…5\n  ，\n  0…6]\n  的每个元素占\n  5\n  个字节，将其按列优先次序存储在起始地址为\n  1000\n  的内存单元中，则元素\n  A[5\n  ，\n  5]\n  的地址为\n  \n    \n  \n\n\n  \n","choices":["\n1175\n","\n1180\n","\n1205\n","\n1210\n"],"correct_choice":"\n1175\n"},{"title":"对任何数据结构链式存储结构一定优于顺序存储结构()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"数组可看作基本线性表的一种推广，因此与线性表一样，可以对它进行插入、删除等操作，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"以下能对一维数组 a 进行正确初始化的语句是（）","choices":["\nint a[10]=(0, 0, 0, 0, 0);\n","\nint a[10]={  };\n","\nint a[]={0};\n","\nint a[10]={10*a};\n"],"correct_choice":"\nint a[10]={  };\n\nint a[]={0};\n"},{"title":"  设数组Data[0..m-1]作为循环队列SQ的存储空间，front为队头指针，rear为队尾指针，则执行出队操作的语句为（）。","choices":["\nfront=front+1\n","\nfront=(front+1)%m\n","\nrear=rear+1\n","\nrear=(rear+1)%m\n"],"correct_choice":"\nfront=(front+1)%m\n"},{"title":"  对两个数组 a 和 b 进行如下初始化 \nchar a[] = \"ABCDEF\";\nchar b[] = {'A','B','C','D','E','F'};\n  以下叙述正确的是(    )\n","choices":["\na 与 b 数组完全相同\n","\na 与 b 长度相同\n","\na 和 b 中都存放了字符串\n","\na 数组比 b 数组长\n"],"correct_choice":"\na 数组比 b 数组长\n"},{"title":"  对以下二维数组的正确声明是（   ）\n","choices":["\nint a[3][];\n","\nfloat a(3,4)\n","\ndouble a[][4];\n","\nfloat a(3)(4);\n"],"correct_choice":"\ndouble a[][4];\n"},{"title":"  定义了一维 int 型数组 a[10] 后，下面错误的引用是（   ）。\n","choices":["\na[0] = 1;\n","\na[0] = 5*2;\n","\na[10] = 2;\n","\na[1] = a[2] * a[0];\n"],"correct_choice":"\na[10] = 2;\n"},{"title":"假定一个二维数组的定义语句为“int a[3][4]={{3,4},{2,8,6}};”，则元素a[1][2]的值为（    ）。","choices":["\n2\n","\n4\n","\n6\n","\n8\n"],"correct_choice":"\n6\n"},{"title":"下面的说法那个正确 #define NUMA 10000000\n#define NUMB 1000\nint a[NUMA], b[NUMB];\n \nvoid pa()\n{\n    int i, j;\n    for(i = 0; i < NUMB; ++i) \n        for(j = 0; j < NUMA; ++j) \n            ++a[j]; \n} \nvoid pb() \n{ \n    int i, j; \n    for(i = 0; i < NUMA; ++i) \n        for(j = 0; j < NUMB; ++j) \n            ++b[j]; \n} \n","choices":["\npa 和 pb 运行的一样快\n","\npa 比 pb 快\n","\npb 比 pa 快\n","\n无法判断\n"],"correct_choice":"\npb 比 pa 快\n"},{"title":"  在定义 int a[3][4][2]; 后，第 20 个元素是（   ）\n","choices":["\na[2][1][1]\n","\na[1][0][1]\n","\na[2][0][1]\n","\na[2][2][1]\n"],"correct_choice":"\na[2][1][1]\n"},{"title":"\n  对线性表采用折半查找，该线性表必须_______。\n","choices":["\n元素按值有序排列\n","\n采用顺序结构\n","\n元素按值有序排列，并且采用顺序存储结构\n","\n元素按值有序排列，并且采用链式存储结构\n"],"correct_choice":"\n元素按值有序排列，并且采用顺序存储结构\n"},{"title":"顺序存储方式插入和删除时效率太低,因此它不如链式存储方式好()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"设有一个10阶的对称矩阵A,采用压缩存储方式,以行序为主存储,a11\n 为第一元素,其存储地址为1,每个元素占一个地址空间,则a85\n 的地址为()","choices":["\n13\n","\n33\n","\n18\n","\n40\n"],"correct_choice":"\n33\n"},{"title":"从逻辑结构上看,n维数组的每个元素均属于1个n维向量()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"下面数据结构能够支持随机的插入和删除操作、并具有较好的性能的是____。","choices":["\n数组和链表\n","\n链表和哈希表\n","\n哈希表和队列\n","\n队列和堆栈\n","\n堆栈和双向队列\n","\n双向队列和数组\n"],"correct_choice":"\n链表和哈希表\n"},{"title":"稀疏矩阵压缩存储后,必会失去随机存取功能()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"  若有语句 \n\n  \n\nchar s1[10], s2[10] = {\"books\"};\n  则能将字符串 books 存放到数组 s1 的正确语句是(   )\n","choices":["\nstrcpy(s1, s2);\n","\ns1 = {\"books\"};\n","\ns1 = s2;\n","\nstrcpy(s2, s1);\n"],"correct_choice":"\nstrcpy(s1, s2);\n"},{"title":"若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）","choices":["\nS1的栈底位置为0，S2的栈底位置为n+1\n","\nS1的栈底位置为0，S2的栈底位置为n/2\n","\nS1的栈底位置为1，S2的栈底位置为n\n","\nS1的栈底位置为1，S2的栈底位置为1\n"],"correct_choice":"\nS1的栈底位置为1，S2的栈底位置为n\n"},{"title":"\n  设某数据结构的二元组形式表示为\n  A=(D\n  ，\n  R)\n  ，\n  D={01\n  ，\n  02\n  ，\n  03\n  ，\n  04\n  ，\n  05\n  ，\n  06\n  ，\n  07\n  ，\n  08\n  ，\n  09}\n  ，\n  R={r}\n  ，\n  r={<01\n  ，\n  02>\n  ，\n  <01\n  ，\n  03>\n  ，\n  <01\n  ，\n  04>\n  ，\n  <02\n  ，\n  05>\n  ，\n  <02\n  ，\n  06>\n  ，\n  <03\n  ，\n  07>\n  ，\n  <03\n  ，\n  08>\n  ，\n  <03\n  ，\n  09>}\n  ，则数据结构A是（）\n  。\n","choices":["\n线性结构\n","\n树型结构\n","\n物理结构\n","\n图型结构\n"],"correct_choice":"\n树型结构\n"},{"title":"若长度为n的线性表采用顺序存储结构,在其第i个位置插入一个新元素的算法的时间复杂度为()(1<=i<=n+1)","choices":["\nO(0)\n","\nO(1)\n","\nO(n)\n","\nO(n2)\n"],"correct_choice":"\nO(n)\n"},{"title":"对线性表进行折半查找时,要求线性表必须()","choices":["\n以顺序方式存储\n","\n以顺序方式存储,且数据元素有序\n","\n以链接方式存储\n","\n以链接方式存储,且数据元素有序\n"],"correct_choice":"\n以顺序方式存储,且数据元素有序\n"},{"title":"  请问下面哪种方式可以在不改变原来数组的情况下，拷贝出数组 b ，且满足 b!=a 。例如数组 a 为 [1,2,3] 。  ","choices":["\nlet b=a;\n","\nlet b=a.slice();\n","\nlet b=a.splice(0,0);\n","\nlet b=a.concat();\n"],"correct_choice":"\nlet b=a.concat();\n"},{"title":"int A[2][3]={1,2,3,4,5,6}; 则A[1][0]和*(*(A+1)+1)的值分别是（）","choices":["\n4 5\n","\n4 3\n","\n3 5\n","\n3 4\n"],"correct_choice":"\n4 5\n"},{"title":"顺序表结构适宜于进行随机存取。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"以下一维整型数据 a 的声明正确的是（   ）\n\n","choices":["\nint a(10);\n","\nint n = 10, a[n];\n","\nint n;\nscanf(\"%d\", &n);\nint a[n];\n","\n#define N 10\nint a[N];\n"],"correct_choice":"\n#define N 10\nint a[N];\n"},{"title":"  下面对一维数组 a 进行正确的初始化的语句是(   )\n","choices":["\nint a[10] = (0, 0, 0, 0, 0);\n","\nint a[10] = {};\n","\nint a[10] = {10};\n","\nint a[10] = {10, 0, -1.0};\n"],"correct_choice":"\nint a[10] = {10};\n"},{"title":"  设二维数组 A[1 … m,1 … n] 按行存储在数组 B 中，则二维数组元素 A[i,j] 在一维数组 B 中的下标为         。  ","choices":["\nn*(i-1)+j\n","\nn*(i-1)+j-1\n","\ni*(j-1)\n","\nj*m+i-1\n"],"correct_choice":"\nn*(i-1)+j\n"},{"title":"设数组a[]作为循环队列SQ的存储空间，数组的长度为m，f为队头指示，r为队尾指示则执行出队操作的语句为","choices":["\nf=f+1\n","\nf=(f+1)%m\n","\nr=(r+1)%m\n","\nf=(f+1)%(m+1)\n"],"correct_choice":"\nf=(f+1)%m\n"},{"title":"设有数组A[i,j],数组的每个元素长度为3字节,i的值为1到8,j的值为1到10,数组从内存首地址BA开始顺序存放,当用以列为主存放时,元素A[5,8]的存储首地址为()","choices":["\nBA+141\n","\nBA+180\n","\nBA+222\n","\nBA+225\n"],"correct_choice":"\nBA+180\n"},{"title":"链表和数组的区别。","choices":["\n在有序的情况下搜索\n","\n插入和删除\n","\n随机访问\n","\n数据存储类型\n"],"correct_choice":"\n在有序的情况下搜索\n\n插入和删除\n\n随机访问\n"},{"title":"设有一个\n10\n阶的下三角矩阵\nA\n（包括对角线），按照从上到下、从左到右的顺序存储到连续的\n55\n个存储单元中，每个数组元素占\n1\n个字节的存储空间，则\nA[5][4]\n地址与\nA[0][0]\n的地址之差为（\n）。","choices":["\n10\n","\n19\n","\n28\n","\n55\n"],"correct_choice":"\n19\n"},{"title":"  若有说明：int a[3][4];，则对 a 数组元素的正确引用是(   ）。\n","choices":["\na[2][4]\n","\na[1,3]\n","\na[1+1][0]\n","\na(2)(1)\n"],"correct_choice":"\na[1+1][0]\n"},{"title":"若二维数组 a 有 m 列，则在数组元素 a[i][j] 前的元素个数为（）","choices":["\nj * m + i\n","\ni * m + j\n","\ni * m + j - 1\n","\nj * m + i - 1\n"],"correct_choice":"\ni * m + j\n"},{"title":"和顺序栈相比,链栈有一个比较明显的优势是()","choices":["\n通常不会出现栈满的情况\n","\n通常不会出现栈空的情况\n","\n插入操作更容易实现\n","\n删除操作更容易实现\n"],"correct_choice":"\n通常不会出现栈满的情况\n"},{"title":"已知int a[3][4];则下列能表示a[1][2]元素值的是","choices":["\n*（*（a+1）+2）\n","\n*(a+1+2)\n","\n(&a[0]+1)[2]\n","\n*(a[0]+1)\n"],"correct_choice":"\n*（*（a+1）+2）\n"},{"title":"\n 下列给定程序中，函数fun的功能是:进行数字字符转换。若形参ch中是数字字符'0'～'9',则将'0'转换成'9','1'转换成'8', '2'转换成'7',…, '9'转换成'0';如果是其他字符则保持不变，并将转换后的结果作为函数值返回。 \n  请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。 \n  试题程序。 #include<stdio.h>\n_____ fun(char ch)\n{\n    if(ch>='0'&& _______)\n        return'9'-(ch- ______);\n    return ch;\n}\nmain( )\n{  \n    char c1,c2;\n    printf(\"\\nThe result:\\n\");\n    c1='2';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n    c1='8';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n    c1='a';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n}\n","choices":["\nint ch<='9'  '0'\n","\nchar   ch<='9'  '0'\n","\nchar   ch<='9'  0\n","\nint ch<='9'  0\n"],"correct_choice":"\nint ch<='9'  '0'\n\nchar   ch<='9'  '0'\n"},{"title":"  设有一个 10 阶的对称矩阵 A ，采用压缩存储方式，以行序为主存储， a1   ，   1  为第一个元素，其存储地址为 1 ，每个元素占 1 个地址空间，则 a8   ，   5  的地址为         。  ","choices":["\n13\n","\n33\n","\n18\n","\n40\n"],"correct_choice":"\n33\n"},{"title":"设有一个10阶对称矩阵A[10][10]，采用压缩存储方式按行将矩阵中的下三角部分的元素存入一维数组B[\n ]中，A[0][0]存入B[0]中，则A[8][6]在B[  ]的（    ）位置。    ","choices":["\n32\n","\n33\n","\n42\n","\n65\n"],"correct_choice":"\n42\n"},{"title":"\n  数组A=array[1..100，1..100]以行序为主序存储，设每个数据元素占2个存储单元，基地址为10，则LOC[5，5]应为。\n\n\n  \n","choices":["\n1020\n","\n1010\n","\n818\n","\n808\n"],"correct_choice":"\n818\n"},{"title":"顺序存储结构的主要缺点是不利于插入或删除操作()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"矩阵中的数据元素可以是不同的数据类型 ，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"在C语言中，顺序存储长度为3的字符串，需要占用（    ）个字节。","choices":["\n3\n","\n4\n","\n6\n","\n12\n"],"correct_choice":"\n4\n"},{"title":"\n  若用一个大小为\n  6\n  的数组来实现循环队列，且当\n  rear\n  和\n  front\n  的值分别为\n  0\n  和\n  3\n  。当从队列中删除一个元素，再加入两个元素后，\n  rear\n  和\n  front\n  的值分别为\n  \n  。\n","choices":["\n1和5\n","\n2和4\n","\n4和2\n","\n5和1\n"],"correct_choice":"\n2和4\n"},{"title":"有n个数存放在一维数组A[1,n]中,在进行顺序查找时,这n个数的排列有序或无序其平均查找长度不同()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  取线性表的第i个元素的时间同i的大小有关\n  。\n\n\n  \n\n\n  \n    \n  \n","choices":["\n是\n","\n否\n"],"correct_choice":"\n否\n"},{"title":"\n  稀疏矩阵一般采用三元组顺序表方法压缩存储\n  。\n  ( \n   )\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"当很频繁地对序列中部进行插入和删除操作时，应该选择使用的容器是（）","choices":["\nvector\n","\nlist\n","\ndeque\n","\nstack\n"],"correct_choice":"\nlist\n"},{"title":"一个非空广义表的表尾()","choices":["\n不能是子表\n","\n只能是子表\n","\n只能是原子\n","\n是原子或子表\n"],"correct_choice":"\n只能是子表\n"},{"title":"通常对数组进行的两种基本操作是（   ）","choices":["\n建立与删除\n","\n索引和修改\n","\n查找和修改\n","\n查找与索引\n"],"correct_choice":"\n查找和修改\n"},{"title":"  如有定义：char str[20];，能将从键盘输入的字符串“How are you”保存到 str 数组的语句是（   ）\n","choices":["\nscanf(\"%s\", str);\n","\nstr[] = getch();\n","\ngets(str);\n","\nstr = gets();\n"],"correct_choice":"\ngets(str);\n"},{"title":"下面关于线性表的叙述中,错误的是哪一个()","choices":["\n线性表采用顺序存储,必须占用一片连续的存储单元\n","\n线性表采用顺序存储,便于进行插入和删除操作\n","\n线性表采用链接存储,不必占用一片连续的存储单元\n","\n线性表采用链接存储,便于插入和删除操作\n"],"correct_choice":"\n线性表采用顺序存储,便于进行插入和删除操作\n"},{"title":"线性表采用链式存储时，其地址________。","choices":["\n必须是连续的\n","\n一定是不连续的\n","\n部分地址必须是连续的\n","\n连续与否均可以\n"],"correct_choice":"\n连续与否均可以\n"},{"title":"有一个用数组 C[1..m]表示的环形队列，m 为数组的长度。假设 f 为队头元素在数组中的位置，r 为队尾元素的后一位置(按顺时针方向)。若队列非空，则计算队列中元素个数的公式应为？","choices":["\n（m+r-f）mod m\n","\nr-f\n","\n(m-r+f) mod m\n","\n(m-r-f) mod m\n","\n(r-f) mod m\n"],"correct_choice":"\n（m+r-f）mod m\n"},{"title":"short a[100]，sizeof(a) 返回什么？","choices":["\n2\n","\n4\n","\n100\n","\n200\n","\n400\n"],"correct_choice":"\n200\n"},{"title":"char str[]=”Hello”,sizeof(str)=（）","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n6\n"},{"title":"对于不同的特殊矩阵应该采用不同的存储方式，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n正确\n"},{"title":"既希望较快的查找又便于线性表动态变化的查找方法是()","choices":["\n顺序查找\n","\n折半查找\n","\n分块查找\n","\n哈希法查找\n"],"correct_choice":"\n分块查找\n"},{"title":"  下列选项中，能正确定义数组的语句是（   ）。\n  \n  \n","choices":["\nint num[0..2008];\n","\nint num[]={2008};\n","\nint N = 2008;\nint num[N];\n","\n#define N 2008;\nint num[N];\n"],"correct_choice":"\nint num[]={2008};\n"},{"title":"数组元素的下标值越大，存取时间越长，这样的说法正确吗？","choices":["\n正确\n","\n不正确\n"],"correct_choice":"\n不正确\n"},{"title":"一个顺序表第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是（   ）。","choices":["\n110\n","\n108\n","\n100\n","\n120\n"],"correct_choice":"\n108\n"},{"title":"\n  若有\n  18\n  个元素的有序表存放在一维数组\n  A[19]\n  中，第一个元素放\n  A[1]\n  中，现进行二分查找，则查找\n  A\n  ［\n  3\n  ］的比较序列的下标依次为\n  (      )\n\n","choices":["\n1，2，3\n","\n9，5，2，3\n","\n9，5，3\n","\n9，4，2，3\n"],"correct_choice":"\n9，4，2，3\n"},{"title":"有n个数存放在一维数组A[1..n]中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不同。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"在以下哪个操作中， 数组比链表更快?","choices":["\n原地逆序\n","\n头部插入\n","\n返回头节点\n","\n返回随机节点\n"],"correct_choice":"\n返回随机节点\n"}]