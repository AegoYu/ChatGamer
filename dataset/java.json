[{"title":"\n  下面哪个不是Java语言的关键字（）\n","choices":["\ndefault\n","\nnumber\n","\nabstract\n","\npackage\n"],"correct_choice":"\nnumber\n"},{"title":"JDK中提供的java、javac、jar等开发工具也是用Java编写的。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  队列(Queue)是先进先出的。（  ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  关于ASCII码和ANSI码，以下说法不正确的是（）？ ","choices":["\n标准ASCII只使用7个bit\n","\n在简体中文的Windows系统中，ANSI就是GB2312\n","\nASCII码是ANSI码的子集\n","\nASCII码都是可打印字符\n"],"correct_choice":"\nASCII码都是可打印字符\n"},{"title":"下列类定义中哪些是合法的抽象类的定义？（）","choices":["\nabstract Animal{abstract void growl();}\n","\nclass abstract Animal{abstract  void growl();}\n","\nabstract class Animal{abstract  void growl();}\n","\nabstract class Animal{abstract  void growl(){System.out.println( “growl”);};}\n"],"correct_choice":"\nabstract class Animal{abstract  void growl();}\n"},{"title":"\n  下列关于计算机系统和Java编程语言的说法，正确的是（）\n","choices":["\n计算机是由硬件、操作系统和软件组成，操作系统是缺一不可的组成部分。\n","\nJava语言编写的程序源代码可以不需要编译直接在硬件上运行。\n","\n在程序中书写注释不会影响程序的执行，可以在必要的地方多写一些注释。\n","\nJava的集成开发环境（IDE），如Eclipse，是开发Java语言必需的软件工具。\n"],"correct_choice":"\n在程序中书写注释不会影响程序的执行，可以在必要的地方多写一些注释。\n"},{"title":"\n  A\n  派生出子类\n  B \n  ，\n  B\n  派生出子类\n  C\n  ，并且在\n  Java\n  源代码中有如下声明：\n\n\n  1.\n  A  a0=new  A();\n\n\n  2.\n  A  a1 =new  B();\n\n\n  3.\n  A  a2=new  C();\n\n\n  问以下哪个说法是正确的？\n   （ ）\n","choices":["\n只有第1行能通过编译\n","\n第1、2行能通过编译，但第3行编译出错\n","\n第1、2、3行能通过编译，但第2、3行运行时出错\n","\n第1行、第2行和第3行的声明都是正确的\n"],"correct_choice":"\n第1行、第2行和第3行的声明都是正确的\n"},{"title":"\n  下面程序段执行完成后，则变量sum的值是(    )。\n\n\n  \n    \n      \n          int  b[][]={{1},   {2,2}, {2,2,2}};\n        \n        \n          int sum=0;\n        \n        \n          for(int i=0;i<b.length;i++) { \n        \n        \n               for(int   j=0;j<b[i].length;j++) {\n        \n        \n                   sum+=b[i][j];\n        \n        \n               } \n        \n        \n          }\n        \n      \n  \n","choices":["\n32\n","\n11\n","\n2\n","\n3\n"],"correct_choice":"\n11\n"},{"title":"  对于子类的构造函数说明，下列叙述中错误的是（    ）。 ","choices":["\n子类可以继承父类的构造函数。\n","\n子类中调用父类构造函数不可以直接书写父类构造函数，而应该用super();。\n","\n用new创建子类的对象时，若子类没有带参构造函数，将先执行父类的无参构造函数，然后再执行自己的构造函数。\n","\n子类的构造函数中可以调用其他函数。\n"],"correct_choice":"\n子类可以继承父类的构造函数。\n"},{"title":"\n  java\n  语言使用的字符码集是\n","choices":["\nASCII\n","\nBCD\n","\nDCB\n","\nUnicode\n"],"correct_choice":"\nUnicode\n"},{"title":"  下面程序的输出是:() \nString x=\"fmn\";\nx.toUpperCase();\nString y=x.replace('f','F');\ny=y+\"wxy\";\nSystem.out.println(y);","choices":["\nFmNwxy\n","\nfmnwxy\n","\nwxyfmn\n","\nFmnwxy\n"],"correct_choice":"\nFmnwxy\n"},{"title":"下列说法正确的有（）","choices":["\nclass中的constructor不可省略\n","\nconstructor必须与class同名，但方法不能与class同名\n","\nconstructor在一个对象被new时执行\n","\n一个class只能定义一个constructor\n"],"correct_choice":"\nconstructor在一个对象被new时执行\n"},{"title":"ArrayList和Vector主要区别是什么？","choices":["\nVector与ArrayList一样，也是通过数组实现的，不同的是Vector支持线程的同步\n","\nVector与ArrayList一样，也是通过数组实现的，不同的是ArrayList支持线程的同步\n","\nVector是通过链表结构存储数据，ArrayList是通过数组存储数据\n","\n上述说法都不正确\n"],"correct_choice":"\nVector与ArrayList一样，也是通过数组实现的，不同的是Vector支持线程的同步\n"},{"title":"下面哪个不是标准Statement类？","choices":["\nStatement\n","\nPreparedStatement\n","\nCallableStatement\n","\nBatchedStatement\n"],"correct_choice":"\nBatchedStatement\n"},{"title":"  下面函数将返回？ \npublic static int func (){\n    try{\n        return 1;\n    }catch (Exception e){\n        return 2;\n    }finally{\n        return 3;\n    }\n}","choices":["\n1\n","\n2\n","\n3\n","\n编译错误\n"],"correct_choice":"\n3\n"},{"title":"\n  int i=5;\n\n\n   int s=(i++)+(++i)+(i--)+(--i);\n\n\n   s=( )//s\n  的值是什么？\n","choices":["\n28\n","\n25\n","\n21\n","\n26\n","\n24\n","\n23\n"],"correct_choice":"\n24\n"},{"title":" 对于abstract声明的类，下面说法正确的是","choices":["\n可以实例化\n","\n不可以被继承\n","\n子类为abstract\n","\n只能被继承\n","\n可以被抽象类继承\n"],"correct_choice":"\n可以被抽象类继承\n"},{"title":"关于String，StringBuilder以及StringBuffer，描述错误的是（）","choices":["\n对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象\n","\nStringBuffer是线程安全\n","\nStringBuilder是线程安全\n","\n可以修改StringBuilder和StringBuffer的内容\n"],"correct_choice":"\nStringBuilder是线程安全\n"},{"title":"下列关于java 中的 wait()方法和 sleep()方法的区别描述错误的是？","choices":["\nwait()方法属于Object类，sleep()属于Thread类\n","\n调用wait()方法的时候，线程会放弃对象锁\n","\n调用sleep()方法的过程中，线程不会释放对象锁\n","\nsleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程\n"],"correct_choice":"\nsleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程\n"},{"title":"下面有关List接口、Set接口和Map接口的描述，错误的是？","choices":["\n他们都继承自Collection接口\n","\nList是有序的Collection，使用此接口能够精确的控制每个元素插入的位置\n","\nSet是一种不包含重复的元素的Collection\n","\nMap提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value\n"],"correct_choice":"\n他们都继承自Collection接口\n"},{"title":"下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：\nbyte[] src,dst;\n","choices":["\ndst=String.fromBytes(src，\"GBK\").getBytes(\"UTF-8\")\n","\ndst=new String(src，\"GBK\").getBytes(\"UTF-8\")\n","\ndst=new String(\"GBK\"，src).getBytes()\n","\ndst=String.encode(String.decode(src，\"GBK\"))，\"UTF-8\" )\n"],"correct_choice":"\ndst=new String(src，\"GBK\").getBytes(\"UTF-8\")\n"},{"title":"  考虑下面这个简单的例子，让我们看看reflection是如何工作的。 \nimport java.lang.reflect.*;\npublic class DumpMethods{\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tClass c=Class.forName(args[0]);\n\t\t\tMethod m[]=c.getDeclaredMethods();\n\t\t\tfor (int i = 0; i < m.length; i++) {\n\t\t\t\tSystem.out.println(m[i].toString());\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n}\n  其中\"c.getDeclaredMethods\"的作用是: ","choices":["\n取得类的公有方法对象\n","\n取得类的所有公有方法名称\n","\n取得类的所有方法对象\n","\n以上选项都不正确\n"],"correct_choice":"\n以上选项都不正确\n"},{"title":"下列关于java并发的说法中正确的是：","choices":["\ncopyonwritearraylist适用于写多读少的并发场景\n","\nreadwritelock适用于读多写少的并发场景\n","\nconcurrenthashmap的写操作不需要加锁，读操作需要加锁\n","\n只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了\n"],"correct_choice":"\nreadwritelock适用于读多写少的并发场景\n"},{"title":"下面哪个不对？","choices":["\nRuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine.\n","\nA method is not required to declare in its throws clause any subclasses of RuntimeExeption that might be thrown during the execution of the method but not caught\n","\nAn RuntimeException is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\n","\nNullPointerException is one kind of RuntimeException\n"],"correct_choice":"\nAn RuntimeException is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.\n"},{"title":"不能用来修饰interface的有（ ）（仅限外部接口）","choices":["\nprivate\n","\npublic\n","\nprotected\n","\nstatic\n"],"correct_choice":"\nprivate\n\nprotected\n\nstatic\n"},{"title":"  关于抽象类与接口，下列说法正确的有？ ","choices":["\n优先选用接口，尽量少用抽象类\n","\n抽象类可以被声明使用，接口不可以被声明使用\n","\n抽象类和接口都不能被实例化。\n","\n以上说法都不对\n"],"correct_choice":"\n优先选用接口，尽量少用抽象类\n\n抽象类和接口都不能被实例化。\n"},{"title":"线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?","choices":["\nMap map = new HashMap()\n","\nMap map = new TreeMap()\n","\nMap map = new ConcurrentHashMap();\n","\nMap map = Collections.synchronizedMap(new HashMap());\n"],"correct_choice":"\nMap map = new ConcurrentHashMap();\n\nMap map = Collections.synchronizedMap(new HashMap());\n"},{"title":"在java中，下列标识符不合法的有（ ）","choices":["\nnew\n","\n$Usdollars\n","\n1234\n","\ncar.taxi\n"],"correct_choice":"\nnew\n\n1234\n\ncar.taxi\n"},{"title":"以下哪些jvm的垃圾回收方式采用的是复制算法回收","choices":["\n新生代串行收集器\n","\n老年代串行收集器\n","\n并行收集器\n","\n新生代并行回收收集器\n","\n老年代并行回收收集器\n","\ncms收集器\n"],"correct_choice":"\n新生代串行收集器\n\n新生代并行回收收集器\n"},{"title":"下列说法错误的有（ ）","choices":["\n在类方法中可用this来调用本类的类方法\n","\n在类方法中调用本类的类方法时可直接调用\n","\n在类方法中只能调用本类中的类方法\n","\n在类方法中绝对不能调用实例方法\n"],"correct_choice":"\n在类方法中可用this来调用本类的类方法\n\n在类方法中只能调用本类中的类方法\n\n在类方法中绝对不能调用实例方法\n"},{"title":"\n  不考虑反射机制，一个子类显式调用父类的构造器必须用super关键字。（  ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"派生类的对象对其基类中（  ）可直接访问。","choices":["\n公有继承的公有成员\n","\n公有继承的私有成员\n","\n公有继承的保护成员\n","\n私有继承的公有成员\n"],"correct_choice":"\n公有继承的公有成员\n"},{"title":"\n  下列说法哪个正确(    )\n  \n","choices":["\n不需要定义类，就能创建对象\n","\n对象中必须有数据域和方法\n","\n数据域可以是基本类型变量，也可以是一个对象\n","\n数据域必须是基本类型变量\n"],"correct_choice":"\n数据域可以是基本类型变量，也可以是一个对象\n"},{"title":"\n  在\n  main()\n  方法中给出的字节数组，如果将其显示到控制台上，需要使用（ ）。\n","choices":["\nSystem.out.print (buffer[i]);\n","\nFileOutputStream fout = new FileOutputStream(this.filename);\n","\nFileInputStream fin = new FileInputStream(this.filename);\n","\nSystem.in.read(buffer)。\n"],"correct_choice":"\nSystem.out.print (buffer[i]);\n"},{"title":"\n  下列代码中的错误是（）\n\n\n  (1)   public class Test\n\n\n  (2)   {\n\n\n  (3)       public static void main(String [] args)\n\n\n  (4)       {\n\n\n  (5)           int i;\n\n\n  (6)           i+=1;\n\n\n  (7)       }\n\n\n  (8)\n     \n  }\n\n\n  \n","choices":["\n非法的表达式 i+=1\n","\n找不到符号i\n","\n类不应为public\n","\n尚未初始化变量i\n"],"correct_choice":"\n尚未初始化变量i\n"},{"title":"Java Application 源程序的主类是指包含有（ ）方法的类。","choices":["\npublic static void main方法\n","\ntoString方法\n","\ninit方法\n","\nactionPerfromed方法\n"],"correct_choice":"\npublic static void main方法\n"},{"title":"\n  “先进先出”的容器是：( \n   )\n\n\n  \n","choices":["\n堆栈(Stack)\n","\n队列（Queue）\n","\n字符串(String)\n","\n迭代器(Iterator)\n"],"correct_choice":"\n队列（Queue）\n"},{"title":"  下面论述正确的是（）？ ","choices":["\n如果两个对象的hashcode相同，那么它们作为同一个HashMap的key时，必然返回同样的值\n","\n如果a,b的hashcode相同，那么a.equals(b)必须返回true\n","\n对于一个类，其所有对象的hashcode必须不同\n","\n如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同\n"],"correct_choice":"\n如果a.equals(b)返回true，那么a,b两个对象的hashcode必须相同\n"},{"title":"关于Java语言的内存回收机制，下列选项中最正确的一项是","choices":["\nJava程序要求用户必须手工创建一个线程来释放内存\n","\nJava程序允许用户使用指针来释放内存\n","\n内存回收线程负责释放无用内存\n","\n内存回收线程不能释放内存对象\n"],"correct_choice":"\n内存回收线程负责释放无用内存\n"},{"title":"在Java中，( )类提供定位本地文件系统，对文件或目录及其属性进行基本操作","choices":["\nFileInputStream\n","\nFileReader\n","\nFileWriter\n","\nFile\n"],"correct_choice":"\nFile\n"},{"title":"以下说法错误的是（）\n","choices":["\n数组是一个对象\n","\n数组不是一种原生类\n","\n数组的大小可以任意改变\n","\n在Java中，数组存储在堆中连续内存空间里\n"],"correct_choice":"\n数组的大小可以任意改变\n"},{"title":"下面程序的运行结果是\nString str1 = \"hello\";\nString str2 = \"he\" + new String(\"llo\");\nSystem.err.println(str1 == str2);\n","choices":["\ntrue\n","\nfalse\n","\nexception\n","\n无输出\n"],"correct_choice":"\nfalse\n"},{"title":"  有如下4条语句：() \nInteger i01=59;\nint i02=59;\nInteger i03=Integer.valueOf(59);\nInteger i04=new Integer(59);\n  以下输出结果为false的是: ","choices":["\nSystem.out.println(i01==i02);\n","\nSystem.out.println(i01==i03);\n","\nSystem.out.println(i03==i04);\n","\nSystem.out.println(i02==i04);\n"],"correct_choice":"\nSystem.out.println(i03==i04);\n"},{"title":"关于C++/JAVA类中static 成员和对象成员的说法正确的是？","choices":["\nstatic 成员变量在对象构造时生成\n","\nstatic 成员函数在对象成员函数中无法调用\n","\n虚成员函数不可能是static 成员函数\n","\nstatic 成员函数不能访问static 成员变量\n"],"correct_choice":"\n虚成员函数不可能是static 成员函数\n"},{"title":"下面有关java基本类型的默认值和取值范围，说法错误的是？","choices":["\n字节型的类型默认值是0，取值范围是-2^7—2^7-1\n","\nboolean类型默认值是false，取值范围是true\\false\n","\n字符型类型默认是0，取值范围是-2^15 —2^15-1\n","\nlong类型默认是0，取值范围是-2^63—2^63-1\n"],"correct_choice":"\n字符型类型默认是0，取值范围是-2^15 —2^15-1\n"},{"title":"下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？","choices":["\nprivate\n","\n无修饰符\n","\npublic\n","\nprotected\n"],"correct_choice":"\n无修饰符\n"},{"title":"语句：char foo='中'，是否正确？（假设源文件以GB2312编码存储，并且以javac – encoding GB2312命令编译）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"关于 JAVA 堆,下面说法错误的是()","choices":["\n所有类的实例和数组都是在堆上分配内存的\n","\n对象所占的堆内存是由自动内存管理系统回收\n","\n堆内存由存活和死亡的对象,空闲碎片区组成\n","\n数组是分配在栈中的\n"],"correct_choice":"\n数组是分配在栈中的\n"},{"title":"  有关下述Java代码描述正确的选项是____。 \n\n  public class TestClass {\n   private static void testMethod(){\n        System.out.println(\"testMethod\");\n   }\n   public static void main(String[] args) {\n        ((TestClass)null).testMethod();\n   }\n}\n","choices":["\n编译不通过\n","\n编译通过，运行异常，报NullPointerException\n","\n编译通过，运行异常，报IllegalArgumentException\n","\n编译通过，运行异常，报NoSuchMethodException\n","\n编译通过，运行异常，报Exception\n","\n运行正常，输出testMethod\n"],"correct_choice":"\n运行正常，输出testMethod\n"},{"title":"JAVA语言的下面几种数组复制方法中，哪个效率最高？","choices":["\nfor循环逐一复制\n","\nSystem.arraycopy\n","\nArrays.copyof\n","\n使用clone方法\n"],"correct_choice":"\nSystem.arraycopy\n"},{"title":"下面哪一项不属于优化Hibernate所鼓励的？","choices":["\n使用单向一对多关联，不使用双向一对多\n","\n不用一对一，用多对一取代\n","\n配置对象缓存，不使用集合缓存\n","\n继承类使用显式多态\n"],"correct_choice":"\n使用单向一对多关联，不使用双向一对多\n"},{"title":"下面哪些接口直接继承自Collection接口（）","choices":["\nList\n","\nMap\n","\nSet\n","\nIterator\n"],"correct_choice":"\nList\n\nSet\n"},{"title":"以下哪个类型是基本数据类型（）","choices":["\nint\n","\nString\n","\nByte\n","\nFloat\n"],"correct_choice":"\nint\n"},{"title":"关于struts项目中的类与MVC模式的对应关系，说法错误的是","choices":["\nJsp文件实现视图View的功能\n","\nActionServlet这一个类是整个struts项目的控制器\n","\nActionForm、Action都属于Model部分\n","\n一个struts项目只能有一个Servlet\n"],"correct_choice":"\nActionForm、Action都属于Model部分\n\n一个struts项目只能有一个Servlet\n"},{"title":"  已知如下类定义： \nclass Base {  \n public Base (){ \n //... \n }  \n public Base ( int m ){ \n //... \n }  \n public void fun( int n ){ \n //... \n } \n}  \npublic class Child extends Base{  \n // member methods  \n}  \n\n 如下哪句可以正确地加入子类中？","choices":["\nprivate void fun( int n ){ //...}\n","\nvoid fun ( int n ){ //... }\n","\nprotected void fun ( int n ) { //... }\n","\npublic void fun ( int n ) { //... }\n"],"correct_choice":"\npublic void fun ( int n ) { //... }\n"},{"title":"final、finally和finalize的区别中，下述说法正确的有？","choices":["\nfinal用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。\n","\nfinally是异常处理语句结构的一部分，表示总是执行。\n","\nfinalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。\n","\n引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。\n"],"correct_choice":"\nfinal用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。\n\nfinally是异常处理语句结构的一部分，表示总是执行。\n"},{"title":"Java对象的初始化方式有（      ）","choices":["\n初始化块\n","\n构造器\n","\n定义变量时指定初始化值\n","\n其它各项都不对\n"],"correct_choice":"\n初始化块\n\n构造器\n\n定义变量时指定初始化值\n"},{"title":"以下关于final关键字说法错误的是","choices":["\nfinal是java中的修饰符，可以修饰类、接口、抽象类、方法和属性\n","\nfinal修饰的类肯定不能被继承\n","\nfinal修饰的方法不能被重载\n","\nfinal修饰的变量不允许被再次赋值\n"],"correct_choice":"\nfinal是java中的修饰符，可以修饰类、接口、抽象类、方法和属性\n\nfinal修饰的方法不能被重载\n"},{"title":"下列选项中是正确的方法声明的是？（）","choices":["\nprotected abstract void f1();\n","\npublic final void f1() {}\n","\nstatic final void fq(){}\n","\nprivate void f1() {}\n"],"correct_choice":"\nprotected abstract void f1();\n\npublic final void f1() {}\n\nstatic final void fq(){}\n\nprivate void f1() {}\n"},{"title":"\n\nbyte b1=1,b2=2,b3,b6,b8;\nfinal byte b4=4,b5=6,b7;\nb3=(b1+b2);  /*语句1*/\nb6=b4+b5;    /*语句2*/\nb8=(b1+b4);  /*语句3*/\nb7=(b2+b5);  /*语句4*/\nSystem.out.println(b3+b6);   下列代码片段中，存在编译错误的语句是() ","choices":["\n语句2\n","\n语句1\n","\n语句3\n","\n语句4\n"],"correct_choice":"\n语句1\n\n语句3\n\n语句4\n"},{"title":"欲构造ArrayList类的一个实例，此类实现了List接口，下列哪个方法是正确的？","choices":["\nArrayList myList=new Object（）\n","\nList myList=new ArrayList()\n","\nArrayList myList=new List()\n","\nList myList=new List()\n"],"correct_choice":"\nList myList=new ArrayList()\n"},{"title":"\n  对于以下代码段，4个输出语句中输出true的个数是(    )。\n\n\n  \n    \n      \n          class A{}\n        \n        \n          class B extends   A{}\n        \n        \n          class C extends   A{}\n        \n        \n          class D extends   B{}\n        \n        \n          A obj = new D();\n        \n        \n          System.out.println(obj   instanceof B);\n        \n        \n          System.out.println(obj   instanceof C);\n        \n        \n          System.out.println(obj   instanceof D);\n        \n        \n          System.out.println(obj   instanceof A);\n        \n      \n  \n\n\n  \n","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"  Given the following class: \npublic class Cat\n{\n    long length;\n    public Cat(long l)\n    {\n        length = 1;\n    }\n    public static void main(String arg[])\n    {\n        Cat c1, c2, c3;\n        c1 = new Cat(10L);\n        c2 = new Cat(10L);\n        c3 = c2;\n        long m = 21L;\n    }\n}\n\n\t\n\n\n  Which expression returns true? ","choices":["\nc1==c2;\n","\nc2==c3;\n","\nm==c1;\n","\nc1.equals(m).\n"],"correct_choice":"\nc2==c3;\n"},{"title":"\n  在\n  java\n  中\n  ,\n  一个类（）\n","choices":["\n可以继承多个类\n","\n可以实现多个接口\n","\n在一个程序中只能有一个子类\n","\n只能实现一个接口\n"],"correct_choice":"\n可以实现多个接口\n"},{"title":"Java\n的屏幕坐标是以像素为单位，容器的左下角被确定为坐标的起点。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  要使对象具有序列化能力，则其类应该实现如下哪个接口(    )。\n","choices":["\njava.io.Serializable\n","\njava.lang.Cloneable,\n","\njava.lang.CharSequence\n","\njava.lang.Comparable\n"],"correct_choice":"\njava.io.Serializable\n"},{"title":"  高优先级的线程比低优先级的线程运行得更快。  ","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  下列选项中符合Java命名规则的标识符是（）\n","choices":["\n2japro\n","\n&Class\n","\nconst\n","\n_123\n"],"correct_choice":"\n_123\n"},{"title":"  以下哪个式子有可能在某个进制下成立（）？ ","choices":["\n13*14=204\n","\n12*34=568\n","\n14*14=140\n","\n1+1=3\n"],"correct_choice":"\n13*14=204\n"},{"title":"构造方法用于创建类的实例对象，构造方法名应与类名相同，返回类型为void。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  编译java程序的命令文件是( )\n","choices":["\njava.exe\n","\njavac.exe\n","\napplet.exe\n"],"correct_choice":"\njavac.exe\n"},{"title":"一个以“.java”为后缀的源文件","choices":["\n只能包含一个public类，类名必须与文件名相同\n","\n只能包含与文件名相同的public类以及其中的内部类\n","\n只能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）\n","\n可以包含任意public类\n"],"correct_choice":"\n只能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）\n"},{"title":"在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？","choices":["\nStringBuffer类的对象调用toString（）方法将返回String类型的结果\n","\n两个类都有append（）方法\n","\n可以直接将字符串“test”赋值给声明的String类和StringBuffer类的变量\n","\n两个类的实例的值都能够被改变\n"],"correct_choice":"\nStringBuffer类的对象调用toString（）方法将返回String类型的结果\n"},{"title":"下列说法正确的有（ ）","choices":["\nclass中的constructor不可省略\n","\nconstructor必须与class同名，但方法不能与class同名\n","\nconstructor在一个对象被new时执行\n","\n一个class只能定义一个constructor\n"],"correct_choice":"\nconstructor在一个对象被new时执行\n"},{"title":"public class Test{\n    static int cnt = 6;\n    static{\n        cnt += 9;\n    }\npublic static void main(String[] args）{\n    System.out.println（“cnt =” + cnt);\n}\nstatic{\n    cnt /=3;\n    };\n}\n  cnt的值是 ","choices":["\ncnt=5\n","\ncnt=2\n","\ncnt=3\n","\ncnt=6\n"],"correct_choice":"\ncnt=5\n"},{"title":"  Given: \n\n\t//point X\npublic class Foo {\n    public static void main(String[] args) throws Exception {\n\n        PrintWriter out = new PrintWriter(\n            new java.io.OutputStreamWriter(System.out), true);\n        out.printIn(“Hello”)；\n    }\n}\n\n\n\n  Which statement at PointX on line I allows this code to compile\n  and run? ","choices":["\nimport java.io.PrintWriter;\n","\ninclude java.io.PrintWriter;\n","\nimport java.io.OutputStreamWriter;\n","\ninclude java.io.OutputStreamWriter;\n","\nno statement is needed.\n"],"correct_choice":"\nimport java.io.PrintWriter;\n"},{"title":"子类A继承父类B, A a = new A();\n  则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？","choices":["\n父类Ｂ静态代码块->父类Ｂ构造函数->子类Ａ静态代码块->父类Ｂ非静态代码块->子类Ａ构造函数->子类Ａ非静态代码块\n","\n父类Ｂ静态代码块->父类Ｂ构造函数->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块\n","\n父类Ｂ静态代码块->子类Ａ静态代码块->父类Ｂ非静态代码块->父类Ｂ构造函数->子类Ａ非静态代码块->子类Ａ构造函数\n","\n父类Ｂ构造函数->父类Ｂ静态代码块->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块\n"],"correct_choice":"\n父类Ｂ静态代码块->子类Ａ静态代码块->父类Ｂ非静态代码块->父类Ｂ构造函数->子类Ａ非静态代码块->子类Ａ构造函数\n"},{"title":"以下二维数组声明合法的是（      ）","choices":["\nchar[2][3] ch = new char[][]\n","\nchar[2][] ch = new char[][3]\n","\nchar[][] ch = new char[2][3]\n","\nchar[][] ch = new [2]char[3]\n"],"correct_choice":"\nchar[][] ch = new char[2][3]\n"},{"title":"以下多线程对int型变量x的操作,哪个不需要进行同步()","choices":["\n++x\n","\nx=y\n","\nx++\n","\nx=1\n"],"correct_choice":"\nx=1\n"},{"title":"\n  以下代码运行输出的是\n\npublic class Person{\n\tprivate String name = \"Person\";\n\tint age=0;\n}\npublic class Child extends Person{\n\tpublic String grade;\n\tpublic static void main(String[] args){\n\t\tPerson p = new Child();\n\t\tSystem.out.println(p.name);\n\t}\n}\n\n  \n","choices":["\n输出：Person\n","\n没有输出\n","\n编译出错\n","\n运行出错\n"],"correct_choice":"\n编译出错\n"},{"title":"given the following code,what will be the output?\nclass Value{\n    public int i=15;\n}\npublic class Test{\n    public static void main(String argv[]){\n        Test t=new Test( );\n        t.first( );\n    }\n\npublic void first( ){\n    int i=5;\n    Value v=new Value( );\n    v.i=25;\n    second(v,i);\n    System.out.println(v.i);\n}\n\npublic void second(Value v,int i){\n    i = 0;\n    v.i = 20;\n    Value val = new Value( );\n    v = val;\n    System.out.println(v.i+\" \"+i);\n   }\n}\n\n","choices":["\n15 0 20\n","\n15 0 15\n","\n20 0 20\n","\n0 15 20\n"],"correct_choice":"\n15 0 20\n"},{"title":"下面有关SPRING的事务传播特性，说法错误的是？","choices":["\nPROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行\n","\nPROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常\n","\nPROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起\n","\nPROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚\n"],"correct_choice":"\nPROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常\n"},{"title":"ResultSet中记录行的第一列索引为？","choices":["\n-1\n","\n0\n","\n1\n","\n以上都不是\n"],"correct_choice":"\n1\n"},{"title":"  对于JVM内存配置参数： \n\n     -Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3  \n\n  ,其最小内存值和Survivor区总大小分别是（） ","choices":["\n5120m，1024m\n","\n5120m，2048m\n","\n10240m，1024m\n","\n10240m，2048m\n"],"correct_choice":"\n10240m，2048m\n"},{"title":"单例模式中，两个基本要点（）和单子类自己提供单例","choices":["\n构造函数私有\n","\n静态工厂方法\n","\n以上都不对\n","\n唯一实例\n"],"correct_choice":"\n构造函数私有\n\n唯一实例\n"},{"title":"  下列不是 Java 关键字的是 （  ）  ","choices":["\nabstract\n","\nfalse\n","\nnative\n","\nsizeof\n"],"correct_choice":"\nfalse\n\nsizeof\n"},{"title":"java中 String str = \"hello world\"下列语句错误的是？","choices":["\nstr+='  a'\n","\nint strlen = str.length\n","\nstr=100\n","\nstr=str+100\n"],"correct_choice":"\nstr+='  a'\n\nint strlen = str.length\n\nstr=100\n"},{"title":"\n  如果类的方法没有返回值，该方法的返回类型应是：( )\n","choices":["\nvoid\n","\nnull\n","\nabstract\n","\ndefault\n"],"correct_choice":"\nvoid\n"},{"title":"\n  假设\n  A\n  类有如下定义，设\n  a\n  是\n  A\n  类的一个实例，下列语句调用哪个是错误的？（ ）\n\n\n  class  A{\n\n\n   static  int  i;\n\n\n   String  s;\n\n\n   static  void  method1() {   }\n\n\n   void  method2()  {   }\n\n\n  }\n","choices":["\nSystem.out.println(a.i)；\n","\na.method1();\n","\nA.method1();\n","\nA.method2()\n"],"correct_choice":"\nA.method2()\n"},{"title":"  以下代码执行的结果显示是多少（ ）？  public class Demo { class Super{ int flag=1;\n        Super(){\n            test();\n        } void test(){\n            System.out.println(\"Super.test() flag=\"+flag);\n        }\n    } class Sub extends Super\n    {\n        Sub(int i){ flag=i;\n            System.out.println(\"Sub.Sub()flag=\"+flag);\n        } void test(){\n            System.out.println(\"Sub.test()flag=\"+flag);\n        }\n    } public static void main(String[] args) { new Demo().new Sub(5);\n    }\n   } ","choices":["\nSub.test() flag=1\nSub.Sub() flag=5\n","\nSub.Sub() flag=5\nSub.test() flag=5\n","\nSub.test() flag=0\nSub.Sub() flag=5\n","\nSuper.test() flag=1\nSub.Sub() flag=5\n"],"correct_choice":"\nSub.test() flag=1\nSub.Sub() flag=5\n"},{"title":"\n  在\n  Java\n  中，属于整数类型变量的是（）\n","choices":["\nsingle\n","\ndouble\n","\nbyte\n","\nchar\n"],"correct_choice":"\nbyte\n"},{"title":"  当编译并运行下面程序时会发生什么结果（）   public class Bground extends Thread{\n    public static void main(String argv[]){\n        Bground b = new Bground();\n        b.run();\n    }\n    public void start(){\n        for(int i=0;i<10;i++){\n            System.out.println(\"Value of i = \"+i);\n        }\n    }\n} ","choices":["\n编译错误，指明run方法没有定义\n","\n运行错误，只鞥呢run方法没有定义\n","\n编译通过并输出0到9\n","\n编译通过，但无输出\n"],"correct_choice":"\n编译通过，但无输出\n"},{"title":"\n  以下哪个方法用于定义线程的执行体？\n  （ \n  ）\n","choices":["\nstart()\n","\ninit()\n","\nrun()\n","\nsynchronized()\n"],"correct_choice":"\nrun()\n"},{"title":"对于一个类的构造函数，其函数名与类名(    )。","choices":["\n完全相同\n","\n基本相同\n","\n不相同\n","\n无关系\n"],"correct_choice":"\n完全相同\n"},{"title":"Which is the return type of the method main()?","choices":["\nint\n","\nvoid\n","\nBoolean\n","\nstatic\n"],"correct_choice":"\nvoid\n"},{"title":"对于application，主线程main（）方法执行的线索，对于applet，主线程是浏览器加载并执行java小程序。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  下列选项中\n  ,\n  不属于字符型常量的是（\n  ）\n","choices":["\n’a’\n","\n”C”\n","\n’\\n’\n","\n’\\123’\n"],"correct_choice":"\n”C”\n"},{"title":"  有以下类定义： \nabstract class Animal{\n\tabstract void say();\n}\npublic class Cat extends Animal{\n\tpublic Cat(){\n\t\tSystem.out.printf(\"I am a cat\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tCat cat=new Cat();\n\t}\n}\n  运行后： ","choices":["\nI am a cat\n","\nAnimal能编译，Cat不能编译\n","\nAnimal不能编译，Cat能编译\n","\n编译能通过，但是没有输出结果\n"],"correct_choice":"\nAnimal能编译，Cat不能编译\n"},{"title":"下列哪种说法是正确的（ ）","choices":["\n实例方法可直接调用超类的实例方法\n","\n实例方法可直接调用超类的类方法\n","\n实例方法可直接调用其他类的实例方法\n","\n实例方法可直接调用本类的类方法\n"],"correct_choice":"\n实例方法可直接调用本类的类方法\n"},{"title":"Which method you define as the starting point of new thread in a class\nfrom which n thread can be execution?","choices":["\npublic void start()\n","\npublic void run()\n","\npublic void int()\n","\npublic static void main(String args[])\n","\npublic void runnable()\n"],"correct_choice":"\npublic void run()\n"},{"title":"Which lines of the following will produce an error?\n1. byte a1 = 2, a2 = 4, a3;\n2. short s = 16;\n3. a2 = s;\n4. a3 = a1 * a2; \n\n","choices":["\nLine 3 and Line 4\n","\nLine 1 only\n","\nLine 3 only\n","\nLine 4 only\n"],"correct_choice":"\nLine 3 and Line 4\n"},{"title":"下列哪个说法是正确的（）","choices":["\nConcurrentHashMap使用synchronized关键字保证线程安全\n","\nHashMap实现了Collction接口\n","\nArray.asList方法返回java.util.ArrayList对象\n","\nSimpleDateFormat是线程不安全的\n"],"correct_choice":"\nSimpleDateFormat是线程不安全的\n"},{"title":"  用命令方式运行以下代码的运行结果是（） \npublic class f{\n    public static void main(String[] args){\n        String foo1 = args[1];\n        String foo2 = args[2];\n        String foo3 = args[3];\n    }\n}\n  命令:  java T11 a b c ","choices":["\n程序编译错误\n","\na b c\n","\n程序运行错误\n","\nt11\n"],"correct_choice":"\n程序运行错误\n"},{"title":"以下哪项陈述是正确的？","choices":["\n垃圾回收线程的优先级很高，以保证不再 使用的内存将被及时回收\n","\n垃圾收集允许程序开发者明确指定释放 哪一个对象\n","\n垃圾回收机制保证了JAVA程序不会出现 内存溢出\n","\n进入”Dead”状态的线程将被垃圾回收器回收\n","\n以上都不对\n"],"correct_choice":"\n以上都不对\n"},{"title":"ArrayList list = new ArrayList(20);中的list扩充几次","choices":["\n0\n","\n1\n","\n2\n","\n3\n"],"correct_choice":"\n0\n"},{"title":"下面叙述那个是正确的？（）","choices":["\njava中的集合类（如Vector）可以用来存储任何类型的对象，且大小可以自动调整。但需要事先知道所存储对象的类型，才能正常使用。\n","\n在java中，我们可以用违例（Exception）来抛出一些并非错误的消息，但这样比直接从函数返回一个结果要更大的系统开销。\n","\njava接口包含函数声明和变量声明。\n","\njava中，子类不可以访问父类的私有成员和受保护的成员。\n"],"correct_choice":"\n在java中，我们可以用违例（Exception）来抛出一些并非错误的消息，但这样比直接从函数返回一个结果要更大的系统开销。\n"},{"title":"以下描述正确的是","choices":["\nCallableStatement是PreparedStatement的父接口\n","\nPreparedStatement是CallableStatement的父接口\n","\nCallableStatement是Statement的父接口\n","\nPreparedStatement是Statement的父接口\n"],"correct_choice":"\nPreparedStatement是CallableStatement的父接口\n"},{"title":"package Wangyi;\nclass Base\n{\n    public void method()\n    {\n        System.out.println(\"Base\");\n    } \n}\nclass Son extends Base\n{\n    public void method()\n    {\n        System.out.println(\"Son\");\n    }\n    \n    public void methodB()\n    {\n        System.out.println(\"SonB\");\n    }\n}\npublic class Test01\n{\n    public static void main(String[] args)\n    {\n        Base base = new Son();\n        base.method();\n        base.methodB();\n    }\n}\n  问这个程序的输出结果。\n","choices":["\nBase SonB\n","\nSon SonB\n","\nBase Son SonB\n","\n编译不通过\n"],"correct_choice":"\n编译不通过\n"},{"title":"  对文件名为Test.java的java代码描述正确的是() \nclass Person {\n\tString name = \"No name\";\n\tpublic Person(String nm) {\n\t\tname = nm;\n\t}\n}\nclass Employee extends Person {\n\tString empID = \"0000\";\n\tpublic Employee(String id) {\n\t\tempID = id;\n\t}\n}\npublic class Test {\n\tpublic static void main(String args[]) {\n\t\tEmployee e = new Employee(\"123\");\n\t\tSystem.out.println(e.empID);\n\t}\n}","choices":["\n输出：0000\n","\n输出：123\n","\n编译报错\n","\n输出：No name\n"],"correct_choice":"\n编译报错\n"},{"title":"常用的servlet包的名称是？","choices":["\njava.servlet\n","\njavax.servlet\n","\nservlet.http\n","\njavax.servlet.http\n"],"correct_choice":"\njavax.servlet\n\njavax.servlet.http\n"},{"title":"String str = new String(“abc”)，“abc”在内存中是怎么分配的？","choices":["\n堆\n","\n栈\n","\n字符串常量区\n","\n寄存器\n"],"correct_choice":"\n堆\n\n字符串常量区\n"},{"title":"下述有关c++的虚类和java接口的描述，说法错误的是？","choices":["\nc++虚类相当与java里面的抽象类\n","\nc++中没有接口的概念，与之对应的是纯虚类，对应的是java的接口\n","\n纯虚函数和虚函数的区别在于前者只包含定义，而后者还可以包含函数体。\n","\n一个抽象类和接口中的方法必须是抽象方法\n"],"correct_choice":"\n纯虚函数和虚函数的区别在于前者只包含定义，而后者还可以包含函数体。\n\n一个抽象类和接口中的方法必须是抽象方法\n"},{"title":"\n  字符界面下接受用户从键盘输入，需要import的包是：（ \n   ）\n\n\n  \n","choices":["\njava.lang包\n","\njava.awt包\n","\njava.io包\n","\njava.applet包\n"],"correct_choice":"\njava.io包\n"},{"title":"\n  对接口的描述正确的是()\n","choices":["\n一个类可以实现多个接口\n","\n接口可以有非静态的成员变量\n","\n接口可以实现方法\n","\n实现接口的任何类，都需要实现接口的方法\n"],"correct_choice":"\n一个类可以实现多个接口\n"},{"title":"对于非运行时异常，程序中一般可不做处理，由java虚拟机自动进行处理。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  关于抽象类的叙述正确的是？(   )      ","choices":["\n抽象类不可以实例化\n","\n抽象类就是一种特殊的接口\n","\n抽象类的方法都是抽象方法\n","\n抽象类的导出类一定不是抽象类\n"],"correct_choice":"\n抽象类不可以实例化\n"},{"title":"HashSet子类依靠()方法区分重复元素。","choices":["\ntoString(),equals()\n","\nclone(),equals()\n","\nhashCode(),equals()\n","\ngetClass(),clone()\n"],"correct_choice":"\nhashCode(),equals()\n"},{"title":"  设 Tree 为已定义的类名，下列语句能正确创建 Tree 对象的是    。  ","choices":["\nTree t=new Tree;\n","\nTree t=new Tree();\n","\nTree t=Tree();\n","\nTree t[ ]=new Tree[10];\n"],"correct_choice":"\nTree t=new Tree();\n"},{"title":"  socket编程中，以下哪个socket的操作是不属于服务端操作的（）？ ","choices":["\naccept\n","\nlisten\n","\nconnect\n","\nclose\n"],"correct_choice":"\nconnect\n"},{"title":"\n  关于Java语言描述正确的是？  ( \n   )\n\n\n  \n","choices":["\njava和C++都保留了指针\n","\njava和C++都有三个特征：封装、继承和多态\n","\njava的垃圾回收机制是指程序结束时系统自动回收内存\n","\n以上说法都不正确\n"],"correct_choice":"\njava和C++都有三个特征：封装、继承和多态\n"},{"title":"\n  关于下面代码\n  int[] x=new int[25];\n   描述正确的是（）\n\n","choices":["\nx[25]存放了数据“\\0”。\n","\nx[24] 存放了数据“\\0”。\n","\n若访问x[25]，程序将抛出异常。\n","\nx[1]访问此数组的第一个元素。\n"],"correct_choice":"\n若访问x[25]，程序将抛出异常。\n"},{"title":"\n  在\n  java\n  中，一个类可同时定义为许多同名的方法，这些方法的形式参数个数，类型或顺序各不相同，传回的值可能个不相同，这种面向对象的特性称为（）\n","choices":["\n隐藏\n","\n覆盖\n","\n重载\n","\n无此特性\n"],"correct_choice":"\n重载\n"},{"title":"\n  下列关于Java语言中String和char的说法，正确的是（）\n","choices":["\nString是Java定义的一种基本数据类型。\n","\nString是以“\\0”结尾的char类型的数组char[]。\n","\n使用equals()方法比较两个String是否内容一样（即字符串中的各个字符都一样）。\n","\nChar类型在Java语言里面存储的是ASCII码。\n"],"correct_choice":"\n使用equals()方法比较两个String是否内容一样（即字符串中的各个字符都一样）。\n"},{"title":"\n  以下对选择语句描述错误的是(）\n","choices":["\n根据某一条件重复执行一部分代码直到满足终止条件为止\n","\n可以根据条件控制程序流程，改变程序执行的顺序\n","\n选择语句可以嵌套使用\n","\n当条件满足时就会执行相应的语句\n"],"correct_choice":"\n根据某一条件重复执行一部分代码直到满足终止条件为止\n"},{"title":"  关于以下程序段，正确的说法是：（） \nString s1=\"abc\"+\"def\";//1\nString s2=new String（s1);//2\nif(s1.equals(s2))//3\nSystem.out.println(\".equals succeeded\");//4\nif(s1==s2)//5\nSystem.out.println(\"==succeeded\");//6","choices":["\n行4，行6都不执行\n","\n行6执行，行4不执行\n","\n行4执行，行6不执行\n","\n行4，行6都将执行\n"],"correct_choice":"\n行4执行，行6不执行\n"},{"title":"代码System. out. println(10 % 3 * 2)；将打印出？","choices":["\n1\n","\n2\n","\n4\n","\n6\n"],"correct_choice":"\n2\n"},{"title":"假设有以下代码 \nString s=”hello”;\nString t=”hello”;\nChar c[] ={‘h’,’e’,’l’,’l’,’o’}; \n 下列选项中返回false的语句是：","choices":["\ns.equals(t);\n","\nt.equals(c);\n","\ns==t;\n","\nt.equals(new String(“hello”));\n"],"correct_choice":"\nt.equals(c);\n"},{"title":"public class Test\n {\n     static boolean foo(char c)\n     {\n         System.out.print(c);\n         return true;\n     }\n     public static void main( String[] argv )\n     {\n         int i = 0;\n         for ( foo('A'); foo('B') && (i < 2); foo('C'))\n         {\n             i++ ;\n             foo('D');\n         }\n     }\n }\n  What is the result? \n\n  \n","choices":["\nABDCBDCB\n","\nABCDABCD\n","\nCompilation fails.\n","\nAn exception is thrown at runtime.\n"],"correct_choice":"\nABDCBDCB\n"},{"title":"Which keyword can protect a class in a package from accessibility by the\nclasses outside the package but not package inside ?","choices":["\nprivate\n","\nprotected\n","\nfinal\n","\ndon't use any keyword at all (make it default) ？\n"],"correct_choice":"\ndon't use any keyword at all (make it default) ？\n"},{"title":"执行如下程序，输出结果是（      ）\nclass Test\n{\n     private int data;\n     int result = 0;\n     public void m()\n     {\n         result += 2;\n         data += 2;\n         System.out.print(result + \"  \" + data);\n     }\n }\n class ThreadExample extends Thread\n {\n     private Test mv;\n     public ThreadExample(Test mv)\n     {\n         this.mv = mv;\n     }\n     public void run()\n     {\n         synchronized(mv)\n         {\n             mv.m();\n         }\n     }\n }\n class ThreadTest\n {\n     public static void main(String args[])\n     {\n         Test mv = new Test();\n         Thread t1 = new ThreadExample(mv);\n         Thread t2 = new ThreadExample(mv);\n         Thread t3 = new ThreadExample(mv);\n         t1.start();\n         t2.start();\n         t3.start();\n     }\n }","choices":["\n0 22 44 6\n","\n2 42 42 4\n","\n2 24 46 6\n","\n4 44 46 6\n"],"correct_choice":"\n2 24 46 6\n"},{"title":"下列语句正确的是：","choices":["\n形式参数可被字段修饰符修饰\n","\n形式参数不可以是对象\n","\n形式参数为方法被调用时真正被传递的参数\n","\n形式参数可被视为local variable\n"],"correct_choice":"\n形式参数可被视为local variable\n"},{"title":"下列程序的运行结果\npublic void getCustomerInfo() {\n        try {\n            // do something that may cause an Exception\n        } catch (java.io.FileNotFoundException ex) {\n            System.out.print(\"FileNotFoundException!\");\n        } catch (java.io.IOException ex) {\n            System.out.print(\"IOException!\");\n        } catch (java.lang.Exception ex) {\n            System.out.print(\"Exception!\");\n        }\n    }\n","choices":["\nIOException!\n","\nIOException!Exception!\n","\nFileNotFoundException!IOException!\n","\nFileNotFoundException!IOException!Exception!\n"],"correct_choice":"\nIOException!\n"},{"title":"JSP\n表达式的写法：","choices":["\n<% expression %>\n","\n<=% expression %>\n","\n<%= expression %>\n","\n<expression/>\n"],"correct_choice":"\n<%= expression %>\n"},{"title":"Why would a responsible Java programmer want to use a nested class?","choices":["\nTo keep the code for a very specialized class in close association with the class it works with.\n","\nTo support a new user interface that generates custom events.\n","\nTo impress the boss with his/her knowledge of Java by using nested classes all over the place.\n"],"correct_choice":"\nTo keep the code for a very specialized class in close association with the class it works with.\n\nTo support a new user interface that generates custom events.\n"},{"title":"关于ThreadLocal类\n 以下说法正确的是","choices":["\nThreadLocal继承自Thread\n","\nThreadLocal实现了Runnable接口\n","\nThreadLocal重要作用在于多线程间的数据共享\n","\nThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本\n","\nThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏\n"],"correct_choice":"\nThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本\n\nThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏\n"},{"title":"下面有关forward和redirect的描述，正确的是()\n？","choices":["\nforward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求\n","\n执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址\n","\n执行redirect时，服务器端告诉浏览器重新去请求地址\n","\nforward是内部重定向，redirect是外部重定向\n","\nredirect默认将产生301 Permanently moved的HTTP响应\n"],"correct_choice":"\n执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址\n\n执行redirect时，服务器端告诉浏览器重新去请求地址\n\nforward是内部重定向，redirect是外部重定向\n"},{"title":"\n  对于如下代码段\n\n\n  \n    \n      \n          class A{\n        \n        \n              public A foo(){return this;}\n        \n        \n          }\n        \n        \n          class B extends A{\n        \n        \n              public A foo(){\n        \n        \n                  return this;\n        \n        \n              }\n        \n        \n          }\n        \n        \n          class C extends B\n        \n        \n          {\n        \n        \n              _______\n          \n        \n        \n          \n          \n        \n        \n          }\n        \n      \n  \n\n\n   可以放入到横线位置，使程序正确编译运行，而且不产生错误的选项是（ ）\n","choices":["\npublic void foo(){}\n","\npublic int foo(){return 1;}\n","\npublic A foo(B b){return b;}\n","\npublic A foo(){return A;}\n"],"correct_choice":"\npublic A foo(B b){return b;}\n"},{"title":"Continue语句跳出整个循环.","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  类Cat里面有个公有方法sleep()，该方法前有static修饰，则可以直接用Cat.sleep()。（\n   ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"下面有关JDK中的包和他们的基本功能，描述错误的是？","choices":["\njava.awt： 包含构成抽象窗口工具集的多个类，用来构建和管理应用程序的图形用户界面\n","\njava.io：　 包含提供多种输出输入功能的类\n","\njava.lang： 包含执行与网络有关的类，如URL，SCOKET，SEVERSOCKET\n","\njava.util：　 包含一些实用性的类\n"],"correct_choice":"\njava.lang： 包含执行与网络有关的类，如URL，SCOKET，SEVERSOCKET\n"},{"title":"\n  有一个源代码，只包含import java.util.*\n  ;\n  这一个import语句，下面叙述正确的是？   ( \n   )\n\n\n  \n","choices":["\n只能写在源代码的第一句\n","\n可以访问java/util目录下及其子目录下的所有类\n","\n能访问java/util目录下的所有类，不能访问java/util子目录下的所有类\n","\n编译错误\n"],"correct_choice":"\n能访问java/util目录下的所有类，不能访问java/util子目录下的所有类\n"},{"title":"\n  对于子类的构造函数说明，下列叙述中错误的是（ ）。\n","choices":["\n子类不能继承父类的无参构造函数。\n","\n子类可以在自己的构造函数中使用super关键字来调用父类的含参数构造函数，但这个调用语句必须是子类构造函数的第一个可执行语句。\n","\n在创建子类的对象时，若不含带参构造函数，将先执行父类的无参构造函数，然后再执行自己的无参构造函数。\n","\n子类不但可以继承父类的无参构造函数，也可以继承父类的有参构造函数。\n"],"correct_choice":"\n子类不但可以继承父类的无参构造函数，也可以继承父类的有参构造函数。\n"},{"title":"\n  设A为已知定义的类名，下列声明A类的对象a的语句( )\n","choices":["\nfloat  A  a\n","\npublic  a=A（）\n","\nA a=new  int ()\n","\nA  a=new  A()\n"],"correct_choice":"\nA  a=new  A()\n"},{"title":"\n  final方法等同于private方法。（  ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"java socket如何获取本地ip地址？","choices":["\ngetInetAddress()\n","\ngetLocalAddress()\n","\ngetReuseAddress()\n","\ngetLocalPort()\n"],"correct_choice":"\ngetLocalAddress()\n"},{"title":"系统在调用重载函数时，能作为确定哪个重载函数被调用的依据是（）","choices":["\n函数返回类型\n","\n参数个数\n","\n函数名称\n","\n参数名称\n"],"correct_choice":"\n参数个数\n"},{"title":"TextField\n的事件监听器接口是（）","choices":["\nActionListener\n","\nChangeListener\n","\nItemListener\n","\nWindowListener\n"],"correct_choice":"\nActionListener\n"},{"title":"一般用()创建InputStream对象,表示从标准输入中获取数据,用()创建OutputStream对象，表示输出到标准输出设备中。","choices":["\nSystem.in System.out\n","\nSystem.out System.in\n","\nSystem.io.in System.io.out\n","\nSystem.io.out System.io.in\n"],"correct_choice":"\nSystem.in System.out\n"},{"title":"关于中间件特点的描述.不正确的是（）","choices":["\n中间件运行于客户机/服务器的操作系统内核中，提高内核运行效率\n","\n中间件应支持标准的协议和接口\n","\n中间件可运行于多种硬件和操作系统平台上\n","\n跨越网络,硬件，操作系统平台的应用或服务可通过中间件透明交互\n"],"correct_choice":"\n中间件运行于客户机/服务器的操作系统内核中，提高内核运行效率\n"},{"title":"下列哪一项的实现不可以添加为\nTextField\n对象的监听器（）","choices":["\nMouseMotionListener\n","\nFocusListener\n","\nWindowsListener\n","\nActionListener\n"],"correct_choice":"\nWindowsListener\n"},{"title":"下面有关JVM内存，说法错误的是？","choices":["\n程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的\n","\nJava方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的\n","\n方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的\n","\n原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的\n"],"correct_choice":"\n方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的\n"},{"title":"  下面代码将输出什么内容：（）   public class SystemUtil{\n    public static boolean isAdmin(String userId){\n        return userId.toLowerCase()==\"admin\";\n    }\n    public static void main(String[] args){\n        System.out.println(isAdmin(\"Admin\"));\n    }\n}     ","choices":["\ntrue\n","\nfalse\n","\n1\n","\n编译错误\n"],"correct_choice":"\nfalse\n"},{"title":"变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？","choices":["\n1\n","\n-1\n","\n2^63+2^62+…+2^2+2^1+2^0\n","\n–(2^63+2^62+…+2^2+2^1+2^0)\n"],"correct_choice":"\n-1\n"},{"title":"What will happen when you attempt to compile and run the following code?\npublic class Test{\nstatic{\n   int x=5;\n}\nstatic int x,y;\npublic static void main(String args[]){\n   x--;\n   myMethod( );\n   System.out.println(x+y+ ++x);\n}\npublic static void myMethod( ){\n  y=x++ + ++x;\n }\n}\n\n","choices":["\ncompiletime error\n","\nprints:1\n","\nprints:2\n","\nprints:3\n","\nprints:7\n","\nprints:8\n"],"correct_choice":"\nprints:3\n"},{"title":"如果希望监听TCP端口9000，应该怎样创建socket?","choices":["\nnew Socket(\"localhost\",9000);\n","\nnew ServerSocket(9000);\n","\nnew Socket(9000);\n","\nnew ServerSocket(\"localhost\",9000);\n"],"correct_choice":"\nnew ServerSocket(9000);\n"},{"title":"以下代码的输出结果是？ public class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n\n","choices":["\n静态块 构造块 构造块 构造块\n","\n构造块 静态块 构造块 构造块\n","\n构造块 构造块 静态块 构造块\n","\n构造块 构造块 构造块 静态块\n"],"correct_choice":"\n构造块 构造块 静态块 构造块\n"},{"title":"下面哪些类实现或者继承了Collection接口？","choices":["\nHashMap\n","\nArrayList\n","\nVector\n","\nIterator\n"],"correct_choice":"\nArrayList\n\nVector\n"},{"title":"在java语言中，如果你编写一个多线程序，可以使用的方法是（）","choices":["\n扩展类Thread\n","\n实现Runnable接口\n","\n扩展类 Runnable\n","\n实现接口Thread\n"],"correct_choice":"\n扩展类Thread\n\n实现Runnable接口\n"},{"title":"Java多线程有几种实现方法？","choices":["\n继承Thread类\n","\n实现Runnable接口\n","\n实现Thread接口\n","\n以上都不正确\n"],"correct_choice":"\n继承Thread类\n\n实现Runnable接口\n"},{"title":"class A {}\n  class B extends A {}\n  class C extends A {}\n  class D extends B {}\n  Which four statements are true ?","choices":["\nThe type List<A>is assignable to List.\n","\nThe type List<B>is assignable to List<A>.\n","\nThe type List<Object>is assignable to List<?>.\n","\nThe type List<D>is assignable to List<?extends B>.\n","\nThe type List<?extends A>is assignable to List<A>.\n","\nThe type List<Object>is assignable to any List reference.\n","\nThe type List<?extends B>is assignable to List<?extends A>.\n"],"correct_choice":"\nThe type List<A>is assignable to List.\n\nThe type List<Object>is assignable to List<?>.\n\nThe type List<D>is assignable to List<?extends B>.\n\nThe type List<?extends B>is assignable to List<?extends A>.\n"},{"title":"  关于JAVA堆，下面说法错误的是（）？ ","choices":["\n所有类的实例和数组都是在堆上分配内存的\n","\n堆内存由存活和死亡的对象，空闲碎片区组成\n","\n数组是分配在栈中的\n","\n对象所占的堆内存是由自动内存管理系统回收\n"],"correct_choice":"\n数组是分配在栈中的\n"},{"title":"\n  假设\n  A\n  类有如下定义，设\n  a\n  是\n  A\n  类同一个包下的一个实例，下列语句调用哪个是错误的？（）\n\n\n  class\n  A{\n\n\n   int  i;\n\n\n   static  String  s;\n\n\n   void  method1() {   }\n\n\n   static  void  method2()  {   }\n\n\n  }\n","choices":["\nSystem.out.println(a.i)；\n","\na.method1();\n","\nA.method1();\n","\nA.method2()\n"],"correct_choice":"\nA.method1();\n"},{"title":"\n  静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ ）\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  导出类调用基类的构造器必须用到的关键字：\n  ( \n   )\n\n\n  \n","choices":["\nthis\n","\nfinal\n","\nsuper\n","\nstatic\n"],"correct_choice":"\nsuper\n"},{"title":"  以下选项中，合法的赋值语句是（）  ","choices":["\na>1;\n","\ni++;\n","\na= a+1=5;\n","\ny = int ( i );\n"],"correct_choice":"\ni++;\n"},{"title":"下列运算符合法的是（ ）","choices":["\n&&\n","\n<>\n","\nif\n","\n:=\n"],"correct_choice":"\n&&\n"},{"title":"\n  执行完以下代码\n  int [ ]  x = new int[10]\n  ；后，以下哪项说明是正确的（\n  ）\n","choices":["\nx[9]为0\n","\nx[9]未定义\n","\nx[10]为0\n","\nx[0]为空\n"],"correct_choice":"\nx[9]为0\n"},{"title":"\n  以下关于\n  abstract\n  关键字的说法，正确的是（）\n","choices":["\nabstract 可以与final 并列修饰同一个类。\n","\nabstract 类中不可以有private的成员。\n","\nabstract 类中必须全部是abstract方法。\n","\nabstract 方法必须在abstract类或接口中。\n"],"correct_choice":"\nabstract 方法必须在abstract类或接口中。\n"},{"title":"为了使包ch4在当前程序中可见，可以使用的语句是（）","choices":["\nimport ch4.*;\n","\npackage ch4.*;\n","\nch4 import;\n","\nch4 package;\n"],"correct_choice":"\nimport ch4.*;\n"},{"title":"  A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：  A a0=new A();\nA a1=new B();\nA a2=new C();   以下哪个说法是正确的？ ","choices":["\n第1行，第2行和第3行的声明都是正确的\n","\n第1,2,3行都能通过编译，但第2,3行运行时出错\n","\n第1,2行能通过编译，但第3行编译出错\n","\n只有第1行能通过编译\n"],"correct_choice":"\n第1行，第2行和第3行的声明都是正确的\n"},{"title":"  以下java程序代码，执行后的结果是（） \npublic class Test {\t\n    public static void main(String[] args) {\t\n        Object o = new Object() {\t\n             public boolean equals(Object obj) {\t\n                 return true;\t\n         }\t\n     };\t\n     System.out.println(o.equals(\"Fred\"));\n     }\n}","choices":["\nFred\n","\ntrue\n","\n编译错误\n","\n运行时抛出异常\n"],"correct_choice":"\ntrue\n"},{"title":"多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为\n()","choices":["\n同步\n","\n异步\n","\n只读\n","\n只写\n"],"correct_choice":"\n同步\n"},{"title":"一个以\". java\"为后缀的源文件，哪些说法是正确的？","choices":["\n只能包含一个类，类名必须与文件名相同\n","\n只能包含与文件名相同的类，以及其中的内部类\n","\n只能有一个与文件名相同的类，可以包含其他类\n","\n可以包含任意类\n"],"correct_choice":"\n只能有一个与文件名相同的类，可以包含其他类\n"},{"title":"\n  A\n  派生出子类\n  B\n  ，\n  B\n  派生出子类\n  C\n  ，并且在\n  java\n  源代码有如下声明：\n\n\n  1. \n  A a0=new A();\n\n\n  2. \n  A a1=new B();\n\n\n  3. \n  A a2=new C();\n\n\n  问以下哪个说法是正确的？（）\n","choices":["\n只有第一行能通过编译\n","\n第1、2行能通过编译，但第3行编译出错\n","\n第1、2、3行能通过编译，但第2、3行运行时出错\n","\n第1行，第2行和第3行的声明都是正确的\n"],"correct_choice":"\n第1行，第2行和第3行的声明都是正确的\n"},{"title":"以下代码将打印出 \tpublic static void main(String args[]) {\n\t\t  List  Listlist1 = new ArrayList();\n\t\t  Listlist1.add(0);\n\t\t  List Listlist2 = Listlist1;\n\t\t    System.out.println(Listlist1.get(0) instanceof Integer);\n\t\t    System.out.println(Listlist2.get(0) instanceof Integer);\n\t}","choices":["\n编译错误\n","\ntrue true\n","\ntrue false\n","\nfalse false\n"],"correct_choice":"\ntrue true\n"},{"title":"\n  关于下列程序段的输出结果，说法正确的是：（\n  ）\n  \n     public class MyClass{\n\n static int i; public static void main(String   argv[]){\n  System.out.println(i); } }\n  \n","choices":["\n有错误，变量i没有初始化。\n","\nnull\n","\n1\n","\n0\n"],"correct_choice":"\n0\n"},{"title":"以下代码执行后输出结果为（      ）\npublic class ClassTest{\n     String str = new String(\"hello\");\n     char[] ch = {'a','b','c'};\n     public void fun(String str, char ch[]){\n     str=\"world\";\n     ch[0]='d';\n }\n public static void main(String[] args) {\n     ClassTest test1 = new ClassTest();\n     test1.fun(test1.str,test1.ch);\n     System.out.print(test1.str + \" and \");\n     System.out.print(test1.ch);\n     }\n }","choices":["\nhello and dbc\n","\nworld and abc\n","\nhello and abc\n","\nworld and dbc\n"],"correct_choice":"\nhello and dbc\n"},{"title":"关于sleep()和wait()，以下描述错误的一项是（ ）","choices":["\nsleep是线程类（Thread）的方法，wait是Object类的方法；\n","\nsleep不释放对象锁，wait放弃对象锁\n","\nsleep暂停线程、但监控状态仍然保持，结束后会自动恢复\n","\nwait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态\n"],"correct_choice":"\nwait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态\n"},{"title":"Math.floor(-8.5)=( )","choices":["\n(float)-8.0\n","\n(long)-9\n","\n(long)-8\n","\n(double)-9.0\n"],"correct_choice":"\n(double)-9.0\n"},{"title":"  下列Java代码中的变量a、b、c分别在内存的____存储区存放。 \nclass A {\n    private String a = “aa”;\n    public boolean methodB() {\n        String b = “bb”;\n        final String c = “cc”;\n    }\n}","choices":["\n堆区、堆区、堆区\n","\n堆区、栈区、堆区\n","\n堆区、栈区、栈区\n","\n堆区、堆区、栈区\n","\n静态区、栈区、堆区\n","\n静态区、栈区、栈区\n"],"correct_choice":"\n堆区、栈区、栈区\n"},{"title":"以下哪项不属于java类加载过程？","choices":["\n生成java.lang.Class对象\n","\nint类型对象成员变量赋予默认值\n","\n执行static块代码\n","\n类方法解析\n"],"correct_choice":"\nint类型对象成员变量赋予默认值\n"},{"title":"对重载函数形象的描述中，正确的是（）","choices":["\n参数的类型可能不同\n","\n参数的顺序可能不同\n","\n函数的返回值类型可能不同\n","\n参数的个数可能不同\n"],"correct_choice":"\n参数的类型可能不同\n\n参数的顺序可能不同\n\n函数的返回值类型可能不同\n\n参数的个数可能不同\n"},{"title":"  以下关于JAVA语言异常处理描述正确的有？ ","choices":["\nthrow关键字可以在方法上声明该方法要抛出的异常。\n","\nthrows用于抛出异常对象。\n","\ntry是用于检测被包住的语句块是否出现异常，如果有异常，则捕获异常，并执行catch语句。\n","\nfinally语句块是不管有没有出现异常都要执行的内容。\n","\n在try块中不可以抛出异常\n"],"correct_choice":"\ntry是用于检测被包住的语句块是否出现异常，如果有异常，则捕获异常，并执行catch语句。\n\nfinally语句块是不管有没有出现异常都要执行的内容。\n"},{"title":"程序文件名必须与公共外部类的名称完全一致（包括大小写）.","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"Java的跨平台特性是指它的源代码可以在多个平台运行。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  关于\n  Socket\n  通信编程，以下描述错误的是：（ ）\n","choices":["\n服务器端通过new ServerSocket()创建TCP连接对象\n","\n服务器端通过TCP连接对象调用accept()方法创建通信的Socket对象\n","\n客户端通过new Socket()方法创建通信的Socket对象\n","\n客户端通过new ServerSocket()创建TCP连接对象\n"],"correct_choice":"\n客户端通过new ServerSocket()创建TCP连接对象\n"},{"title":"\n  关于容器下面说法正确的是？ ( \n   )\n\n\n  \n","choices":["\n列表(List)和集合(Set)存放的元素都是可重复的。\n","\n列表(List)和集合(Set)存放的元素都是不可重复的。\n","\n映射(Map)<key,value>中key是可以重复的。\n","\n映射(Map)<key,value>中value是可以重复的。\n"],"correct_choice":"\n映射(Map)<key,value>中value是可以重复的。\n"},{"title":"\n  下列关于包（package）的描述，正确的是（）\n","choices":["\n包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。\n","\nimport语句将所对应的Java源文件拷贝到此处执行。\n","\n包（package）是Eclipse组织Java项目特有的一种方式。\n","\n定义在同一个包（package）内的类可以不经过import而直接相互使用。\n"],"correct_choice":"\n定义在同一个包（package）内的类可以不经过import而直接相互使用。\n"},{"title":"\n  接口不能扩展（继承）多个接口。（ ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"this代表了()的对象引用,super表示的是当前对象的()对象?","choices":["\n当前类 当前类\n","\n当前类的父类 当前类\n","\n当前类  当前类的父类\n","\n以上都不正确\n"],"correct_choice":"\n当前类  当前类的父类\n"},{"title":"下列属于容器的组件有（）","choices":["\nJButton\n","\nJPanel\n","\nThread\n","\nJTextArea\n"],"correct_choice":"\nJPanel\n"},{"title":"下列关于继承的哪项叙述是正确的？  ","choices":["\n在java中类允许多继承\n","\n在java中一个类只能实现一个接口\n","\n在java中一个类不能同时继承一个类和实现一个接口\n","\njava的单一继承使代码更可靠\n"],"correct_choice":"\njava的单一继承使代码更可靠\n"},{"title":"下列关于构造函数的描述中，错误的是（）","choices":["\n构造函数可以设置默认的参数\n","\n构造函数在定义类对象时自动执行\n","\n构造函数可以是内联函数\n","\n构造函数不可以重载\n"],"correct_choice":"\n构造函数不可以重载\n"},{"title":"如何跳出Array的forEach循环？（ ）\n","choices":["\nbreak\n","\nreturn true\n","\nreturn false\n","\n以上都不是\n"],"correct_choice":"\nbreak\n"},{"title":"Web程序中，当前用户上下文信息应该保存在下面哪个对象中（）\n","choices":["\npage\n","\nrequest\n","\nsession\n","\nApplication\n"],"correct_choice":"\nsession\n"},{"title":"下列哪个对访问修饰符作用范围由大到小排列是正确的？","choices":["\nprivate>default>protected>public\n","\npublic>default>protected>private\n","\nprivate>protected>default>public\n","\npublic>protected>default>private\n"],"correct_choice":"\npublic>protected>default>private\n"},{"title":"Which of the following can be applied to constructors:","choices":["\nfinal\n","\nstatic\n","\nsynchronized\n","\nnative\n","\nNone of these.\n"],"correct_choice":"\nNone of these.\n"},{"title":"  有如下一段程序：  public class Test{ \n    private static int i=1;\n    public int getNext(){ \n         return i++;\n    } \n    public static void main(String [] args){ \n        Test test=new Test(); \n        Test testObject=new Test(); \n        test.getNext(); \n        testObject.getNext(); \n        System.out.println(testObject.getNext()); \n    } \n}   请问最后打印出来的是什么？（） ","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"\n  （）是方法定义和常量值的集合。\n","choices":["\n接口\n","\n变量\n","\n单元\n","\n成员\n"],"correct_choice":"\n接口\n"},{"title":"java Thread中，run方法和start方法的区别，下面说法错误的是？","choices":["\n通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。\n","\n他们都可以实现了多线程运行。\n","\nrun方法是thread的一个普通方法调用。\n","\n调用start方法后，一旦得到cpu时间片，就开始执行run()方法。\n"],"correct_choice":"\n他们都可以实现了多线程运行。\n"},{"title":"下面有关struts1和struts2的区别，描述错误的是？","choices":["\nStruts1要求Action类继承一个抽象基类。Struts 2 Action类可以实现一个Action接口\n","\nStruts1 Action对象为每一个请求产生一个实例。Struts2 Action是单例模式并且必须是线程安全的\n","\nStruts1 Action 依赖于Servlet API，Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试\n","\nStruts1 整合了JSTL，Struts2可以使用JSTL，但是也支持OGNL\n"],"correct_choice":"\nStruts1 Action对象为每一个请求产生一个实例。Struts2 Action是单例模式并且必须是线程安全的\n"},{"title":"下列哪项不属于jdk1.6垃圾收集器？","choices":["\nSerial收集器\n","\nparNew收集器\n","\nCMS收集器\n","\nG1收集器\n"],"correct_choice":"\nG1收集器\n"},{"title":"在Struts框架中如果要使用Validation作验证的话，需要使用以下哪个Form？","choices":["\nActionForm\n","\nValidatorActionForm\n","\nValidatorForm\n","\nDynaValidatorActionForm\n"],"correct_choice":"\nDynaValidatorActionForm\n"},{"title":"在Java中，HashMap中是用哪些方法来解决哈希冲突的？","choices":["\n开放地址法\n","\n二次哈希法\n","\n链地址法\n","\n建立一个公共溢出区\n"],"correct_choice":"\n链地址法\n"},{"title":"  有以下程序段， 则下面正确的选项是（）   public class MyThead extends Thread{\n\tpublic static void main(String[] args) {\n\t\tMyThead t=new MyThead();\n\t\tMyThead s=new MyThead();\n\t\tt.start();\n\t\tSystem.out.println(\"one.\");\n\t\ts.start();\n\t\tSystem.out.println(\"two.\");\n\t}\n\tpublic void run() {\n\t\tSystem.out.println(\"Thread\");\n\t}\n} ","choices":["\n编译失败\n","\n程序运行可能结果为：\none.\nThread\ntwo.\nThread\n","\n程序运行可能结果是：\none.\ntwo.\nThread\nThread\n","\n程序运行结果不稳定\n"],"correct_choice":"\n程序运行可能结果为：\none.\nThread\ntwo.\nThread\n\n程序运行可能结果是：\none.\ntwo.\nThread\nThread\n\n程序运行结果不稳定\n"},{"title":"以下关于对象序列化描述正确的是","choices":["\n使用FileOutputStream可以将对象进行传输\n","\n使用PrintWriter可以将对象进行传输\n","\n使用transient修饰的变量不会被序列化\n","\n对象序列化的所属类需要实现Serializable接口\n"],"correct_choice":"\n使用transient修饰的变量不会被序列化\n\n对象序列化的所属类需要实现Serializable接口\n"},{"title":"String与StringBuffer的区别。","choices":["\nString是不可变的对象，StringBuffer是可以再编辑的\n","\n字符串是常量，StringBuffer是变量\n","\nString是可变的对象，StringBuffer是不可以再编辑的\n","\n以上说法都不正确\n"],"correct_choice":"\nString是不可变的对象，StringBuffer是可以再编辑的\n\n字符串是常量，StringBuffer是变量\n"},{"title":"下面有关java threadlocal说法正确的有？","choices":["\nThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递\n","\n线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收\n","\n在Thread类中有一个Map，用于存储每一个线程的变量的副本。\n","\n对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式\n"],"correct_choice":"\nThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递\n\n线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收\n\n在Thread类中有一个Map，用于存储每一个线程的变量的副本。\n\n对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式\n"},{"title":"\n  关于数据库连接的程序，以下哪个语句的注释是错误的（ ）\n","choices":["\nClass.forName(“sun.jdbc.odbc.JdbcOdbcDriver”); //指定MySQL JDBC驱动程序\n","\nString url=”jdbc:odbc:student_access”;  //指定数据源为student_access\n","\nConnection con=DriverManager.getConnection(url); //创建连接指定数据库的对象\n","\nStatement stmt=con.creatStatement();//创建执行SQL语句的Statement对象\n"],"correct_choice":"\nClass.forName(“sun.jdbc.odbc.JdbcOdbcDriver”); //指定MySQL JDBC驱动程序\n"},{"title":"\n  要使对象具有序列化能力，则其类应该实现如下哪个接口()。\n","choices":["\njava.io.Serializable\n","\njava.lang.Cloneable,\n","\njava.lang.CharSequence\n","\njava.lang.Comparable\n"],"correct_choice":"\njava.io.Serializable\n"},{"title":"\n  DBMS\n  中实现事务持久性的子系统是()\n","choices":["\n安全性管理子系统\n","\n完整性管理子系统\n","\n并发控制子系统\n","\n恢复管理子系统\n"],"correct_choice":"\n恢复管理子系统\n"},{"title":"  定义类中成员变量时不可能用到的修饰是（）  ","choices":["\nfinal\n","\nvoid\n","\nprotected\n","\nstatic\n"],"correct_choice":"\nvoid\n"},{"title":"public interface IService {\nString NAME=”default”;\n}   与上面等价表示是哪一项（）？     ","choices":["\npublic String NAME=”default”;\n","\npublic static String NAME=”default”;\n","\nprivate String NAME=”default”;\n","\npublic static final String NAME=”default”;\n"],"correct_choice":"\npublic static final String NAME=”default”;\n"},{"title":"\n  根据以下代码段，下列说法中正确的是(    )。\n\n\n  \n    \n      \n          public class   Parent {\n        \n        \n               private void m1(){}\n        \n        \n               void m2(){}\n        \n        \n               protected void m3(){}\n        \n        \n               public static void m4(){}\n        \n        \n          }\n        \n      \n  \n\n\n  \n","choices":["\n子类中一定能够继承和覆盖Parent类的m1方法\n","\n子类中一定能够继承和覆盖Parent类的m2方法\n","\n子类中一定能够继承和覆盖Parent类的m3方法\n","\n子类中一定能够继承和覆盖Parent类的m4方法\n"],"correct_choice":"\n子类中一定能够继承和覆盖Parent类的m3方法\n"},{"title":"\n  输入流将数据从文件，标准输入或其他外部输入设备中加载道内存，在\n  java\n  中其对应于抽象类（）及其子类。\n","choices":["\njava.io.InputStream\n","\njava.io.OutputStream\n","\njava.os.InputStream\n","\njava.os.OutputStream\n"],"correct_choice":"\njava.io.InputStream\n"},{"title":"\n  下列不属于类及类成员的访问控制符是：（\n   ）\n\n\n  \n","choices":["\npublic\n","\nprivate\n","\nstatic\n","\nprotected\n"],"correct_choice":"\nstatic\n"},{"title":"\n  在\n  JAVA\n  编程中，\n  Java\n  编译器会将\n  Java\n  程序转换为（\n  \n  ）\n","choices":["\n字节码\n","\n可执行代码\n","\n机器代码\n","\n以上都不对\n"],"correct_choice":"\n字节码\n"},{"title":"java中将ISO8859-1字符串转成GB2312编码，语句为 ？  ","choices":["\nnew String(\"ISO8959-1\".getBytes(\"ISO8959-1\")，“GB2312”)\n","\nnew String(String.getBytes(\"GB2312\"），ISO8859-1)\n","\nnew String(String.getBytes(\"ISO8859-1\"))\n","\nnew String(String.getBytes(\"GB2312\"))\n"],"correct_choice":"\nnew String(\"ISO8959-1\".getBytes(\"ISO8959-1\")，“GB2312”)\n"},{"title":"下面有关java和c++的描述，错误的是？","choices":["\njava是一次编写多处运行，c++是一次编写多处编译\n","\nc++和java支持多继承\n","\nJava不支持操作符重载，操作符重载被认为是c++的突出特征\n","\njava没有函数指针机制，c++支持函数指针\n"],"correct_choice":"\nc++和java支持多继承\n"},{"title":"  有这么一段程序： \npublic class Test{ \n    public String name=\"abc\"; \n    public static void main(String[] args){ \n        Test test=new Test(); \n        Test testB=new Test(); \n        System.out.println(test.equals(testB)+\",\"+test.name.equals(testB.name)); \n    } \n}\n  请问以上程序执行的结果是（） ","choices":["\ntrue,true\n","\ntrue,false\n","\nfalse,true\n","\nfalse,false\n"],"correct_choice":"\nfalse,true\n"},{"title":"  下面代码的输出结果是什么？ \npublic class ZeroTest {\n    public static void main(String[] args) {\n     try{\n       int i = 100 / 0;\n       System.out.print(i);\n  }catch(Exception e){\n       System.out.print(1);\n       throw new RuntimeException();\n  }finally{\n       System.out.print(2);\n  }\n      System.out.print(3);\n }\n }","choices":["\n3\n","\n123\n","\n1\n","\n12\n"],"correct_choice":"\n12\n"},{"title":"java如何接受request域中的参数？","choices":["\nrequest.getRequestURL()\n","\nrequest. getAttribute()\n","\nrequest.getParameter()\n","\nrequest.getWriter()\n"],"correct_choice":"\nrequest.getParameter()\n"},{"title":"以下程序的输出结果是？\npublic class Example {\n    String str = new String(\"good\");\n    char[] ch = { 'a', 'b', 'c' };\n\n    public static void main(String args[]) {\n        Example ex = new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.print(ex.str + \" and \");\n        System.out.print(ex.ch);\n    }\n\n   public static void change(String str, char ch[])       \n   {\n        str = \"test ok\";\n        ch[0] = 'g';\n    }\n}\n","choices":["\ngood and abc\n","\ngood and gbc\n","\ntest ok and abc\n","\ntest ok and gbc\n"],"correct_choice":"\ngood and gbc\n"},{"title":"下面有关servlet中init,service,destroy方法描述错误的是？","choices":["\ninit()方法是servlet生命的起点。一旦加载了某个servlet，服务器将立即调用它的init()方法\n","\nservice()方法处理客户机发出的所有请求\n","\ndestroy()方法标志servlet生命周期的结束\n","\nservlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的\n"],"correct_choice":"\nservlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的\n"},{"title":"  下面程序的运行结果：() \npublic static void main(String args[]) {\n\t\tThread t=new Thread(){\n\t\tpublic void  run(){\n\t\t\tdianping();\n\t\t\t\n\t\t}\n\t};\n\tt.run();\n\tSystem.out.print(\"dazhong\");\n\t}\n\tstatic void dianping(){\n\t\tSystem.out.print(\"dianping\");\n}","choices":["\ndazhongdianping\n","\ndianpingdazhong\n","\na和b都有可能\n","\ndianping循环输出，dazhong夹杂在中间\n"],"correct_choice":"\ndianpingdazhong\n"},{"title":"下面哪种情况会导致持久区jvm堆内存溢出？","choices":["\n循环上万次的字符串处理\n","\n在一段代码内申请上百M甚至上G的内存\n","\n使用CGLib技术直接操作字节码运行，生成大量的动态类\n","\n不断创建对象\n"],"correct_choice":"\n使用CGLib技术直接操作字节码运行，生成大量的动态类\n"},{"title":"下列关于Java并发的说法中正确的是（）","choices":["\nCopyOnWriteArrayList适用于写多读少的并发场景\n","\nReadWriteLock适用于读多写少的并发场景\n","\nConcurrentHashMap的写操作不需要加锁，读操作需要加锁\n","\n只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了\n"],"correct_choice":"\nReadWriteLock适用于读多写少的并发场景\n"},{"title":"\n  对下面Spring声明式事务的配置含义的说明错误的是（）\n\n\n  <bean id=\"txProxyTemplate\" abstract=\"true\"\nclass=\n\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\">\n    <property name=\"transactionManager\" ref=\"myTransactionManager\" />\n<property name=\"transactionAttributes\">      \n <props>\n        <prop key=\"get*\">PROPAGATION_REQUIRED,readOnly</prop>\n         <prop key=\"*\">PROPAGATION_REQUIRED</prop>\n     </props>\n</property> \n</bean>\n  \n","choices":["\n定义了声明式事务的配置模板\n","\n对get方法采用只读事务\n","\n缺少sessionFactory属性的注入\n","\n配置需要事务管理的bean的代理时，通过parent引用这个配置模板，代码如下：\n<bean id=\"petBiz\" parent=\"txProxyTemplate\">\n         <property name=\"target\" ref=\"petTarget\"/>\n</bean>\n\n"],"correct_choice":"\n缺少sessionFactory属性的注入\n"},{"title":"  在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )    \n  <%@ page language=\"java\"\n  import=\"java.util.*\" errorPage=\"error.jsp\"\n  isErrorPage=\"false\" %>  ","choices":["\n该页面可以使用 exception 对象\n","\n该页面发生异常会转向 error.jsp\n","\n存在 errorPage 属性时，isErrorPage 是默认为 false\n","\nerror.jsp 页面一定要有isErrorPage 属性且值为 true\n"],"correct_choice":"\n该页面可以使用 exception 对象\n"},{"title":"java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有（ ）","choices":["\nprivate\n","\npublic\n","\nprotected\n","\nstatic\n"],"correct_choice":"\nprivate\n\nprotected\n"},{"title":"jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？","choices":["\n抽象类可以有构造方法，接口中不能有构造方法\n","\n抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法\n","\n一个类可以实现多个接口，但只能继承一个抽象类\n","\n接口中可以有普通成员变量，抽象类中没有普通成员变量\n"],"correct_choice":"\n抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法\n\n接口中可以有普通成员变量，抽象类中没有普通成员变量\n"},{"title":"关于volatile关键字，下列描述不正确的是？","choices":["\n用volatile修饰的变量，每次更新对其他线程都是立即可见的。\n","\n对volatile变量的操作是原子性的。\n","\n对volatile变量的操作不会造成阻塞。\n","\n不依赖其他锁机制，多线程环境下的计数器可用volatile实现。\n"],"correct_choice":"\n对volatile变量的操作是原子性的。\n\n不依赖其他锁机制，多线程环境下的计数器可用volatile实现。\n"},{"title":"\n  关于继承的说法正确的是（）。 \n","choices":["\n子类将继承父类所有的数据域和方法。\n","\n子类将继承父类的其可见的数据域和方法。\n","\n子类只继承父类public方法和数据域\n","\n子类只继承父类的方法，而不继承数据域\n"],"correct_choice":"\n子类将继承父类所有的数据域和方法。\n"},{"title":"  下列哪个类的声明是正确的？  ","choices":["\nabstract final class HI{}\n","\nabstract private move(){}\n","\nprotected private number;\n","\npublic abstract class Car{}\n"],"correct_choice":"\npublic abstract class Car{}\n"},{"title":"  以下代码执行的结果是多少（）？  \t\tpublic class Demo {\n\tpublic static void main(String[] args) {\n\t\tCollection<?>[] collections = \n{new HashSet<String>(), new ArrayList<String>(), new HashMap<String, String>().values()};\n\t\t\t\tSuper subToSuper = new Sub();\n\t\t\t\tfor(Collection<?> collection: collections) {\n\tSystem.out.println(subToSuper.getType(collection));\n}\n}\nabstract static class Super {\n\tpublic static String getType(Collection<?> collection) {\n\t\treturn “Super:collection”;\n}\npublic static String getType(List<?> list) {\n\t\treturn “Super:list”;\n}\npublic String getType(ArrayList<?> list) {\n\t\treturn “Super:arrayList”;\n}\npublic static String getType(Set<?> set) {\n\t\treturn “Super:set”;\n}\npublic String getType(HashSet<?> set) {\n\t\treturn “Super:hashSet”;\n}\n}\nstatic class Sub extends Super {\n\tpublic static String getType(Collection<?> collection) {\n            return \"Sub\"; }\n}\n} ","choices":["\nSub:collection\nSub:collection\nSub:collection\n","\nSub:hashSet\nSub:arrayList\nSub:collection\n","\nSuper:collection\nSuper:collection\nSuper:collection\n","\nSuper:hashSet\nSuper:arrayList\nSuper:collection\n"],"correct_choice":"\nSuper:collection\nSuper:collection\nSuper:collection\n"},{"title":"  以下代码对其执行后，NumberList里的元素依次为：         List<Integer> NumberList =newArrayList<Integer>();       NumberList.add(2);       NumberList.add(4);       NumberList.add(1);       NumberList.add(3);       NumberList.add(5);       for(int i =0;i<NumberList.size();++i)       {        int v = NumberList.get(i);        if(v%2==0)        {           NumberList.remove(v);        }       }       System.out.println(NumberList);    ","choices":["\n2,4,1,3,5\n","\n2,1,3,5\n","\n4,1,3,5\n","\n会出现越界情况\n"],"correct_choice":"\n会出现越界情况\n"},{"title":"  以下描述错误的一项是（ ）？  ","choices":["\n程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行  到了第几行，是线程隔离的\n","\n原则上讲，所有的对象都是在堆区上分配内存，是线程之间共享的\n","\n方法区用于存储JVM加载的类信息、常量、静态变量，即使编译器编译后的代码等数据，是线程隔离的\n","\nJava方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的\n"],"correct_choice":"\n方法区用于存储JVM加载的类信息、常量、静态变量，即使编译器编译后的代码等数据，是线程隔离的\n"},{"title":"\n  一个类中，有两个方法名、形参类型、顺序和个数都完全一样，返回值不一样的方法,这种现象叫覆盖。（  ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"为\nAB\n类的一个无形式参数无返回值的方法\nmethod\n书写方法头，使得使用类名\nAB\n作为前缀就可以调用它，该方法头的形式为（\n）。","choices":["\nstatic  void  method( )\n","\npublic  void  method( )\n","\nfinal  void  method( )\n","\nabstract  void  method( )\n"],"correct_choice":"\nstatic  void  method( )\n"},{"title":"\n  以下关于集合类\n  ArrayList\n  、\n  LinkedList\n  、\n  HashMap\n  描述错误的是：\n","choices":["\nHashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值\n","\nArrayList和LinkedList均实现了List接口\n","\n添加和删除元素时，ArrayList的表现更佳\n","\nArrayList的访问速度比LinkedList快\n"],"correct_choice":"\n添加和删除元素时，ArrayList的表现更佳\n"},{"title":"Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述错误的是","choices":["\nArrayList和LinkedList均实现了List接口\n","\nArrayList的访问速度比LinkedList快\n","\n添加和删除元素时，ArrayList的表现更佳\n","\nHashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值\n"],"correct_choice":"\n添加和删除元素时，ArrayList的表现更佳\n"},{"title":"java语言的下面几种数组复制方法中，哪个效率最高？","choices":["\nfor 循环逐一复制\n","\nSystem.arraycopy\n","\nArray.copyOf\n","\n使用clone方法\n"],"correct_choice":"\nSystem.arraycopy\n"},{"title":"下面有个hibernate延迟加载，说法错误的是？","choices":["\nHibernate2延迟加载实现：a)实体对象 b)集合（Collection）\n","\nHibernate3 提供了属性的延迟加载功能\n","\nget支持延迟加载，load不支持延迟加\n","\nhibernate使用Java反射机制，而不是字节码增强程序来实现透明性\n"],"correct_choice":"\nget支持延迟加载，load不支持延迟加\n"},{"title":"Math.round(11.5)\n等于多少\n(). Math.round(-11.5)\n等于多少\n(  ).","choices":["\n11 ,-11\n","\n11 ,-12\n","\n12 ,-11\n","\n12 ,-12\n"],"correct_choice":"\n12 ,-11\n"},{"title":"下面哪个标识符是合法的？","choices":["\n\"9HelloWorld\"\n","\n\"_Hello World\"\n","\n\"Hello*World\"\n","\n\"Hello$World\"\n"],"correct_choice":"\n\"Hello$World\"\n"},{"title":"在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？","choices":["\nint float\n","\nint double\n","\nlong float\n","\nlong double\n"],"correct_choice":"\nint double\n"},{"title":"\n  java\n  接口的修饰符可以为（）\n","choices":["\nprivate\n","\nprotected\n","\nfinal\n","\nabstract\n"],"correct_choice":"\nabstract\n"},{"title":"  观察以下代码： \n\n  \n  class Car extends Vehicle\n{\n    public static void main (String[] args)\n    {\n        new  Car(). run();\n    }\n    private final void run()\n    {\n        System. out. println (\"Car\");\n    }\n}\nclass Vehicle\n{\n    private final void run()\n    {\n        System. out. println(\"Vehicle\");\n    }\n}\n  \n\n  下列哪些针对代码运行结果的描述是正确的？","choices":["\nCar\n","\nVehicle\n","\nCompiler error at line 3\n","\nCompiler error at line 5\n","\nException thrown at runtime\n"],"correct_choice":"\nCar\n"},{"title":"以下是java concurrent包下的4个类，选出差别最大的一个","choices":["\nSemaphore\n","\nReentrantLock\n","\nFuture\n","\nCountDownLatch\n"],"correct_choice":"\nFuture\n"},{"title":"检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。\npackage algorithms.com.guan.javajicu;  \npublic class Inc {  \n    public static void main(String[] args) {  \n       Inc inc = new Inc();  \n       int i = 0;  \n       inc.fermin(i);  \n       i= i ++;  \n       System.out.println(i); \n   \n    }  \n    void fermin(int i){  \n       i++;  \n    }  \n}  ","choices":["\n0\n","\n1\n","\n2\n","\n3\n"],"correct_choice":"\n0\n"},{"title":"  what is the result of the following code? \nenum AccountType\n{\n    SAVING, FIXED, CURRENT;\n    private AccountType()\n    {\n        System.out.println(“It is a account type”);\n    }\n}\nclass EnumOne\n{\n    public static void main(String[]args)\n    {\n        System.out.println(AccountType.FIXED);\n    }\n}\n\n\t\n\n\n","choices":["\nCompiles fine and output is prints”It is a account type”once followed by”FIXED”\n","\nCompiles fine and output is prints”It is a account type”twice followed by”FIXED”\n","\nCompiles fine and output is prints”It is a account type”thrice followed by”FIXED”\n","\nCompiles fine and output is prints”It is a account type”four times followed by”FIXED”\n","\nCompilation fails\n"],"correct_choice":"\nCompiles fine and output is prints”It is a account type”thrice followed by”FIXED”\n"},{"title":"\n  已知如下的命令执行 java MyTest a b c \n  \n  请问哪个语句是正确的？\n   ( )\n","choices":["\nargs[0] = \"MyTest a b c\"\n","\nargs[0] = \"MyTest\"\n","\nargs[0] = \"a\"\n","\nargs[1]= \"b\"\n"],"correct_choice":"\nargs[0] = \"a\"\n\nargs[1]= \"b\"\n"},{"title":"以下表达式中，正确的是（）","choices":["\nbyte i=128\n","\nboolean i=null\n","\nlong i=0xfffL\n","\ndouble i=0.9239d\n"],"correct_choice":"\nlong i=0xfffL\n\ndouble i=0.9239d\n"},{"title":"根据下面的代码，\n  String s = null;\n  会抛出NullPointerException异常的有（）。","choices":["\nif( (s!=null) & (s.length()>0) )\n","\nif( (s!=null) && (s.length()>0) )\n","\nif( (s==null) | (s.length()==0) )\n","\nif( (s==null) || (s.length()==0) )\n"],"correct_choice":"\nif( (s!=null) & (s.length()>0) )\n\nif( (s==null) | (s.length()==0) )\n"},{"title":"下面有关servlet的层级结构和常用的类，说法正确的有?","choices":["\nGenericServlet类：抽象类，定义一个通用的、独立于底层协议的Servlet。\n","\n大多数Servlet通过从GenericServlet或HttpServlet类进行扩展来实现\n","\nServletConfig接口定义了在Servlet初始化的过程中由Servlet容器传递给Servlet得配置信息对象\n","\nHttpServletRequest接口扩展ServletRequest接口，为HTTP Servlet提供HTTP请求信息\n"],"correct_choice":"\nGenericServlet类：抽象类，定义一个通用的、独立于底层协议的Servlet。\n\n大多数Servlet通过从GenericServlet或HttpServlet类进行扩展来实现\n\nServletConfig接口定义了在Servlet初始化的过程中由Servlet容器传递给Servlet得配置信息对象\n\nHttpServletRequest接口扩展ServletRequest接口，为HTTP Servlet提供HTTP请求信息\n"},{"title":"以下哪几种方式可用来实现线程间通知和唤醒：(       )","choices":["\nObject.wait/notify/notifyAll\n","\nReentrantLock.wait/notify/notifyAll\n","\nCondition.await/signal/signalAll\n","\nThread.wait/notify/notifyAll\n"],"correct_choice":"\nObject.wait/notify/notifyAll\n\nCondition.await/signal/signalAll\n"},{"title":"public class NameList\n{\n    private List names = new ArrayList();\n    public synchronized void add(String name)\n    {\n        names.add(name);\n    }\n    public synchronized void printAll()     {\n        for (int i = 0; i < names.size(); i++)\n        {\n            System.out.print(names.get(i) + ””);\n        }\n    }\n\n    public static void main(String[]args)\n    {\n        final NameList sl = new NameList();\n        for (int i = 0; i < 2; i++)\n        {\n            new Thread()\n            {\n                public void run()\n                {\n                    sl.add(“A”);\n                    sl.add(“B”);\n                    sl.add(“C”);\n                    sl.printAll();\n                }\n            } .start();\n        }\n    }\n}\n\n  Which two statements are true if this class is compiled and run? \n","choices":["\nAn exception may be thrown at runtime.\n","\nThe code may run with no output, without exiting.\n","\nThe code may run with no output, exiting normally(正常地).\n","\nThe code may rum with output “A B A B C C “, then exit.\n","\nThe code may rum with output “A B C A B C A B C “, then exit.\n","\nThe code may ruin with output “A A A B C A B C C “, then exit.\n","\nThe code may ruin with output “A B C A A B C A B C “, then exit.\n"],"correct_choice":"\nThe code may rum with output “A B C A B C A B C “, then exit.\n\nThe code may ruin with output “A B C A A B C A B C “, then exit.\n"},{"title":"/*..................*/中可以嵌套//注释，也能嵌套/*..........*/注释。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  有程序片段如下，以下表达式结果为\n  true\n  的是（\n  ）\n\n\n  Float  s=new  Float(0.1f);\n\n\n  Float  t=new  Float(0.1f);\n\n\n  Double  u=new  Double(0.1);\n","choices":["\ns==t\n","\ns.equals(t)\n","\nu.equals(s)\n","\nt.equals(u)\n"],"correct_choice":"\ns.equals(t)\n"},{"title":"\n  \n    假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量，则线程 1 和线程 2 同时执行下面的代码，最终 a 的结果不可能是（）  \n  \n    \n  \n     boolean isOdd = false;  \n\n\n  \n    \n  \n\n\n  for(int i=1;i<=2;++i)\n\n\n  {\n\n  if（i%2==1）isOdd = true； \n  else isOdd = false； \n\n   a+=i*(isOdd?1:-1)；\n\n\n  }\n\n\n  \n","choices":["\n-1\n","\n-2\n","\n0\n","\n1\n"],"correct_choice":"\n1\n"},{"title":"Java中只有整型才能使用的运算符为？","choices":["\n*\n","\n/\n","\n%\n","\n+\n"],"correct_choice":"\n%\n"},{"title":"\n  如下Java语句\n  double x=2.0; int y=4;\n  x/=++y;\n   执行后，x的值是（）\n","choices":["\n0.5\n","\n2.5\n","\n0.4\n","\n2.0\n"],"correct_choice":"\n0.4\n"},{"title":"\n  映射\n  (Map)\n  的key和value都不可重复。（    ）\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"高优先级的线程比低优先级的线程运行得更快。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"下列关于一个类的静态成员的描述中，不正确的是","choices":["\n该类的对象共享其静态成员变量的值\n","\n静态成员变量可被该类的所有方法访问\n","\n该类的静态方法能访问该类的静态成员变量\n","\n该类的静态数据成员变量的值不可修改\n"],"correct_choice":"\n该类的静态数据成员变量的值不可修改\n"},{"title":"下面不属于Object类中方法的是:","choices":["\nhashCode()\n","\nfinally()\n","\nwait()\n","\ntoString()\n"],"correct_choice":"\nfinally()\n"},{"title":"  已知如下类说明：   public class Test{\n    private float f=1.0;\n    int m=12;\n    static int n=1;\n    public static void main(String args[]){\n        Test t=new Test();\n    }\n}   如下哪些使用是正确的（）  ","choices":["\nt.f\n","\nthis.n\n","\nTest.m\n","\nTest.n\n"],"correct_choice":"\nTest.n\n"},{"title":"下面有关jsp中静态include和动态include的区别，说法错误的是？  ","choices":["\n动态INCLUDE:用jsp:include动作实现 \n","\n静态INCLUDE:用include伪码实现，定不会检查所含文件的变化，适用于包含静态页面<%@ include file=\"included.htm\" %>\n","\n静态include的结果是把其他jsp引入当前jsp，两者合为一体;动态include的结构是两者独立，直到输出时才合并\n","\n静态include和动态include都可以允许变量同名的冲突.页面设置也可以借用主文件的\n"],"correct_choice":"\n静态include和动态include都可以允许变量同名的冲突.页面设置也可以借用主文件的\n"},{"title":"  指出下列程序运行的结果（）  public class Example{\n    String str = new String(\"good\");\n    char[ ] ch = { 'a' , 'b' , 'c' };\n    public static void main(String args[]){\n        Example ex = new Example();\n        ex.change(ex.str,ex.ch);\n        System.out.print(ex.str + \" and \");\n        System.out.print(ex.ch);\n    }\n    public void change(String str,char ch[ ]){\n        str = \"test ok\";\n        ch[0] = 'g';\n    }\n}      ","choices":["\ngood and  abc\n","\ngood and gbc\n","\ntest ok and abc\n","\ntest ok and gbc\n"],"correct_choice":"\ngood and gbc\n"},{"title":"下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？","choices":["\n实例变量指的是类中定义的变量，即成员变量，如果没有初始化，会有默认值。\n","\n局部变量指的是在方法中定义的变量，如果没有初始化，会有默认值\n","\n类变量指的是用static修饰的属性\n","\nfinal变量指的是用final 修饰的变量\n"],"correct_choice":"\n局部变量指的是在方法中定义的变量，如果没有初始化，会有默认值\n"},{"title":"明朝时期张居正改革的一条鞭法的主要思想是()","choices":["\n面向过程\n","\n万物皆数\n","\n统一接口\n","\n泛型编程\n"],"correct_choice":"\n统一接口\n"},{"title":"\n  public class Test\n{\n    public int x;\n    public static void main(String []args)\n    {\n        System. out. println(\"Value is\" + x);\n    }\n}\n\n   对于上面这段代码，以下说法正确的是： ","choices":["\n程序会打出 \"Value is 0\"\n","\n程序会抛出 NullPointerException\n","\n非静态变量不能够被静态方法引用\n","\n编译器会抛出 \"possible reference before assignment\"的错误\n"],"correct_choice":"\n非静态变量不能够被静态方法引用\n"},{"title":"  在jdk1.5的环境下，有如下4条语句： \nInteger i01 = 59;\nint i02 = 59;\nInteger i03 =Integer.valueOf(59);\nInteger i04 = new Integer(59)。\n  以下输出结果为false的是： ","choices":["\nSystem.out.println(i01== i02);\n","\nSystem.out.println(i01== i03);\n","\nSystem.out.println(i03== i04);\n","\nSystem.out.println(i02== i04);\n"],"correct_choice":"\nSystem.out.println(i03== i04);\n"},{"title":"  以下代码将打印出   public static void main (String[] args) { \n    String classFile = \"com.jd.\". replaceAll(\".\", \"/\") + \"MyClass.class\";\n    System.out.println(classFile);\n}","choices":["\ncom. jd\n","\ncom/jd/MyClass.class\n","\n///////MyClass.class\n","\ncom.jd.MyClass\n"],"correct_choice":"\n///////MyClass.class\n"},{"title":"下面哪些属于JSP内置对象及方法？","choices":["\nrequest\n","\nout\n","\napplication\n","\nconfig\n"],"correct_choice":"\nrequest\n\nout\n\napplication\n\nconfig\n"},{"title":"在Java中下面Class的声明哪些是错误的？","choices":["\npublic abstract final class Test {\n\tabstract void method();\n}\n","\npublic abstract class Test {\n\tabstract final void method();\n}\n","\npublic abstract class Test {\n\tabstract void method() {\n}\n}\n","\npublic class Test {\n\tfinal void method() {\n\n}\n}\n"],"correct_choice":"\npublic abstract final class Test {\n\tabstract void method();\n}\n\npublic abstract class Test {\n\tabstract final void method();\n}\n\npublic abstract class Test {\n\tabstract void method() {\n}\n}\n"},{"title":"  下面哪些写法能在 java8   中编译执行（） ","choices":["\ndir.listFiles((File f)->f.getName().endsWith(“.Java”));\n","\ndir.listFiles((File f)=>f.getName().endsWith(“.Java”));\n","\ndir.listFiles((_.getName().endsWith(“.Java”)));\n","\ndir.listFiles( f->f.getName().endsWith(“.Java”));\n"],"correct_choice":"\ndir.listFiles((File f)->f.getName().endsWith(“.Java”));\n\ndir.listFiles( f->f.getName().endsWith(“.Java”));\n"},{"title":"Model-View-Controller(MVC) is an architectural pattern that frequently\nused in web applications. Which of the following statement(s) is(are) correct?","choices":["\nModels often represent data and the business logics needed to manipulate the data in the application\n","\nA view is a (visual) representation of its model. It renders the model into a form suitable for interaction, typically a user interface element\n","\nA controller is the link between a user and the system. It accepts input from the user and instructs the model and a view to perform actions based on that input\n","\nThe common practice of MVC in web applications is, the model receives GET or POST input from user and decides what to do with it, handing over to controller and which hand control to views(HTML-generating components)\n","\nNone of the above\n"],"correct_choice":"\nModels often represent data and the business logics needed to manipulate the data in the application\n\nA view is a (visual) representation of its model. It renders the model into a form suitable for interaction, typically a user interface element\n\nA controller is the link between a user and the system. It accepts input from the user and instructs the model and a view to perform actions based on that input\n"},{"title":"在Jdk1.7中，下述说法中抽象类与接口的区别正确的有哪些？\n","choices":["\n抽象类中可以有普通成员变量，接口中没有普通成员变量。\n","\n抽象类和接口中都可以包含静态成员常量。\n","\n一个类可以实现多个接口，但只能继承一个抽象类\n","\n抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。\n"],"correct_choice":"\n抽象类中可以有普通成员变量，接口中没有普通成员变量。\n\n抽象类和接口中都可以包含静态成员常量。\n\n一个类可以实现多个接口，但只能继承一个抽象类\n\n抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。\n"},{"title":"\n  抽象类方法的访问权限默认都是public。（  ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"若在某一个类定义中定义有如下的方法：\nabstract void performDial( );\n该方法属于（）","choices":["\n本地方法\n","\n最终方法\n","\n解态方法\n","\n抽象方法\n"],"correct_choice":"\n抽象方法\n"},{"title":"\n  在\n  main()\n  方法中给出的整型数组，如果将其写到一个文件中，需要（ ）。\n","choices":["\n标准输出流System.out.println()。\n","\n建立数据字节输出流。\n","\n建立数据字节输入流。\n","\n标准输入流System.in.read()。\n"],"correct_choice":"\n建立数据字节输出流。\n"},{"title":"提供Java存取数据库能力的包是（ ）","choices":["\njava.sql\n","\njava.awt\n","\njava.lang\n","\njava.swing\n"],"correct_choice":"\njava.sql\n"},{"title":"\n  设三个整型变量 x = 1 , y = 2 , z = 3，则表达式\n      y＋＝z－－/＋＋x\n      的值是(      )。\n  \n","choices":["\n3\n","\n3.5\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"如果一个方法或变量是\"private\"访问级别，那么它的访问范围是:","choices":["\n在当前类，或者子类中\n","\n在当前类或者它的父类中\n","\n在当前类，或者它所有的父类中\n","\n在当前类中\n"],"correct_choice":"\n在当前类中\n"},{"title":"\n  关于如下程序的描述哪个是正确的？（ ）\n\n\n  public class Person{\n\n\n  static int arr[] = new int[5];\n\n\n  public static void main(String a[]){\n\n\n  System.out.println(arr[0]);\n\n\n  }\n\n\n  }\n","choices":["\n编译将产生错误\n","\n编译时正确，但运行时将产生错误\n","\n正确，输出0\n","\n正确，输出 null\n"],"correct_choice":"\n正确，输出0\n"},{"title":"\n  局部变量能否和成员变量重名？ \n","choices":["\n可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量\n","\n可以，这时可用“local”关键字来指向局部变量\n","\n不能，局部变量不能与成员变量重名\n","\n不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量\n"],"correct_choice":"\n可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量\n"},{"title":"  有以下代码: \nclass A{\n\tpublic A(String str){\n\t\t\n\t}\n}\npublic class Test{\n\tpublic static void main(String[] args) {\n\t\tA classa=new A(\"he\");\n\t\tA classb=new A(\"he\");\n\t\tSystem.out.println(classa==classb);\n\t}\n}\n  请问输出的结果是: ","choices":["\nfalse\n","\ntrue\n","\n报错\n","\n以上选项都不正确\n"],"correct_choice":"\nfalse\n"},{"title":"\n  若有定义语句：\n  int a=10\n  ；\n  double b=3.14\n  ；则表达式\n  ’A’+a+b\n  值的类型是（）\n","choices":["\nchar\n","\nint\n","\ndouble\n","\nfloat\n"],"correct_choice":"\ndouble\n"},{"title":"Which of the following class is not implement java.util.Map interface?","choices":["\nHashtable\n","\nHashMap\n","\nVector\n","\nIdentityHashMap\n"],"correct_choice":"\nVector\n"},{"title":"  如下Java语句 \ndouble x= 3.0; \nint y=5; \nx/=--y;\n  执行后， x的值是（） ","choices":["\n3\n","\n0.6\n","\n0.4\n","\n0.75\n"],"correct_choice":"\n0.75\n"},{"title":"  以下代码在编译和运行过程中会出现什么情况 \npublic class TestDemo{\n\tprivate int count;\n\tpublic static void main(String[] args) {\n\t\tTestDemo test=new TestDemo(88);\n\t\tSystem.out.println(test.count);\n\t}\n\t TestDemo(int a) {\n\t\t count=a;\n\t}\n}\n","choices":["\n编译运行通过，输出结果是88\n","\n编译时错误，count变量定义的是私有变量\n","\n编译时错误，System.out.println方法被调用时test没有被初始化\n","\n编译和执行时没有输出结果\n"],"correct_choice":"\n编译运行通过，输出结果是88\n"},{"title":"下列不属于java语言鲁棒性特点的是","choices":["\njava能检查程序在编译和运行时的错误\n","\njava能运行虚拟机实现跨平台\n","\njava自己操纵内存减少了内存出错的可能性\n","\njava还实现了真数组，避免了覆盖数据的可能\n"],"correct_choice":"\njava能运行虚拟机实现跨平台\n"},{"title":"  说明输出结果。 \npackage test; \nimport java.util.Date;  \npublic class SuperTest extends Date{  \n    private static final long serialVersionUID = 1L;  \n    private void test(){  \n       System.out.println(super.getClass().getName());  \n    }  \n     \n    public static void main(String[]args){  \n       new SuperTest().test();  \n    }  \n}  \n","choices":["\nSuperTest\n","\nSuperTest.class\n","\ntest.SuperTest\n","\ntest.SuperTest.class\n"],"correct_choice":"\ntest.SuperTest\n"},{"title":"  下面关于程序编译说法正确的是（）  ","choices":["\njava语言是编译型语言，会把java程序编译成二进制机器指令直接运行\n","\njava编译出来的目标文件与具体操作系统有关\n","\njava是解释型语言，在运行时才进行翻译指令\n","\njava编译出来的目标文件，可以运行在任意jvm上\n"],"correct_choice":"\njava是解释型语言，在运行时才进行翻译指令\n"},{"title":"  list是一个ArrayList的对象，哪个选项的代码填到//todo\n  delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（） \nIterator it = list.iterator();\nint index = 0;\nwhile (it.hasNext())\n{\n    Object obj = it.next();\n    if (needDelete(obj))  //needDelete返回boolean，决定是否要删除\n    {\n        //todo delete\n    }\n    index ++;\n}\n\n","choices":["\nit.remove();\n","\nlist.remove(obj);\n","\nlist.remove(index);\n","\nlist.remove(obj,index);\n"],"correct_choice":"\nit.remove();\n"},{"title":"\n  下面的类哪些可以处理Unicode字符?\n  \n","choices":["\nInputStreamReader\n","\nBufferedReader\n","\nWriter\n","\nPipedInputStream\n"],"correct_choice":"\nInputStreamReader\n\nBufferedReader\n\nWriter\n"},{"title":"  关于OutOfMemoryError，下面说法正确的是（）？ ","choices":["\njava.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。\n","\njava.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现\n","\njava.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小\n","\njava.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到\n"],"correct_choice":"\njava.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。\n\njava.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现\n\njava.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小\n"},{"title":"下面有关 JAVA 异常类的描述,说法正确的有()","choices":["\n异常的继承结构:基类为 Throwable,Error 和 Exception 继承 Throwable,RuntimeException 和 IOException 等继承 Exception\n","\n非 RuntimeException 一般是外部错误(不考虑Error的情况下),其必须被 try{}catch 语句块所捕获\n","\nError 类体系描述了 Java 运行系统中的内部错误以及资源耗尽的情形,Error 不需要捕捉\n","\nRuntimeException 体系包括错误的类型转换、数组越界访问和试图访问空指针等等,必须 被 try{}catch 语句块所捕获\n"],"correct_choice":"\n异常的继承结构:基类为 Throwable,Error 和 Exception 继承 Throwable,RuntimeException 和 IOException 等继承 Exception\n\nError 类体系描述了 Java 运行系统中的内部错误以及资源耗尽的情形,Error 不需要捕捉\n"},{"title":"\n  根据以下接口和类的定义，要使代码没有语法错误，则类Hero中应该定义方法(    )。\n\n\n  \n    \n      \n          interface   Action{  \n        \n        \n              void fly();  \n        \n        \n          }\n        \n        \n          class Hero   implements Action{  //……  }\n        \n      \n  \n","choices":["\nprivate void fly(){}\n","\nvoid fly(){}\n","\nprotected void fly(){}\n","\npublic void fly(){}\n"],"correct_choice":"\npublic void fly(){}\n"},{"title":"\n  下列不正确的\n  Java\n  语言标识符是（\n  ）\n","choices":["\nSky\n","\n$Computer\n","\nfor\n","\nNULL\n"],"correct_choice":"\nfor\n"},{"title":"Java语言中，String s =new String(“xyz”);创建了几个string object？","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n2\n"},{"title":"\n  在Java \n      Applet程序用户自定义的Applet子类中，一般需要重载父类的(      )方法来完成一些画图操作。\n","choices":["\nstart( )\n","\nstop( )\n","\ninit( )\n","\npaint( )\n"],"correct_choice":"\npaint( )\n"},{"title":"以下哪项是类实例化的语句？","choices":["\nvarName ClassName=new varName();\n","\nClassName varName=new ClassName(new ClassName);\n","\nClassName varName=ClassName();\n","\nClassName varName=new ClassName();\n"],"correct_choice":"\nClassName varName=new ClassName();\n"},{"title":"\n  为初始化其成员变量，每个类都定义的方法是（）\n","choices":["\n方法\n","\nmain\n","\n构造方法\n","\n对象\n"],"correct_choice":"\n构造方法\n"},{"title":"我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名。（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  类Test1定义如下: \npublic class Test1{//1\n    public float aMethod(float a,float b){}//2 \n    //3\n}//4\n  将以下哪种方法插入行3是不合法的。 ","choices":["\npublic int aMethod(int a,int b){}\n","\nprivate float aMethod(int a,int b,int c){}\n","\npublic float aMethod(float a,float b){}\n","\npublic float aMethod(float a,float b,float c){}\n"],"correct_choice":"\npublic float aMethod(float a,float b){}\n"},{"title":"一个以”.java”为后缀的源文件\n","choices":["\n只能包含一个类，类名必须与文件名相同\n","\n只能包含与文件名相同的类以及其中的内部类\n","\n只能有一个与文件名相同的类，可以包含其他类\n","\n可以包含任意类\n"],"correct_choice":"\n只能有一个与文件名相同的类，可以包含其他类\n"},{"title":"下面有关java内存模型的描述，说法错误的是？","choices":["\nJMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证\n","\n“synchronized” — 保证在块开始时都同步主内存的值到工作内存，而块结束时将变量同步回主内存\n","\n“volatile” — 保证修饰后在对变量读写前都会与主内存更新。\n","\n如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），就可以保证了这个对象被其他线程正确的查看\n"],"correct_choice":"\n如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），就可以保证了这个对象被其他线程正确的查看\n"},{"title":"判断对错。在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：\n\nbyte[] src,dst;\n\n  \n","choices":["\ndst=String.frombytes(src,”GBK”).getbytes(“UTF-8”)\n","\ndst=new String (src,”GBK”).getbytes(“UTF-8”)\n","\ndst=new String (”GBK”, src,) getbytes()\n","\ndst=String.encode(String.decode(src,”GBK”)), “UTF-8”)\n"],"correct_choice":"\ndst=new String (src,”GBK”).getbytes(“UTF-8”)\n"},{"title":"  What is the result of compiling and executing the following\n  fragment of code: \nBoolean flag = false;\nif (flag = true)\n{\n    System.out.println(“true”);\n}\nelse\n{\n    System.out.println(“false”);\n}\n\n","choices":["\nThe code fails to compile at the “if” statement.\n","\nAn exception is thrown at run-time at the “if” statement.\n","\nThe text“true” is displayed.\n","\nThe text“false”is displayed.\n","\nNothing is displayed.\n"],"correct_choice":"\nThe text“true” is displayed.\n"},{"title":"  如下代码的输出结果是什么？   public class Test { \n    public int aMethod(){\n        static int i = 0;\n        i++; \n        return i;\n    } \npublic static void main(String args[]){\n    Test test = new Test(); \n    test.aMethod(); \n    int j = test.aMethod();\n    System.out.println(j);\n    } \n} ","choices":["\n0\n","\n1\n","\n2\n","\n编译失败\n"],"correct_choice":"\n编译失败\n"},{"title":"下列有关Servlet的生命周期，说法不正确的是？","choices":["\n在创建自己的Servlet时候，应该在初始化方法init()方法中创建Servlet实例\n","\n在Servlet生命周期的服务阶段，执行service()方法，根据用户请求的方法，执行相应的doGet()或是doPost()方法\n","\n在销毁阶段，执行destroy()方法后会释放Servlet 占用的资源\n","\ndestroy()方法仅执行一次，即在服务器停止且卸载Servlet时执行该方法\n"],"correct_choice":"\n在创建自己的Servlet时候，应该在初始化方法init()方法中创建Servlet实例\n"},{"title":"  面向对象的程序设计语言具有（）等共同特性。","choices":["\n封装性\n","\n多态性\n","\n简单性\n","\n复杂性\n","\n继承性\n"],"correct_choice":"\n封装性\n\n多态性\n\n继承性\n"},{"title":"\n  Java\n  提供的事件处理模型是一种人机交互模型。它有三个基本要素\n","choices":["\n事件源\n","\n事件对象\n","\n事件过程\n","\n事件监听器\n"],"correct_choice":"\n事件源\n\n事件对象\n\n事件监听器\n"},{"title":"\n  Choose the correct  ones from the following statements:\n","choices":["\nA class can implement more than one interfaces\n","\nA class can extend more than one class\n","\nAn interface has at least one method declared.\n","\nAn abstract class which has no abstract methods declared is legal\n"],"correct_choice":"\nA class can implement more than one interfaces\n\nAn abstract class which has no abstract methods declared is legal\n"},{"title":"有关会话跟踪技术描述正确的是（）","choices":["\nCookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端\n","\n关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期\n","\n在禁用Cookie时可以使用URL重写技术跟踪会话\n","\n隐藏表单域将字段添加到HTML表单并在客户端浏览器中显示\n"],"correct_choice":"\nCookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端\n\n关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期\n\n在禁用Cookie时可以使用URL重写技术跟踪会话\n"},{"title":"\n  下列不属于访问控制符的是（）\n","choices":["\npublic\n","\nprivate\n","\nprotected\n","\nstatic\n"],"correct_choice":"\nstatic\n"},{"title":"\n  下列关于修饰符混用的说法，错误的是( )\n","choices":["\nabstract不能与final并列修饰同一个类\n","\nabstract 类中不建议有private的成员\n","\nabstract 方法必须在abstract类或接口中\n","\nstatic方法中能直接处理非static的属性\n"],"correct_choice":"\nstatic方法中能直接处理非static的属性\n"},{"title":"在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数的个数、类型或顺序各不相同，传回的值也可以不相同。这种面向对象程序特性称为（）","choices":["\n隐藏\n","\n重写\n","\n重载\n","\nJava不支持此特性\n"],"correct_choice":"\n重载\n"},{"title":"\n  paint()\n  方法使用哪种类型的参数\n  ?（ ）\n","choices":["\nGraphics\n","\nGraphics2D\n","\nString\n","\nColor\n"],"correct_choice":"\nGraphics\n"},{"title":"\n  下列程序段执行后t3的结果是（）。 \n\n\n  int t1=2, t2=3, t3;\n\n\n  t3=t1<t2?t1:(t2+t1); \n","choices":["\n2\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n2\n"},{"title":"  在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？ ","choices":["\n管道\n","\n消息队列\n","\n高速缓存数据库\n","\n套接字\n"],"correct_choice":"\n管道\n"},{"title":"  正则表达式中，表示匹配非数字字符的字符是（）？ ","choices":["\n\\b\n","\n\\d\n","\n\\B\n","\n\\D\n"],"correct_choice":"\n\\D\n"},{"title":"\n  类\n  ABC\n  定义如下：\n\n\n  1\n  ．\n  public  class  ABC{\n\n\n  2\n  ．\n   public  int  max( int  a, int  b) {   }\n\n\n  3\n  ．\n\n\n  4\n  ．\n  } \n\n\n  将以下哪个方法插入行\n  3\n  是不合法的。（ ）。\n","choices":["\npublic  float  max(float  a, float  b, float  c){  }\n","\npublic  int  max (int  c,  int  d){  }\n","\npublic  float  max(float  a,  float  b){  }\n","\nprivate  int  max(int a, int b, int c){  }\n"],"correct_choice":"\npublic  int  max (int  c,  int  d){  }\n"},{"title":"  下列修饰符中，能够使得某个成员变量只能被它所在包访问到和它的子类访问到的是（ ）  ","choices":["\nprotected\n","\npublic\n","\nprivate\n","\n应不加修饰符\n"],"correct_choice":"\nprotected\n"},{"title":"一个以”.java”为后缀的源文件","choices":["\n只能包含一个类，类名必须与文件名相同\n","\n只能包含与文件名相同的类以及其中的内部类\n","\n只能有一个与文件名相同的类，可以包含其他类\n","\n可以包含任意类\n"],"correct_choice":"\n只能有一个与文件名相同的类，可以包含其他类\n"},{"title":"在异常处理中，如释放资源，关闭数据库、关闭文件应由（    ）语句来完成。","choices":["\ntry子句\n","\ncatch子句\n","\nfinally子句\n","\nthrow子句\n"],"correct_choice":"\nfinally子句\n"},{"title":"判断对错。List，Set，Map都继承自继承Collection接口。","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"在使用super和this关键字时，以下描述正确的是（）    ","choices":["\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n","\nsuper（）和this（）不一定要放在构造方法内第一行\n","\nthis（）和super（）可以同时出现在一个构造函数中\n","\nthis（）和super（）可以在static环境中使用，包括static方法和static语句块\n"],"correct_choice":"\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n"},{"title":"假设有以下代码String s = \"hello\"；String t = “hello”；char c [ ] = {'h','e','l','l','o'}；下列选项中返回false的语句是？","choices":["\ns.equals (t)；\n","\nt.equals (c)；\n","\ns==t；\n","\nt.equals (new String (\"hello\"))；\n"],"correct_choice":"\nt.equals (c)；\n"},{"title":"Java程序中的类名称必须与存放该类的文件名相同。","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  关于AWT和Swing说法正确的是？ ","choices":["\nSwing是AWT的子类\n","\nAWT在不同操作系统中显示相同的风格\n","\nAWT不支持事件类型，Swing支持事件模型\n","\nSwing在不同的操作系统中显示相同的风格\n"],"correct_choice":"\nSwing在不同的操作系统中显示相同的风格\n"},{"title":"面向对象的三个基本元素是什么？","choices":["\n封装\n","\n继承\n","\n重载\n","\n多态\n"],"correct_choice":"\n封装\n\n继承\n\n多态\n"},{"title":"Integer i = 42; \nLong l = 42l; \nDouble d = 42.0; \n  下面为true的是","choices":["\n(i == l)\n","\n(i == d)\n","\n(l == d)\n","\ni.equals(d)\n","\nd.equals(l)\n","\ni.equals(l)\n","\nl.equals(42L)\n"],"correct_choice":"\nl.equals(42L)\n"},{"title":"对于一个已经不被任何变量引用的对象，当垃圾回收器准备回收该对象所占用的内存时，将自动调用该对象的哪个方法（）","choices":["\nfinalize\n","\nnotify\n","\nnotifyAll\n","\nhashCode\n"],"correct_choice":"\nfinalize\n"},{"title":"\n  类Car里面有个方法run()，如果直接用Car.run()，则方法run前面必须用的关键词是？  ( \n   )\n\n\n  \n","choices":["\nclass\n","\nfinal\n","\npublic\n","\nstatic\n"],"correct_choice":"\nstatic\n"},{"title":"  以下代码执行的结果显示是多少（）？       ","choices":["\n0110\n","\n-1110\n","\n0211\n","\n-1211\n"],"correct_choice":"\n-1110\n"},{"title":"\n  下列叙述错误的是（\n  ）\n","choices":["\njava程序的输入输出功能是通过流来实现的\n","\njava中的流按照处理单位可分成两种：字节流和字符流\n","\nInputStream是一个基本的输出流类。\n","\n通过调用相应的close（）方法关闭输入输出流\n"],"correct_choice":"\nInputStream是一个基本的输出流类。\n"},{"title":"哪个关键字可以对对象加互斥锁？（）","choices":["\nsynchronized\n","\nvolatile\n","\nserialize\n","\nstatic\n"],"correct_choice":"\nsynchronized\n"},{"title":"\n  有以下代码片段：\n\n\n   String str1=\"hello\";\n\n\n   String str2=\"he\"+ new String(\"llo\");\n\n\n   System.out.println(str1==str2);\n\n\n  请问输出的结果是：\n","choices":["\ntrue\n","\n都不对\n","\nnull\n","\nfalse\n"],"correct_choice":"\nfalse\n"},{"title":"Java数据库连接库JDBC用到哪种设计模式?","choices":["\n生成器\n","\n桥接模式\n","\n抽象工厂\n","\n单例模式\n"],"correct_choice":"\n桥接模式\n"},{"title":"instanceof运算符能够用来判断一个对象是否为:","choices":["\n一个类的实例\n","\n一个实现指定接口的类的实例\n","\n全部正确\n","\n一个子类的实例\n"],"correct_choice":"\n全部正确\n"},{"title":"\n  给出以下代码,请给出结果. \nclass Two{\n    Byte x;\n}\nclass PassO{\n    public static void main(String[] args){\n        PassO p=new PassO();\n        p.start();\n    }\n    void start(){\n        Two t=new Two();\n        System.out.print(t.x+””);\n        Two t2=fix(t);\n        System.out.print(t.x+” ” +t2.x);\n    }\n    Two fix(Two tt){\n        tt.x=42;\n        return tt;\n    }\n}\n\n","choices":["\nnull null 42\n","\nnull 42 42\n","\n0 0 42\n","\n0 42 42\n","\nAn exception is thrown at runtime\n","\nCompilation\n"],"correct_choice":"\nnull 42 42\n"},{"title":"  下面程序的输出结果是什么。  public class A2{ \npublic static void main(String[] args){\n    int[] a={2,4,6,8,3,6,9,12};\n    doSomething(a,0,a.length-1);\n    for(int i=0;i<=a.length-1;i++)\n    System.out.print(a[i]+\" \");\n} \nprivate static void doSomething(int[] a,int start,int end){\n    if(start<end){\n        int p=core(a,start,end);\n        doSomething(a,start,p-1);\n        doSomething(a,p+1,end);\n    }\n}\nprivate static int core(int[] a,int start,int end)\n{\n    int x=a[end];\n    int i=start;\n    for(int j=start;j<=end-1;j++){\n        if(a[j]>=x){\n            swap(a,i,j);\n            i++;//交换了几次 \n        }\n    }//把最大的放到最后\n    swap(a,i,end);//把最大的放到i的位置 \n    return i;\n} \n \nprivate static void swap(int[] a,int i,int j) \n{\n    int tmp=a[i];\n    a[i]=a[j];\n    a[j]=tmp;\n}\n}  ","choices":["\n找到最大值\n","\n找到最小值\n","\n从大到小的排序\n","\n从小到大的排序\n"],"correct_choice":"\n从大到小的排序\n"},{"title":"关于HashMap和Hashtable正确的说法有（）","choices":["\n都实现了Map接口\n","\nHashtable类不是同步的，而HashMap类是同步的\n","\nHashtable不允许null键或值\n","\nHashMap不允许null或值\n"],"correct_choice":"\n都实现了Map接口\n\nHashtable不允许null键或值\n"},{"title":"若下列所用变量均已经正确定义，一下表达式中不合法的是","choices":["\nx>>3\n","\n+++j\n","\na=x>y?x:y\n","\nx%=4\n"],"correct_choice":"\n+++j\n"},{"title":"  已知 boolean result ，则下面哪个选项是合法的：  ","choices":["\nresult=1\n","\nresult=true;\n","\nif(result!=0) {//so something…}\n","\nif(result) {//do something…}\n"],"correct_choice":"\nresult=true;\n\nif(result) {//do something…}\n"},{"title":"下面哪些情况下需要使用抽象类？","choices":["\n当一个类的一个或多个方法是抽象方法时\n","\n当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法体时\n","\n当一个类实现多个接口时\n","\n当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时\n"],"correct_choice":"\n当一个类的一个或多个方法是抽象方法时\n\n当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法体时\n\n当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时\n"},{"title":"\n  下列关于JAVA多线程的叙述正确的是（）\n","choices":["\n调用start()方法和run()都可以启动一个线程\n","\nCyclicBarrier和CountDownLatch都可以让一组线程等待其他线程\n","\nCallable类的call()方法可以返回值和抛出异常\n","\n新建的线程调用start()方法就能立即进行运行状态\n"],"correct_choice":"\nCyclicBarrier和CountDownLatch都可以让一组线程等待其他线程\n\nCallable类的call()方法可以返回值和抛出异常\n"},{"title":"\n  程序Demo.java编译运行后输出的结果是：( )\n\n\n  P\n  ublic class demo\n\n\n  I\n  nt x=1；\n\n\n  I\n  nt y；\n\n\n  P\n  ublic static void main（String args[]）\n\n\n  I\n  nt z=2;\n\n\n  D\n  emo t=new Demo();\n\n\n   System.out.printin(t.x+t.y+z);\n","choices":["\n3\n","\n12\n","\n1\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"   以下定义一维数组的语句中，正确的是：（）  ","choices":["\nint a [10]\n","\nint a []=new [10]\n","\nint  a[]\nint a []=new int [10]\n","\nint a []={1,2,3,4,5}\n"],"correct_choice":"\nint a []={1,2,3,4,5}\n"},{"title":"已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？","choices":["\nm. length()\n","\nm. length-1\n","\nm. length()+1\n","\nm. length+1\n"],"correct_choice":"\nm. length-1\n"},{"title":"\n  下列描述中，错误的是（\n  ）\n","choices":["\njava要求编程者管理内存\n","\njava的安全性体现在多个层次上\n","\njava中没有指针机制\n","\njava有多线程机制\n"],"correct_choice":"\njava要求编程者管理内存\n"},{"title":"  顺序执行下列程序语句后，则b的值是（） \n  String a=\"Hello\"; \n  String b=a.substring(0,2); \n\n  \n","choices":["\nHello\n","\nHel\n","\nHe\n","\nnull\n"],"correct_choice":"\nHe\n"},{"title":"\n  关于对象成员占用内存的说法哪个正确？（\n  ）\n\n\n  \n","choices":["\n同一个类的对象共用同一段内存\n","\n同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间\n","\n对象的方法不占用内存\n","\n以上都不对\n"],"correct_choice":"\n同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间\n"},{"title":"  下列关于管道（Pipe）通信的叙述中，正确的是（）？ ","choices":["\n进程对管道进行读操作和写操作都可能被阻塞\n","\n一个管道只能有一个进程或一个写进程对其操作\n","\n一个管道可实现双向数据传输\n","\n管道的容量仅受磁盘容量大小限制\n"],"correct_choice":"\n进程对管道进行读操作和写操作都可能被阻塞\n"},{"title":"java语言中，按照一定格式生成程序的文档的工具是？","choices":["\njavac\n","\njavah\n","\njavadoc\n","\njar\n"],"correct_choice":"\njavadoc\n"},{"title":"下列说法正确的是","choices":["\njava中包的主要作用是实现跨平台功能\n","\npackage语句只能放在import语句后面\n","\n包（package）由一组类（class）和接口（interface）组成\n","\n可以用#include关键词来标明来自其它包中的类\n"],"correct_choice":"\n包（package）由一组类（class）和接口（interface）组成\n"},{"title":"Thread. sleep()是否会抛出checked exception?","choices":["\n会\n","\n不会\n"],"correct_choice":"\n会\n"},{"title":"  What results from the following code fragment? \nint i = 5;\nint j = 10;\nSystem.out.println(i + ~j);\n\n","choices":["\nCompilation error because”~”doesn’t operate on integers\n","\n-5\n","\n-6\n","\n15\n"],"correct_choice":"\n-6\n"},{"title":"以下声明合法的是","choices":["\ndefault  String  s\n","\npublic  final  static  native  int  w( )\n","\nabstract  double  d\n","\nabstract  final  double  hyperbolicCosine( )\n"],"correct_choice":"\npublic  final  static  native  int  w( )\n"},{"title":"下面有关java类加载器，说法正确的是？","choices":["\n引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的\n","\n扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。\n","\n系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类\n","\ntomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用\n"],"correct_choice":"\n引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的\n\n扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。\n\n系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类\n\ntomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用\n"},{"title":"java中关于继承的描述正确的是（）","choices":["\n一个子类只能继承一个父类\n","\n子类可以继承父类的构造方法\n","\n继承具有传递性\n","\n父类一般具有通用性，子类更具体\n"],"correct_choice":"\n一个子类只能继承一个父类\n\n继承具有传递性\n\n父类一般具有通用性，子类更具体\n"},{"title":"  下面属于JSP内置对象的是？ ","choices":["\nout对象\n","\nresponse对象\n","\napplication对象\n","\npage对象\n"],"correct_choice":"\nout对象\n\nresponse对象\n\napplication对象\n\npage对象\n"},{"title":"以下哪些类是线程安全的（）","choices":["\nVector\n","\nHashMap\n","\nArrayList\n","\nStringBuffer\n","\nProperties\n"],"correct_choice":"\nVector\n\nStringBuffer\n\nProperties\n"},{"title":"\n  根据以下代码段,执行new Child(\"John\", 10); 要使数据域data得到10，则子类空白处应该填写(    )。\n\n\n  \n    \n      \n          class Parent {\n        \n        \n               private int data;\n        \n        \n               public Parent(int d){ data = d; }\n        \n        \n          }\n        \n        \n          class Child   extends Parent{\n        \n        \n               String name;\n        \n        \n               public Child(String s, int d){\n        \n        \n                   ___________________\n        \n        \n                   name = s;\n        \n        \n               }\n        \n        \n          }\n        \n      \n  \n","choices":["\ndata = d;\n","\nsuper.data = d;\n","\nParent(d);\n","\nsuper(d);\n"],"correct_choice":"\nsuper(d);\n"},{"title":"\n  对抽象类的描述正确的是()\n","choices":["\n抽象类的方法都是抽象方法\n","\n一个类可以继承多个抽象类\n","\n抽象类不能有构造方法\n","\n抽象类不能被实例化\n"],"correct_choice":"\n抽象类不能被实例化\n"},{"title":"\n  一个类可以有多个不同名的构造函数\n  。（\n  ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  在\n  applet\n  的方法中\n  ,\n  可关闭小应用程序并释放其占用资源的是（\n  ）\n","choices":["\nstop()\n","\npaint()\n","\ninit()\n","\ndestroy()\n"],"correct_choice":"\ndestroy()\n"},{"title":"\n  下列代码的执行结果是：（\n  ）\n  \n    \n  \n\npublic class Test3{\n public static void main(String args[]){\n    System.out.println(100%3);\n    System.out.println(100%3.0);\n }\n}\n\n  \n","choices":["\n1和1\n","\n1和1.0\n","\n1.0和1\n","\n1.0和1.0\n"],"correct_choice":"\n1和1.0\n"},{"title":"下面属于java合法变量定义的是？","choices":["\nfinal\n","\n1var1\n","\n_var2\n","\nvar3&\n"],"correct_choice":"\n_var2\n"},{"title":"\n  以下\n  _____\n  不是\n  Object\n  类的方法\n","choices":["\nclone（）\n","\nfinalize()\n","\ntoString()\n","\nhasNext()\n"],"correct_choice":"\nhasNext()\n"},{"title":"  下面代码运行结果是（） \npublic class Test{\t\n    public int add(int a,int b){\t\n         try {\t\n             return a+b;\t\t\n         } \n        catch (Exception e) {\t\n            System.out.println(\"catch语句块\");\t\n         }\t\n         finally{\t\n             System.out.println(\"finally语句块\");\t\n         }\t\n         return 0;\t\n    } \n     public static void main(String argv[]){ \n         Test test =new Test(); \n         System.out.println(\"和是：\"+test.add(9, 34)); \n     }\n}\n","choices":["\ncatch语句块\n和是：43\n","\n编译异常\n","\nfinally语句块\n和是：43\n","\n和是：43\nfinally语句块\n"],"correct_choice":"\nfinally语句块\n和是：43\n"},{"title":"String str1 = “abc”，“abc”分配在内存哪个区域？","choices":["\n堆\n","\n栈\n","\n字符串常量区\n","\n寄存器\n"],"correct_choice":"\n字符串常量区\n"},{"title":"关于依赖注入，下列选项中说法错误的是（）","choices":["\n依赖注入能够独立开发各组件，然后根据组件间关系进行组装\n","\n依赖注入使组件之间相互依赖，相互制约\n","\n依赖注入提供使用接口编程\n","\n依赖注入指对象在使用时动态注入\n"],"correct_choice":"\n依赖注入使组件之间相互依赖，相互制约\n"},{"title":"  执行以下程序后的输出结果是（） \npublic class Test {\npublic static void main(String[] args) {\n    StringBuffer a = new StringBuffer(\"A\"); \n    StringBuffer b = new StringBuffer(\"B\"); \n    operator(a, b); \n    System.out.println(a + \",\" + b); \n} \npublic static void operator(StringBuffer x, StringBuffer y) { \n    x.append(y); y = x; \n}\n}\n","choices":["\nA,A\n","\nA,B\n","\nB,B\n","\nAB,B\n"],"correct_choice":"\nAB,B\n"},{"title":"  What will be printed when you execute the following code? \nclass C {\n    C() {\n        System.out.print(\"C\");\n    }\n}\n\nclass A {\n    C c = new C();\n\n    A() {\n        this(\"A\");\n        System.out.print(\"A\");\n    }\n\n    A(String s) {\n        System.out.print(s);\n    }\n}\n\nclass Test extends A {\n    Test() {\n        super(\"B\");\n        System.out.print(\"B\");\n    }\n\n    public static void main(String[] args) {\n        new Test();\n    }\n}\n\n","choices":["\nBB\n","\nCBB\n","\nBAB\n","\nNone of the above\n"],"correct_choice":"\nCBB\n"},{"title":"\n  在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）\n","choices":["\nthis.A(x)\n","\nthis(x)\n","\nsuper(x)\n","\nA(x)\n"],"correct_choice":"\nthis(x)\n"},{"title":"下面不是面向对象的基本原则的是？","choices":["\n单一职责原则（Single-Resposibility Principle）\n","\n开放封闭原则（Open-Closed principle）\n","\n抽象类原则（Abstract-Class principle）\n","\n依赖倒置原则（Dependecy-Inversion Principle）\n","\n接口隔离原则（Interface-Segregation Principle）\n"],"correct_choice":"\n抽象类原则（Abstract-Class principle）\n"},{"title":"下面哪些类实现或继承了\nCollection\n接口？","choices":["\nHashMap\n","\nArrayList\n","\nVector\n","\nIterator\n"],"correct_choice":"\nArrayList\n\nVector\n"},{"title":"  以下JSP代码定义了一个变量，如何输出这个变量的值？ \n  <bean:define id=\"stringBean\"\n  value=\"helloWorld\"/> ","choices":["\n<bean:write name=\"helloWorld\"/>\n","\n<%=stringBean%>\n","\n<bean:write name=\"stringBean\"/>\n","\n<%String myBean=(String)pageContext.getAttribute(\"stringBean\",PageContext.PAGE_SCOPE);%>\n<%=myBean%>\n"],"correct_choice":"\n<%=stringBean%>\n\n<bean:write name=\"stringBean\"/>\n\n<%String myBean=(String)pageContext.getAttribute(\"stringBean\",PageContext.PAGE_SCOPE);%>\n<%=myBean%>\n"},{"title":"\n  下列外部类定义中，不正确的是：（ \n   ）\n\n\n  \n","choices":["\nclass x { .... }\n","\nclass x extends y { .... }\n","\nstatic class x implements y1,y2 { .... }\n","\npublic class x extends Applet { .... }\n"],"correct_choice":"\nstatic class x implements y1,y2 { .... }\n"},{"title":" 可以把任何一种数据类型的变量赋给Object类型的变量。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"与InputStream流相对应的Java系统的“标准输入对象”是（）","choices":["\nSystem.in\n","\nSystem.out\n","\nSystem.err\n","\nSystem.exit()\n"],"correct_choice":"\nSystem.in\n"},{"title":"枚举（enum）属于原始数据类型（primitive type）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  关于java编译和运行命令叙述不正确的是？  (  )      ","choices":["\n运行“java Scut.class”\n","\n运行“java Scut”\n","\n运行“javac Scut.java”的输出文件是Scut.class\n","\njava这个命令的运行对象是Scut.class\n"],"correct_choice":"\n运行“java Scut.class”\n"},{"title":"  可以把任何一种数据类型的变量赋给Object类型的变量。  ","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"\n  以下哪个方法用于定义线程的执行体？\n   （）\n\n","choices":["\nstart()\n","\njoin()\n","\nrun()\n","\nsynchronized()\n"],"correct_choice":"\nrun()\n"},{"title":"  有时为了避免某些未识别的异常抛给更高的上层应用，在某些接口实现中我们通常需要捕获编译运行期所有的异常， catch 下述哪个类的实例才能达到目的：（）  ","choices":["\nError\n","\nException\n","\nRuntimeException\n","\nThrowable\n"],"correct_choice":"\nException\n"},{"title":"  以下程序的运行结果是（） \npublic class Increment\n{\n    public static void main(String args[])\n    {\n        int a;\n        a = 6;\n        System.out.print(a);\n        System.out.print(a++);\n        System.out.print(a);\n    }\n}\n\n","choices":["\n666\n","\n667\n","\n677\n","\n676\n"],"correct_choice":"\n667\n"},{"title":"\n  列表(List)和集合(Set)下面说法正确的是？  ( \n   )\n\n\n  \n","choices":["\nSet中至多只能有一个空元素\n","\nList中至多只能有一个空元素\n","\nList和Set都可以包含重复元素的有序集合\n","\nList和Set都是有序集合\n"],"correct_choice":"\nSet中至多只能有一个空元素\n"},{"title":"  关于抽象类与最终类，下列说法错误的是？ ","choices":["\n抽象类能被继承，最终类只能被实例化。\n","\n抽象类和最终类都可以被声明使用\n","\n抽象类中可以没有抽象方法，最终类中可以没有最终方法\n","\n抽象类和最终类被继承时，方法可以被子类覆盖\n"],"correct_choice":"\n抽象类和最终类被继承时，方法可以被子类覆盖\n"},{"title":"\n  下面的程序\n  编译运行后，在屏幕上显示的结果是（）\n\n\n   public class test {\n\n\n   public static void main(String args[]) {\n\n\n   int x,y;\n\n\n   x=5>>2;\n\n\n   y=x>>>2;\n\n\n   System.out.println(y);\n\n\n   }\n\n\n  }\n","choices":["\n0\n","\n2\n","\n5\n","\n80\n"],"correct_choice":"\n0\n"},{"title":"下列有关Thread的描述，哪个是正确的？","choices":["\n启动一个线程的方法是：thread. run()\n","\n结束一个线程的通常做法是：thread. stop()\n","\n将一个线程标记成daemon线程，意味着当主线程结束，并且没有其它正在运行的非daemon线程时，该daemon线程也会自动结束。\n","\n让一个线程等待另一个线程的通知的方法是：thread. sleep()\n"],"correct_choice":"\n将一个线程标记成daemon线程，意味着当主线程结束，并且没有其它正在运行的非daemon线程时，该daemon线程也会自动结束。\n"},{"title":"  经过强制类型转换以后，变量a，b的值分别为多少？ \nshort a =128；\nbyte b =(byte) a；\n","choices":["\n128  127\n","\n128 - 128\n","\n128  128\n","\n编译错误\n"],"correct_choice":"\n128 - 128\n"},{"title":"  int  i, sum=0; \n  for(i=0;i<10;++i,sum+=i); i 的最终结果是？ ","choices":["\n10\n","\n9\n","\n11\n","\n以上答案都不正确\n"],"correct_choice":"\n10\n"},{"title":"在类设计中，类的成员变量要求仅仅能够被同一package下的类访问，请问应该使用下列哪个修饰词（）","choices":["\nprotected\n","\npublic\n","\nprivate\n","\n不需要任何修饰词\n"],"correct_choice":"\n不需要任何修饰词\n"},{"title":"true、false、null、sizeof、goto、synchronized 哪些是Java关键字？","choices":["\ntrue\n","\nfalse\n","\nnull\n","\nsizeof\n","\ngoto\n","\nsynchronized\n"],"correct_choice":"\ngoto\n\nsynchronized\n"},{"title":"\n  如果要建立一个java.com.computer的包放入当前java类，下列叙述正确的是？  ( \n   )\n\n\n  \n","choices":["\n在代码中，不一定是第一句，只要是类定义前，加入package语句即可\n","\n只需在代码中加入“package java.com;”一个语句\n","\n必须在代码中加入“package java.com;”和“package java.com.computer;”两个语句\n","\n只需在代码中第一条非注释性语句加入“package java.com.computer;”\n"],"correct_choice":"\n只需在代码中第一条非注释性语句加入“package java.com.computer;”\n"},{"title":"下列的哪个选项可以正确用以表示八进制值8？（）","choices":["\n0×8\n","\n0×10\n","\n08\n","\n010\n"],"correct_choice":"\n010\n"},{"title":"\n  设有下面一段代码：\n\n\n  class  Student      extends  Person {\n\n\n   long    id;     // \n  身份证号\n\n\n   int  score;  // \n  入学总分\n\n\n   String  name;   // \n  姓名\n\n\n   int  getScore(){\n\n\n  return  score; \n  } \n\n   }\n\n\n  \n\n\n  问：类\n  Person\n  和类\n  Student\n  的关系是（\n  ）。\n","choices":["\n包含关系\n","\n继承关系\n","\n关联关系\n","\n无关系，上述类定义有语法错误\n"],"correct_choice":"\n继承关系\n"},{"title":"\n  当使包含\n  applet \n  程序的页面从最小化恢复时，以下选项中的哪个方法将被执行？（\n  \n    \n      \n    \n  \n  ）\n","choices":["\npaint()\n","\nstart()\n","\ndestroy()\n","\nstop()\n"],"correct_choice":"\npaint()\n"},{"title":"\n  下面关于Java类的构造方法的说法中正确的是：（ ）\n","choices":["\n一个类至少有一个构造方法\n","\n构造方法的返回值类型必须是void\n","\n构造方法的可见性修饰符必须是public\n","\n构造方法必须显式的定义\n"],"correct_choice":"\n一个类至少有一个构造方法\n"},{"title":"\n  关于final说法正确的是？  ( \n   )\n\n\n  \n","choices":["\nfinal类的方法肯定不能被同一个包的类访问\n","\nfinal类的方法能否被同一个包的类访问不是由final决定\n","\nfinal方法等同于private方法\n","\nfinal对象本身的引用和值都不能改变\n"],"correct_choice":"\nfinal类的方法能否被同一个包的类访问不是由final决定\n"},{"title":"以下代码执行后输出结果为（      ）\npublic class ExceptionTest\n{\n    public void method()\n    {\n        try\n        {\n            System.out.println(\"进入到try块\");\n        }\n        catch (Exception e)\n        {\n             System.out.println(\"异常发生了！\");\n        }\n        finally\n        {\n            System.out.println(\"进入到finally块\");\n        }\n            System.out.println(\"后续代码\");\n }\n     public static void main(String[] args)\n     {\n         ExceptionTest test = new ExceptionTest();\n         test.method();\n     }\n }","choices":["\n进入到try块  异常发生了！  进入到finally块  后续代码\n","\n进入到try块  进入到finally块  后续代码\n","\n进入到try块  后续代码\n","\n异常发生了！  后续代码\n"],"correct_choice":"\n进入到try块  进入到finally块  后续代码\n"},{"title":"  当你编译和运行下面的代码时，会出现下面选项中的哪种情况？   public class Pvf{\n            static boolean Paddy;\n        public static void main(String args[]){\n            System.out.println(Paddy);\n        }\n}    ","choices":["\n编译时错误\n","\n编译通过并输出结果false\n","\n编译通过并输出结果true\n","\n编译通过并输出结果null\n"],"correct_choice":"\n编译通过并输出结果false\n"},{"title":"以下代码执行后输出结果为（      ）\npublic class Test { \n    public static void main(String[] args) { \n        System.out.println(\"return value of getValue(): \" +\n        getValue()); \n    } \n     public static int getValue() { \n         try { \n             return 0; \n         } finally { \n             return 1; \n         } \n     } \n }","choices":["\nreturn value of getValue(): 1\n","\nreturn value of getValue(): 0\n","\nreturn value of getValue(): 0return value of getValue(): 1\n","\nreturn value of getValue(): 1return value of getValue(): 0\n"],"correct_choice":"\nreturn value of getValue(): 1\n"},{"title":"关于HashMap与HashTable，以下说法错误的是（）","choices":["\n两者都是用key-value方式获取数据\n","\nHashtable允许null值作为key和value，而HashMap不可以\n","\nHashMap不是同步的，而Hashtable是同步的\n","\n迭代HashMap采用快速失败机制，而Hashtable不是\n"],"correct_choice":"\nHashtable允许null值作为key和value，而HashMap不可以\n"},{"title":"使用mvc模式设计的web应用程序具有以下优点,除了？","choices":["\n可维护行强\n","\n可扩展性强\n","\n代码重复少\n","\n大大减少代码量\n"],"correct_choice":"\n大大减少代码量\n"},{"title":"  When is the text “Hi there”displayed? \npublic class StaticTest\n{\n    static\n    {\n        System.out.println(“Hi there”);\n    }\n\n    public void print()\n    {\n        System.out.println(“Hello”);\n    }\n\n    public static void main(String args[])\n    {\n        StaticTest st1 = new StaticTest();\n        st1.print();\n        StaticTest st2 = new StaticTest();\n        st2.print();\n    }\n}\n\n","choices":["\nNever.\n","\nEach time a new object of type StaticTest is created.\n","\nOnce when the class is loaded into the Java virtual machine.\n","\nOnly when the main() method is executed.\n"],"correct_choice":"\nOnce when the class is loaded into the Java virtual machine.\n"},{"title":"下面程序的输出结果是？ package algorithms.com.guan.javajicu;  \npublic class TestDemo {  \n    public static String output =\"\";  \n    public static void foo(int i){  \n       try{  \n           if(i == 1){  \n              throw new Exception();  \n           }  \n       }catch(Exception e){  \n           output += \"2\";  \n           return ;  \n       }finally{  \n           output += \"3\";  \n       }  \n       output += \"4\";  \n    }  \n   \n    public static void main(String[] args) {  \n       foo(0);  \n       foo(1);  \n       System.out.println(output); \n    }  \n}  ","choices":["\n出错\n","\n342\n","\n34234\n","\n3423\n"],"correct_choice":"\n3423\n"},{"title":"下面有关servlet service描述错误的是？","choices":["\n不管是post还是get方法提交过来的连接，都会在service中处理\n","\ndoGet/doPost 则是在 javax.servlet.GenericServlet 中实现的\n","\nservice()是在javax.servlet.Servlet接口中定义的\n","\nservice判断请求类型，决定是调用doGet还是doPost方法\n"],"correct_choice":"\ndoGet/doPost 则是在 javax.servlet.GenericServlet 中实现的\n"},{"title":"  如果Child extends Parent，那么正确的有（）？ ","choices":["\n如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数\n","\n如果Child是interface，那么Parent必然是interface\n","\n如果Child是interface，那么Child可以同时extends Parent1，Parent2等多个interface\n","\n如果Child是class，并且没有显示声明任何构造函数，那么此时仍然会调用Parent的构造函数\n"],"correct_choice":"\n如果Child是interface，那么Parent必然是interface\n\n如果Child是interface，那么Child可以同时extends Parent1，Parent2等多个interface\n\n如果Child是class，并且没有显示声明任何构造函数，那么此时仍然会调用Parent的构造函数\n"},{"title":"Consider the following code:   String s=null; \n\n  Which code fragments cause an object of type NullPointerException to be thrown? ","choices":["\nif((s!=null)&(s.length()>0))\n","\nif((s!=null)&&(s.length()>0))\n","\nif((s==null)|(s.length()==0))\n","\nif((s==null)||(s.length()==0))\n"],"correct_choice":"\nif((s!=null)&(s.length()>0))\n\nif((s==null)|(s.length()==0))\n"},{"title":"对于构造方法，下列叙述正确的是（\n）。","choices":["\n构造方法的优先级一般比代码块低。\n","\n构造方法的返回类型只能是void型。\n","\n构造方法的主要作用是完成对类的对象的初始化工作。\n","\n一般在创建新对象时，系统会自动调用构造方法。\n"],"correct_choice":"\n构造方法的优先级一般比代码块低。\n\n构造方法的主要作用是完成对类的对象的初始化工作。\n\n一般在创建新对象时，系统会自动调用构造方法。\n"},{"title":"Which are keywords in Java?","choices":["\nnull\n","\ntrue\n","\nsizeof\n","\nimplements\n","\ninstanceof\n"],"correct_choice":"\nimplements\n\ninstanceof\n"},{"title":"Which statement declares a variable a which is suitable for referring to\nan array of 50 string objects?","choices":["\nchar a[][];\n","\nString a[];\n","\nString[] a;\n","\nObject a[50];\n","\nString a[50];\n","\nObject a[];\n"],"correct_choice":"\nString a[];\n\nString[] a;\n\nObject a[];\n"},{"title":"使用静态属性必须以类名做前缀。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"Java Applet在被浏览器加载的时候首先被执行且在applet整个生命周期中被运行一次的方法是（）","choices":["\ninit()\n","\nstop()\n","\nopreationcrawl()\n","\nreader()\n"],"correct_choice":"\ninit()\n"},{"title":"\n  下列修饰符中与访问控制权限无关的是？（ \n   ）\n\n\n  \n\n","choices":["\nprivate\n","\npublic\n","\nprotected\n","\nfinal\n"],"correct_choice":"\nfinal\n"},{"title":"\n  容器panel缺省使用的布局编辑策略是( )\n","choices":["\nBorder Layout\n","\nFlow Layout\n","\nGridLayout\n","\nCard Layout\n"],"correct_choice":"\nFlow Layout\n"},{"title":"一个以”.java”为后缀的源文件 ","choices":["\n只能包含一个类，类名必须与文件名相同\n","\n只能包含与文件名相同的类以及其中的内部类\n","\n只能有一个与文件名相同的public类，可以包含其他类\n","\n可以包含任意类\n"],"correct_choice":"\n只能有一个与文件名相同的public类，可以包含其他类\n"},{"title":"Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（）","choices":["\n\".*?(?=\\\\()\"\n","\n\".*?(?=\\()\"\n","\n\".*(?=\\\\()\"\n","\n\".*(?=\\()\"\n"],"correct_choice":"\n\".*?(?=\\\\()\"\n"},{"title":"下面有关java hashmap的说法错误的是？","choices":["\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。\n","\nHashMap 的实现不是同步的，意味着它不是线程安全的\n","\nHashMap通过开放地址法解决哈希冲突\n","\nHashMap中的key-value都是存储在Entry数组中的\n"],"correct_choice":"\nHashMap通过开放地址法解决哈希冲突\n"},{"title":"下面有关JAVA异常类的描述，说法错误的是？","choices":["\n异常的继承结构：基类为Throwable，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception\n","\n非RuntimeException一般是外部错误(非Error)，其必须被 try{}catch语句块所捕获\n","\nError类体系描述了Java运行系统中的内部错误以及资源耗尽的情形，Error不需要捕捉\n","\nRuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等，必须被 try{}catch语句块所捕获\n"],"correct_choice":"\nRuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等，必须被 try{}catch语句块所捕获\n"},{"title":"如何获取ServletContext设置的参数值？","choices":["\ncontext.getParameter()\n","\ncontext.getInitParameter()\n","\ncontext.getAttribute()\n","\ncontext.getRequestDispatcher()\n"],"correct_choice":"\ncontext.getInitParameter()\n"},{"title":"  下列说法正确的是（）？ ","choices":["\n对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们\n","\n成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）\n","\n由于匿名内部类只能用在方法内部，所以匿名内部类的用法与局部内部类是一致的\n","\n静态内部类可以访问外部类的成员变量\n"],"correct_choice":"\n对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们\n\n成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）\n"},{"title":"下面哪些类可以被继承？\nJava.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader","choices":["\nThread\n","\nNumber\n","\nDouble\n","\nMath\n","\nClassLoader\n"],"correct_choice":"\nThread\n\nNumber\n\nClassLoader\n"},{"title":"  下列有关JAVA异常处理的叙述中正确的是（）  ","choices":["\nfinally是为确保一段代码不管是否捕获异常都会被执行的一段代码\n","\nthrows是用来声明一个成员方法可能抛出的各种非运行异常情况\n","\nfinal用于可以声明属性和方法，分别表示属性的不可变及方法的不可继承\n","\nthrow是用来明确地抛出一个异常情况\n"],"correct_choice":"\nfinally是为确保一段代码不管是否捕获异常都会被执行的一段代码\n\nthrows是用来声明一个成员方法可能抛出的各种非运行异常情况\n\nthrow是用来明确地抛出一个异常情况\n"},{"title":"\n  有以下程序片段，下列哪个选项不能插入到行1。（    ）\n\n\n  \n    \n      \n          1.\n        \n        \n          2.public  class  Interesting{\n        \n        \n          3.   //\n          省略代码\n        \n        \n          4.}\n        \n      \n  \n","choices":["\nimport java.awt.*;\n","\npackage mypackage;\n","\nclass OtherClass{   }\n","\npublic class MyClass{ }\n"],"correct_choice":"\npublic class MyClass{ }\n"},{"title":"我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名。","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下列整形的最终属性i的定义中，正确的是（）","choices":["\nstatic final int i=100;\n","\nfinal i;\n","\nstatic int i;\n","\nfinal float i=1.2f;\n"],"correct_choice":"\nstatic final int i=100;\n"},{"title":"原生类中的数据类型均可任意转换。","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"Java中所有类的父类是（    ）。","choices":["\nFather\n","\nDang\n","\nException\n","\nObject\n"],"correct_choice":"\nObject\n"},{"title":"\n  覆盖（重写）与重载的关系是（）。\n","choices":["\n覆盖（重写）只有出现在父类与子类之间，而重载可以出现在同一个类中\n","\n覆盖（重写）方法可以有不同的方法名，而重载方法必须是相同的方法名\n","\nfinal修饰的方法可以被覆盖（重写），但不能被重载\n","\n覆盖（重写）与重载是同一回事\n"],"correct_choice":"\n覆盖（重写）只有出现在父类与子类之间，而重载可以出现在同一个类中\n"},{"title":"public boolean returnTest()\n{\n    try\n    {\n        return true;\n    }\n    catch (Exception e)\n    {\n\n    }\n    finally\n    {\n        return false;\n    }\n}\n\n  以下代码返回值是什么？","choices":["\ntrue\n","\nfalse\n"],"correct_choice":"\nfalse\n"},{"title":"  如下代码的 结果是什么 ?   class Base {\n    Base() {\n    System.out.print(\"Base\"); \n    }\n}\npublic class Alpha extends Base {\n    public static void main( String[] args ) {\n        new Alpha();\n        //调用父类无参的构造方法\n        new Base();\n    } \n} ","choices":["\nBase\n","\nBaseBase\n","\n编译失败\n","\n代码运行但没有输出\n","\n运行时抛出异常\n"],"correct_choice":"\nBaseBase\n"},{"title":"  下面代码的运行结果是（）  public static void main(String[] args){\n    String s;\n    System.out.println(\"s=\"+s);\n}    ","choices":["\n代码编程成功，并输出”s=”\n","\n代码编译成功，并输出”s=null”\n","\n由于String s没有初始化，代码不能编译通过。\n","\n代码编译成功，但捕获到NullPointException异常\n"],"correct_choice":"\n由于String s没有初始化，代码不能编译通过。\n"},{"title":"\n  选项中哪一行代码可以替换\n  //add code here\n  而不产生编译错误\n\npublic abstract class MyClass {\n     public int constInt = 5;\n     //add code here\n     public void method() {\n     } \n\n  }\n  \n    \n  \n","choices":["\npublic abstract void method(int a);\n","\nconsInt=constInt+5;\n","\npublic int method();\n","\npublic abstract void anotherMethod(){}\n"],"correct_choice":"\npublic abstract void method(int a);\n"},{"title":"以下代码执行后输出结果为（      ）\npublic class Test\n{\n    public static Test t1 = new Test();\n    {\n         System.out.println(\"blockA\");\n    }\n    static\n    {\n        System.out.println(\"blockB\");\n    }\n    public static void main(String[] args)\n    {\n        Test t2 = new Test();\n    }\n }\n","choices":["\nblockAblockBblockA\n","\nblockAblockAblockB\n","\nblockBblockBblockA\n","\nblockBblockAblockB\n"],"correct_choice":"\nblockAblockBblockA\n"},{"title":"下面那些情况可以终止当前线程的运行？","choices":["\n当一个优先级高的线程进入就绪状态时\n","\n抛出一个异常时\n","\n当该线程调用sleep()方法时\n","\n当创建一个新线程时\n"],"correct_choice":"\n抛出一个异常时\n"},{"title":"下面关于Spring的说法中错误的是（）","choices":["\nSpring是一系列轻量级Java EE框架的集合\n","\nSpring中包含一个“依赖注入”模式的实现\n","\n使用Spring可以实现声明式事务\n","\nSpring提供了AOP方式的日志系统\n"],"correct_choice":"\nSpring提供了AOP方式的日志系统\n"},{"title":"\n  jre\n  判断程序是否执行结束的标准是（）\n","choices":["\n所有的前台线程执行完毕\n","\n所有的后台线程执行完毕\n","\n所有的线程执行完毕\n","\n和以上都无关\n"],"correct_choice":"\n所有的前台线程执行完毕\n"},{"title":"  以下程序的输出结果为  class Base{\n    public Base(String s){\n        System.out.print(\"B\");\n    }\n}\npublic class Derived extends Base{\n    public Derived (String s) {\n        System.out.print(\"D\");\n    }\n    public static void main(String[] args){\n        new Derived(\"C\");\n    }\n}    ","choices":["\nBD\n","\nDB\n","\nC\n","\n编译错误\n"],"correct_choice":"\n编译错误\n"},{"title":"在java中重写方法应遵循规则的包括（）","choices":["\n访问修饰符的限制一定要大于被重写方法的访问修饰符\n","\n可以有不同的访问修饰符\n","\n参数列表必须完全与被重写的方法相同\n","\n必须具有不同的参数列表\n"],"correct_choice":"\n可以有不同的访问修饰符\n\n参数列表必须完全与被重写的方法相同\n"},{"title":"ArrayLists和LinkedList的区别，下述说法正确的有？","choices":["\nArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。\n","\n对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。\n","\n对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。\n","\nArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。\n"],"correct_choice":"\nArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。\n\n对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。\n\n对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。\n\nArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。\n"},{"title":"下列语句哪一个是不正确的（）","choices":["\nLog4j支持按分钟为间隔生成新的日志文件\n","\nLog4j是一个打印日志用的组件\n","\nLog4j支持按年为间隔生成新的日志文件\n","\nLog4j的日志打印级别可以在运行时重新设置\n"],"correct_choice":"\nLog4j的日志打印级别可以在运行时重新设置\n"},{"title":"\n  编译Java  Application\n      源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为(      )。\n","choices":["\njava\n","\nclass\n","\nhtml\n","\nexe\n"],"correct_choice":"\nclass\n"},{"title":"\n  abstract和final可以同时作为一个类的修饰符。（  ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n   以下说法正确的是（    ）。\n","choices":["\nJava中所有的方法都必须在类内定义\n","\nJava中主方法可以不在类内定义，其他方法都必须定义在类内\n","\nJava中主方法必须定义在类内，其他方法可以不必定义在类内\n","\nJava中所有方法都不必在类内定义\n"],"correct_choice":"\nJava中所有的方法都必须在类内定义\n"},{"title":"  不允许作为类及类成员的访问控制符的是(      )。（不考虑内部类的情况） ","choices":["\npublic\n","\nprivate\n","\nstatic\n","\nprotected\n"],"correct_choice":"\nstatic\n"},{"title":"  下列关于修饰符混用的说法，错误的是( )  ","choices":["\nabstract不能与final并列修饰同一个类\n","\nabstract类中不应该有private的成员\n","\nabstract方法必须在abstract类或接口中\n","\nstatic方法中能处理非static的属性\n"],"correct_choice":"\nstatic方法中能处理非static的属性\n"},{"title":"在程序代码中写的注释太多，会使编译后的程序尺寸变大。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  在java的一个异常处理中，可以包含多个的语句块是\n  （\n  ）。\n","choices":["\ntry\n","\nfinally\n","\nthrows\n","\ncatch\n"],"correct_choice":"\ncatch\n"},{"title":"在Web应用程序的文件与目录结构中，web.xml是放置在(    )中。","choices":["\nWEB-INF目录\n","\nconf目录\n","\nlib目录\n","\nclasses目录\n"],"correct_choice":"\nWEB-INF目录\n"},{"title":"\n  下列哪些语句关于\n  java\n  内存回收的说明是正确的？\n","choices":["\n程序员必须创建一个线程来释放内存\n","\n内存回收程序负责释放无用内存\n","\n内存回收程序允许程序员直接释放内存\n","\n内存回收程序可以在指定的时间释放内存对象\n"],"correct_choice":"\n内存回收程序负责释放无用内存\n"},{"title":"  关键字super的作用是？ ","choices":["\n用来访问父类被隐藏的非私有成员变量\n","\n用来调用父类中被重写的方法\n","\n用来调用父类的构造函数\n","\n以上都是\n"],"correct_choice":"\n以上都是\n"},{"title":"For which of these values of a\n I. 4\n II.6\n III. 8\n is the expression\n (a != 3 && a != 4 && a != 5 && a != 6)\n false? ","choices":["\nI only\n","\nII only\n","\nIII only\n","\nI and II only\n","\nI， II， and III\n"],"correct_choice":"\nI and II only\n"},{"title":"事务隔离级别是由谁实现的？","choices":["\nJava应用程序\n","\nHibernate\n","\n数据库系统\n","\nJDBC驱动程序\n"],"correct_choice":"\n数据库系统\n"},{"title":"  假设有以下代码 \n    String s = \"hello\";\n    String t = \"hello\";\n    char c[] = {'h', 'e', 'l', 'l', 'o'};\n\n  下列选项中返回false的语句是： ","choices":["\ns.equals(t);\n","\nt.equals(c);\n","\ns==t;\n","\nt.equals(new String (\"hello\"));\n"],"correct_choice":"\nt.equals(c);\n"},{"title":"HashMap和HashTable的描述，错误的是？","choices":["\n他们都实现了Map接口。\n","\nHashMap非线程安全，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供额外同步。\n","\nHashMap允许将null作为一个entry的key或者value，而Hashtable不允许。\n","\n通过contains方法可以判断一个对象是否存在于HashMap或者Hashtable中。\n"],"correct_choice":"\n通过contains方法可以判断一个对象是否存在于HashMap或者Hashtable中。\n"},{"title":"哪个是不正确的字符常量？","choices":["\n”\\n”\n","\n”1”\n","\n”a”\n","\n”\\101”\n"],"correct_choice":"\n”\\n”\n\n”1”\n\n”a”\n\n”\\101”\n"},{"title":"下面有关 java 类加载器,说法正确的是?()","choices":["\n引导类加载器(bootstrap class loader):它用来加载 Java 的核心库,是用原生代码来实现的\n","\n扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。\n","\n系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类\n","\ntomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用\n"],"correct_choice":"\n引导类加载器(bootstrap class loader):它用来加载 Java 的核心库,是用原生代码来实现的\n\n扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。\n\n系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类\n\ntomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用\n"},{"title":"下列说法正确的是（）","choices":["\nJAVA程序的main方法必须写在类里面\n","\nJAVA程序中可以有多个名字为main方法\n","\nJAVA程序中类名必须与文件名一样\n","\nJAVA程序的main方法中，如果只有一条语句，可以不用{}（大括号）括起来\n"],"correct_choice":"\nJAVA程序的main方法必须写在类里面\n\nJAVA程序中可以有多个名字为main方法\n"},{"title":"                    存根（Stub）与以下哪种技术有关                                                        ","choices":["\n交换\n","\n动态链接\n","\n动态加载\n","\n磁盘调度\n"],"correct_choice":"\n动态链接\n"},{"title":"\n  设有定义\n  int a=3\n  ，b=4，c=5；\n  则以下的表达式中\n  ，\n  值为\n  false\n  的是 （） ","choices":["\na < b && b < c\n","\na <= b\n","\na < ( b + c )\n","\n! ( a < b )\n"],"correct_choice":"\n! ( a < b )\n"},{"title":"以下有关构造方法的说法，正确的是：（）","choices":["\n一个类的构造方法可以有多个\n","\n构造方法在类定义时被调用\n","\n构造方法只能由对象中的其他方法调用\n","\n构造方法可以和类同名，也可以和类名不同\n"],"correct_choice":"\n一个类的构造方法可以有多个\n"},{"title":"\n  下列关于异常处理的描述中，错误的是()。\n","choices":["\n程序运行时异常由Java虚拟机自动进行处理\n","\n使用try-catch-finally语句捕获异常\n","\n使用throw语句抛出异常\n","\n捕获到的异常只能在当前方法中处理，不能在其他方法中处理\n"],"correct_choice":"\n捕获到的异常只能在当前方法中处理，不能在其他方法中处理\n"},{"title":"只有实现了()接口的类，其对象才能序列化。","choices":["\nSerializable\n","\nCloneable\n","\nComparable\n","\nWriteable\n"],"correct_choice":"\nSerializable\n"},{"title":"\n  下列在Java语言中关于数据类型和包装类的说法，正确的是（）\n","choices":["\n基本（简单）数据类型是包装类的简写形式，可以用包装类替代基本（简单）数据类型\n","\nlong和double都占了64位（64bit）的存储空间。\n","\n默认的整数数据类型是int，默认的浮点数据类型是float。\n","\n和包装类一样，基本（简单）数据类型声明的变量中也具有静态方法，用来完成进制转化等。\n"],"correct_choice":"\nlong和double都占了64位（64bit）的存储空间。\n"},{"title":"\n  关于static说法不正确的是（ \n   ）\n\n\n  \n","choices":["\n可以直接用类名来访问类中静态方法(public权限)\n","\n静态块仅在类加载时执行一次\n","\nstatic方法就是没有this的方法\n","\n不可以用对象名来访问类中的静态方法(public权限)\n"],"correct_choice":"\n不可以用对象名来访问类中的静态方法(public权限)\n"},{"title":"下列选项中属于面向对象设计方法主要特征的是（\n）。","choices":["\n继承\n","\n自顶向下\n","\n模块化\n","\n逐步求精\n"],"correct_choice":"\n继承\n"},{"title":"java中关于内存回收的正确说法是\n","choices":["\n程序员必须创建一个线程来释放内存\n","\n内存回收程序负责释放无用内存\n","\n内存回收程序允许程序员直接释放内存\n","\n内存回收程序可以在指定的时间释放内存对象\n"],"correct_choice":"\n内存回收程序负责释放无用内存\n"},{"title":"如何放掉一个指定占据的内存空间？（）","choices":["\n调用free()方法\n","\n代用system.gc()方法\n","\n赋值给该项对象的引用为null\n","\n程序员无法明确强制垃圾回收器运行\n"],"correct_choice":"\n程序员无法明确强制垃圾回收器运行\n"},{"title":"  以下java程序代码，执行后的结果是（） \njava.util.HashMap map=new java.util.HashMap();\t\nmap.put(\"name\",null);\t\t\nmap.put(\"name\",\"Jack\");\t\nSystem.out.println(map.size());\n","choices":["\n0\n","\nnull\n","\n1\n","\n2\n"],"correct_choice":"\n1\n"},{"title":"下面哪一项不是加载驱动程序的方法？","choices":["\n通过DriverManager.getConnection方法加载\n","\n调用方法 Class.forName\n","\n通过添加系统的jdbc.drivers属性\n","\n通过registerDriver方法注册\n"],"correct_choice":"\n通过DriverManager.getConnection方法加载\n"},{"title":"  关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法错误的是（ ）？ ","choices":["\n它负责处理HTTP请求\n","\n加载配置文件\n","\n实现业务操作\n","\n初始化上下应用对象ApplicationContext\n"],"correct_choice":"\n实现业务操作\n"},{"title":"static String str0=\"0123456789\";\nstatic String str1=\"0123456789\";\nString str2=str1.substring(5);\nString str3=new String(str2);\nString str4=new String(str3.toCharArray());\nstr0=null;\n  假定str0,...,str4后序代码都是只读引用。\n  Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）","choices":["\n5\n","\n10\n","\n15\n","\n20\n"],"correct_choice":"\n15\n"},{"title":"\n  在\n  hibernate\n  开发中，关于\n  POJO\n  类对象的状态说法正确的是（）。\n","choices":["\n自由状态（Transient）：实体在内存中自由存在，与数据库中的记录无关\n","\n持久状态（Persistent）：实体处于由Hibernate框架所管理的状态，对应了数据库中的一条记录，同时与某个session实例发生了关联\n","\n游离状态（Detached）：在session 关闭之后,可以使对象从持久状态转换到游离状态。\n","\n不能将对象从游离状态转换成持久态\n"],"correct_choice":"\n自由状态（Transient）：实体在内存中自由存在，与数据库中的记录无关\n\n持久状态（Persistent）：实体处于由Hibernate框架所管理的状态，对应了数据库中的一条记录，同时与某个session实例发生了关联\n\n游离状态（Detached）：在session 关闭之后,可以使对象从持久状态转换到游离状态。\n"},{"title":"What might cause the current thread to stop executing","choices":["\nAn InterruptedException is thrown.\n","\nThe thread executes a wait() call.\n","\nThe thread constructs a new Thread.\n","\nA thread of higher priority becomes ready.\n","\nThe thread executes a waitforID()call on a MediaTracker.\n"],"correct_choice":"\nAn InterruptedException is thrown.\n\nThe thread executes a wait() call.\n\nThe thread executes a waitforID()call on a MediaTracker.\n"},{"title":"\n  下面赋值语句中正确的是（）\n","choices":["\ndouble d=5.3e12;\n","\nfloat f=11.1;\n","\nint i=0.0;\n","\nDouble oD=3;\n"],"correct_choice":"\ndouble d=5.3e12;\n"},{"title":"\n   关于Java语言中的final关键字的使用，下列说法正确的是（）\n","choices":["\n在使用final关键字定义的方法里面使用final关键字定义变量。\n","\n使用final关键字定义变量，必须在变量定义的同时给定变量的具体数值，完成变量初始化。\n","\nfinal关键字可以用来修饰方法，表明此方法不可以被子类重写。\n","\n使用final关键字定义变量，必须同时使用static关键字。\n"],"correct_choice":"\nfinal关键字可以用来修饰方法，表明此方法不可以被子类重写。\n"},{"title":"\n  下列对接口的说法，正确的是( )\n","choices":["\n接口与抽象类是相同的概念\n","\n若要实现一个接口为普通类则必须实现接口的所有方法\n","\n接口之间不能有继承关系\n","\n一个类只能实现一个接口\n"],"correct_choice":"\n若要实现一个接口为普通类则必须实现接口的所有方法\n"},{"title":"  指出以下程序运行的结果是    public class Example{\n    String str=new String(\"good\");\n    char[]ch={'a','b','c'};\n    public static void main(String args[]){\n        Example ex=new Example();\n        ex.change(ex.str,ex.ch);\n        System.out.print(ex.str+\" and \");\n        System.out.print(ex.ch);\n    }\n    public void change(String str,char ch[]){\n   //引用类型变量，传递的是地址，属于引用传递。\n        str=\"test ok\";\n        ch[0]='g';\n    }\n}  ","choices":["\ngood and abc\n","\ngood and gbc\n","\ntst ok and abc\n","\ntst ok and gbc\n"],"correct_choice":"\ngood and gbc\n"},{"title":"关于类的叙述正确的是（）。","choices":["\n在类中定义的变量称为类的成员变量，在别的类中可以直接使用\n","\n局部变量的作用范围仅仅在定义它的方法内，或者是在定义它的控制流块中\n","\n使用别的类的方法仅仅需要引用方法的名字即可\n","\n只要没有定义不带参数的构造函数，JVM都会为类生成一个默认构造函数\n"],"correct_choice":"\n局部变量的作用范围仅仅在定义它的方法内，或者是在定义它的控制流块中\n"},{"title":"  关于以下程序代码的说明正确的是? \n\n  1.   public class HasStatic{\n2.     private static int x=100;\n3.     public static void main(String args[]){\n4.          HasStatic hs1=new HasStatic();\n5.          hs1.x++;\n6.          HasStatic  hs2=new HasStatic();\n7.          hs2.x++;\n8.          hs1=new HasStatic();\n9.          hs1.x++;\n10.        HasStatic.x--;\n11.        System.out.println(\"x=\"+x);\n12.     }\n13.   } \n  \n","choices":["\n程序通过编译，输出结果为：x=103\n","\n10行不能通过编译，因为x是私有静态变量\n","\n5行不能通过编译，因为引用了私有静态变量\n","\n程序通过编译，输出结果为：x=102\n"],"correct_choice":"\n程序通过编译，输出结果为：x=102\n"},{"title":"下列描述中，错误的是","choices":["\nSQL语言又称为结构化查询语言\n","\njava中”static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问\n","\n面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对象所做的改变不会反映到所引用的对象上\n","\njava是强类型语言，javascript是弱类型语言\n","\n面向对象的三大特性包括：封装，继承，多态\n"],"correct_choice":"\n面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对象所做的改变不会反映到所引用的对象上\n"},{"title":"public interface IService {String NAME=\"default\";}\n  默认类型等价表示是哪一项: ","choices":["\npublic String NAME=\"default\";\n","\npublic static String NAME=\"default\";\n","\npublic static final String NAME=\"default\";\n","\nprivate String NAME=\"default\";\n"],"correct_choice":"\npublic static final String NAME=\"default\";\n"},{"title":"下列不属于Java语言性特点的是","choices":["\nJava致力于检查程序在编译和运行时的错误\n","\nJava能运行虚拟机实现跨平台\n","\nJava自己操纵内存减少了内存出错的可能性\n","\nJava还实现了真数组，避免了覆盖数据类型的可能\n"],"correct_choice":"\nJava还实现了真数组，避免了覆盖数据类型的可能\n"},{"title":"下面有关java object默认的基本方法，说法错误的是？","choices":["\nequals(Object obj) 指示某个其他对象是否与此对象“相等”\n","\ncopy() 创建并返回此对象的一个副本\n","\nwait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法\n","\ntoString() 返回该对象的字符串表示\n"],"correct_choice":"\ncopy() 创建并返回此对象的一个副本\n"},{"title":"关于JSP生命周期的叙述，下列哪些为真?","choices":["\nJSP会先解释成Servlet源文件，然后编译成Servlet类文件\n","\n每当用户端运行JSP时，jsp init()方法都会运行一次\n","\n每当用户端运行JSP时，jsp service()方法都会运行一次\n","\n每当用户端运行JSP时，jsp destroy()方法都会运行一次\n"],"correct_choice":"\nJSP会先解释成Servlet源文件，然后编译成Servlet类文件\n\n每当用户端运行JSP时，jsp service()方法都会运行一次\n"},{"title":"  以下代码执行的结果显示是多少（ ）？        ","choices":["\ntrue,false,true\n","\nalse,true,false\n","\ntrue,true,false\n","\nfalse,false,true\n"],"correct_choice":"\nfalse,false,true\n"},{"title":"\n  将类的成员的访问权限设置为默认的，则该成员能被( )\n","choices":["\n同一包中的类访问\n","\n其它包中的类访问\n","\n所有的类访问\n","\n所有的类的子类访问\n"],"correct_choice":"\n同一包中的类访问\n"},{"title":"下列InputStream类中哪个方法可以用于关闭流？","choices":["\nskip（）\n","\nclose（）\n","\nmark（）\n","\nreset（）\n"],"correct_choice":"\nclose（）\n"},{"title":"\n  以下的变量定义语句中，合法的是（）\n","choices":["\nbyte=128\n","\nboolean=null\n","\nlong a=123L\n","\ndouble=0.9239d\n"],"correct_choice":"\nlong a=123L\n"},{"title":"  关于异常的编程，以下描述错误的是：（ ）  ","choices":["\n在有除法存在的代码处，抛不抛出异常均可\n","\nint i=Integer.parseInt(”123a”);将产生NumberFormatException\n","\nint a[]=null; a[0]=1; 将产生ArraylndexOutOfBoundsException\n","\n输入输出流编程中，读和写时都必须抛出IOException\n"],"correct_choice":"\nint a[]=null; a[0]=1; 将产生ArraylndexOutOfBoundsException\n"},{"title":"下列程序执行后结果为(      )\n class A {\n     public int func1(int a, int b) {\n         return a - b;\n     }\n }\n class B extends A {\n     public int func1(int a, int b) {\n         return a + b;\n     }\n }\n public class ChildClass {\n     public static void main(String[] args) {\n     A a = new B();\n     B b = new B();\n     System.out.println(\"Result=\" + a.func1(100, 50));\n     System.out.println(\"Result=\" + b.func1(100, 50));\n     }\n }","choices":["\nResult=150Result=150\n","\nResult=100Result=100\n","\nResult=100Result=150\n","\nResult=150Result=100\n"],"correct_choice":"\nResult=150Result=150\n"},{"title":"  阅读下列程序，选择哪一个是正确的输出结果 \nclass HelloA{\npublic HelloA()\n    {\n        System.out.println(\"I’m A class \");\n    }\n    static\n    {\n    System.out.println(\"static A\");\n    }\n}\npublic class HelloB extends HelloA{\n    public HelloB()\n    {\n        System.out.println(\"I’m B class\");\n    }\n    static{\n        System.out.println(\"static B\");\n    }\n    public static void main (String[] args){\n        new HelloB();\n    }\n}","choices":["\nstatic A I’m A class static B I’m B class\n","\nI’m A class I’m B class static A static B\n","\nstatic A static B I’m A class I’m B class\n","\nI’m A class static A I’m B class static B\n"],"correct_choice":"\nstatic A static B I’m A class I’m B class\n"},{"title":"  java中下面哪个能创建并启动线程（） \npublic class MyRunnable implements Runnable          { \n     public void run()             { \n         //some code here \n     } \n }","choices":["\nnew Runnable(MyRunnable).start()\n","\nnew Thread(MyRunnable).run()\n","\nnew Thread(new MyRunnable()).start()\n","\nnew MyRunnable().start()\n"],"correct_choice":"\nnew Thread(new MyRunnable()).start()\n"},{"title":"选项中哪一行代码可以添加\n 到题目中而不产生编译错误？\npublic abstract class MyClass {\n     public int constInt = 5;\n     //add code here\n     public void method() {\n     }\n}\n","choices":["\npublic abstract void method(int a);\n","\nconstInt = constInt + 5;\n","\npublic int method();\n","\npublic abstract void anotherMethod() {}\n"],"correct_choice":"\npublic abstract void method(int a);\n"},{"title":"\n  阅读如下代码。\n  请问，对语句行\n  test.hello().\n  描述正确的有（）\n\n\n  package NowCoder;\nclass Test {\n\tpublic static void hello() {\n\t    System.out.println(\"hello\");\n\t}\n}\npublic class MyApplication {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tTest test=null;\n\t\ttest.hello();\n\t}\n}\n  \n    \n  \n","choices":["\n能编译通过，并正确运行\n","\n因为使用了未初始化的变量，所以不能编译通过\n","\n以错误的方式访问了静态方法\n","\n能编译通过，但因变量为null，不能正常运行\n"],"correct_choice":"\n能编译通过，并正确运行\n"},{"title":"以下哪一个不是赋值符号？","choices":["\n+=\n","\n<<=\n","\n<<<=\n","\n>>>=\n"],"correct_choice":"\n<<<=\n"},{"title":"在java7中,下列哪个说法是正确的:","choices":["\nConcurrentHashMap使用synchronized关键字保证线程安全\n","\nHashMap实现了Collection接口\n","\nArrays.asList方法返回java.util.ArrayList对象\n","\nSimpleDateFormat对象是线程不安全的\n"],"correct_choice":"\nSimpleDateFormat对象是线程不安全的\n"},{"title":"通过JDBC访问数据库包含下面哪几步？","choices":["\n载入JDBC驱动程序\n","\n建立连接\n","\n执行查询或更新\n","\n关闭连接\n"],"correct_choice":"\n载入JDBC驱动程序\n\n建立连接\n\n执行查询或更新\n\n关闭连接\n"},{"title":"java中Hashtable, Vector, TreeSet, LinkedList哪些线程是安全的？","choices":["\nHashtable\n","\nVector\n","\nTreeSet\n","\nLinkedList\n"],"correct_choice":"\nHashtable\n\nVector\n"},{"title":"下面有关java的instanceof、?、&、&&说法正确的有？","choices":["\ninstanceof 可用来判断某个实例变量是否属于某种类的类型。\n","\n\"?：\"  三目运算符\n","\n&在逻辑运算中是非短路逻辑与，在位运算中是按位与\n","\n&& 逻辑运算：逻辑与\n"],"correct_choice":"\ninstanceof 可用来判断某个实例变量是否属于某种类的类型。\n\n\"?：\"  三目运算符\n\n&在逻辑运算中是非短路逻辑与，在位运算中是按位与\n\n&& 逻辑运算：逻辑与\n"},{"title":"往OuterClass类的代码段中插入内部类声明, 哪一个是错误的:\npublic class OuterClass{\n    private float f=1.0f;\n    //插入代码到这里\n}\n","choices":["\nclass InnerClass{\npublic static float func(){return f;}\n}\n","\nabstract class InnerClass{\npublic abstract float func(){}\n}\n","\nstatic class InnerClass{\nprotected static float func(){return f;}\n}\n","\npublic class InnerClass{\n static float func(){return f;}\n}\n"],"correct_choice":"\nclass InnerClass{\npublic static float func(){return f;}\n}\n\nabstract class InnerClass{\npublic abstract float func(){}\n}\n\nstatic class InnerClass{\nprotected static float func(){return f;}\n}\n\npublic class InnerClass{\n static float func(){return f;}\n}\n"},{"title":"\n  下列关于构造方法不正确的是：（ \n   ）\n\n\n  \n\n\n  \n","choices":["\n类的构造方法和类同名\n","\n一个类可以有多个构造方法\n","\n在实例化对象时必须调用类的构造方法\n","\n构造方法可以和该类其他方法一样被该类对象调用\n"],"correct_choice":"\n构造方法可以和该类其他方法一样被该类对象调用\n"},{"title":"  下面的输出结果是什么？ \npublic class Demo {\n  public static void main(String args[])\n  {\n    String str=new String(\"hello\");\n    if(str==\"hello\")\n    {\n      System.out.println(\"true\");\n    }      \n    else     {\n      System.out.println(\"false\");\n    }\n  }\n}\n\n  \n","choices":["\ntrue\n","\nfalse\n"],"correct_choice":"\nfalse\n"},{"title":"下面不属于HttpServletRequest接口完成功能的是？","choices":["\n读取cookie\n","\n读取HTTP头\n","\n设定响应的content类型\n","\n读取路径信息\n"],"correct_choice":"\n设定响应的content类型\n"},{"title":"  有以下一段代码，请选择其运行结果。(       )\n  public class Spike\n{\n    public static void main(String[] args)\n    {\n        Counter a = new Counter();\n        System.out.println(a.increment());\n        System.out.println(a.anotherIncrement());\n        Counter b = new Counter();\n        System.out.println(b.increment());\n    }\n}\nclass Counter\n{\n    private static int count = 0;\n    public int increment()\n    {\n        return count++;\n    }\n    public int anotherIncrement()\n    {\n        return ++count;\n    }\n}\n\n\n  \n","choices":["\n1 1 1\n","\n1 2 3\n","\n0 2 2\n","\n0 2 0\n"],"correct_choice":"\n0 2 2\n"},{"title":"  关于以下application,说法正确是什么？ \npublic class Test {\n\tstatic int x=10;\n\tstatic {x+=5;}\n\tpublic static void main(String[] args) //4\n        {\n\t\tSystem.out.println(\"x=\"+x);\n\t}\n\tstatic{x/=3;};\n}//9","choices":["\n4行与9行不能通过编译，因为缺少方法名和返回类型\n","\n编译通过，执行结果是：x=5\n","\n编译通过，执行结果是：x=3\n","\n9行不能通过编译，因为只能有一个静态初始化器\n"],"correct_choice":"\n编译通过，执行结果是：x=5\n"},{"title":"在Java中，关于HashMap类的描述，以下错误的是","choices":["\nHashMap使用键/值得形式保存数据\n","\nHashMap 能够保证其中元素的顺序\n","\nHashMap允许将null用作键\n","\nHashMap允许将null用作值\n"],"correct_choice":"\nHashMap 能够保证其中元素的顺序\n"},{"title":"  下面有关java classloader说法正确的是（）？ ","choices":["\nClassLoader就是用来动态加载class文件到内存当中用的\n","\nJVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关\n","\nClassLoader使用的是双亲委托模型来搜索类的\n","\nJava默认提供的三个ClassLoader是Boostrap ClassLoader，Extension ClassLoader，App ClassLoader\n","\n以上都不正确\n"," JVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关 ","  这句话是对的，那么不同版本的同名类，就没办法实现了。这也是java运行用户自定义类加载的一个好处。不同厂商类也可以相同名称 "],"correct_choice":"\nClassLoader就是用来动态加载class文件到内存当中用的\n\nClassLoader使用的是双亲委托模型来搜索类的\n\nJava默认提供的三个ClassLoader是Boostrap ClassLoader，Extension ClassLoader，App ClassLoader\n  这句话是对的，那么不同版本的同名类，就没办法实现了。这也是java运行用户自定义类加载的一个好处。不同厂商类也可以相同名称 "},{"title":"\n  在\n  java\n  中\n  ,\n  以下\n  _____\n  类的对象以键\n  -\n  值的方式存储对象\n","choices":["\njava,util.List\n","\njava,util.ArrayList\n","\njava,util.HashMap\n","\njava,util.LinkedList\n"],"correct_choice":"\njava,util.HashMap\n"},{"title":"哪个类可用于处理 Unicode? \n","choices":["\nInputStreamReader\n","\nBufferedReader\n","\nWriter\n","\nPipedInputStream\n"],"correct_choice":"\nInputStreamReader\n"},{"title":"\n  要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以( )\n","choices":["\n让该类不使用任何关键字\n","\n使用private关键字\n","\n使用protected关键字\n","\n使用void关键字\n"],"correct_choice":"\n让该类不使用任何关键字\n"},{"title":"\n\n  类A1和类A2在同一包中，类A2有个protected的方法testA2，类A1不是类A2的子类（或子类的子类），类A1可以访问类A2的方法testA2。（  ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  下面所示的java代码，运行时，会产生（）类型的异常 \nint Arry_a[] = new int[10];\nSystem.out.println(Arry_a[10]);","choices":["\nArithmeticException\n","\nNullPointException\n","\nIOException\n","\nArrayIndexOutOfBoundsException\n"],"correct_choice":"\nArrayIndexOutOfBoundsException\n"},{"title":"_______意味着一个操作在不同的类中可以有不同的实现方式。","choices":["\n多态性\n","\n多继承\n","\n类的组合\n","\n类的复用\n"],"correct_choice":"\n多态性\n"},{"title":"  What is displayed when the following is executed; \ndouble d1=-0.5;\nSystem.out.println(\"Ceil d1=\"+Math.ceil(d1));\nSystem.out.println(\"floor d1=\"+Math.floor(d1));\n\n","choices":["\nCeil d1=-0.0\nfloor d1=-1.0\n","\nCeil d1=0.0\nfloor d1=-1.0\n","\nCeil d1=-0.0\nfloor d1=-0.0\n","\nCeil d1=0.0\nfloor d1=0.0\n","\nCeil d1=0\nfloor d1=-1\n"],"correct_choice":"\nCeil d1=-0.0\nfloor d1=-1.0\n"},{"title":"volatile关键字的说法错误的是","choices":["\n能保证线程安全\n","\nvolatile关键字用在多线程同步中，可保证读取的可见性\n","\nJVM保证从主内存加载到线程工作内存的值是最新的\n","\nvolatile能禁止进行指令重排序\n"],"correct_choice":"\n能保证线程安全\n"},{"title":"如下代码，执行test()函数后，屏幕打印结果为（）\npublic class Test2\n{\n    public void add(Byte b)\n    {\n        b = b++;\n    }\n    public void test()\n    {\n        Byte a = 127;\n        Byte b = 127;\n        add(++a);\n        System.out.print(a + \" \");\n        add(b);\n        System.out.print(b + \"\");\n    }\n}\n\n\n","choices":["\n127 127\n","\n128 127\n","\n129 128\n","\n以上都不对\n"],"correct_choice":"\n以上都不对\n"},{"title":"java用（）机制实现了进程之间的同步执行","choices":["\n监视器\n","\n虚拟机\n","\n多个CPU\n","\n异步调用\n"],"correct_choice":"\n监视器\n"},{"title":"JAVA反射机制主要提供了以下哪些功能？","choices":["\n在运行时判断一个对象所属的类\n","\n在运行时构造一个类的对象\n","\n在运行时判断一个类所具有的成员变量和方法\n","\n在运行时调用一个对象的方法\n"],"correct_choice":"\n在运行时判断一个对象所属的类\n\n在运行时构造一个类的对象\n\n在运行时判断一个类所具有的成员变量和方法\n\n在运行时调用一个对象的方法\n"},{"title":"  Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( ) \npublic class Demo{\n　　float func0()\n　　{\n　　　　byte i=1;\n　　　　return i;\n　　}\n　　float func1()\n　　{\n　　　　int i=1;\n　　　　return;\n　　}\n　　float func2()\n　　{\n　　　　short i=2;\n　　　　return i;\n　　}\n　　float func3()\n　　{\n　　　　long i=3;\n　　　　return i;\n　　}\n　　float func4()\n　　{\n　　　　double i=4;\n　　　　return i;\n　　}\n}\n","choices":["\nfunc1\n","\nfunc2\n","\nfunc3\n","\nfunc4\n"],"correct_choice":"\nfunc1\n\nfunc4\n"},{"title":"\n  能单独和finally语句一起使用的块是(  )\n","choices":["\ntry\n","\ncatch\n","\nthrow\n","\nthrows\n"],"correct_choice":"\ntry\n"},{"title":"\n  关于\n  访问权限说法正确\n  的是\n  ？\n   ( \n   )\n\n\n  \n","choices":["\n类定义前面可以修饰public,protected和private\n","\n内部类前面可以修饰public,protected和private\n","\n局部内部类前面可以修饰public,protected和private\n","\n以上说法都不正确\n"],"correct_choice":"\n内部类前面可以修饰public,protected和private\n"},{"title":"进行Java基本的GUI设计需要用到的包是（）","choices":["\njava.io\n","\njava.sql\n","\njava.awt\n","\njava.rmi\n"],"correct_choice":"\njava.awt\n"},{"title":"下列关于java抽象类的说法哪个正确?","choices":["\n某个抽象类的父类是抽象类，则这个子类必须重载父类的所有抽象方法\n","\n接口和抽象类是同一回事\n","\n可以用抽象类直接去实例化创建对象\n","\n一个类只能继承一个抽象类\n"],"correct_choice":"\n一个类只能继承一个抽象类\n"},{"title":"Which of the following statements are valid array declaration?\n  (A) int number();\n  (B) float average[];\n  (C) double[] marks;\n  (D) counter int[];","choices":["\n(B) & (C)\n","\n(A)\n","\n(A) & (C)\n","\n(D)\n"],"correct_choice":"\n(B) & (C)\n"},{"title":"  下列代码的输出结果是_____ \nboolean b=true?false:true==true?false:true;\nSystem.out.println(b);\n","choices":["\ntrue\n","\nfalse\n","\nnull\n","\n空字符串\n"],"correct_choice":"\nfalse\n"},{"title":"Which statement is true for the class java.util.ArrayList?","choices":["\nThe elements in the collection are ordered.\n","\nThe collection is guaranteed to be immutable.\n","\nThe elements in the collection are guaranteed to be unique.\n","\nThe elements in the collection are accessed using a unique key.\n","\nThe elements in the collections are guaranteed to be synchronized.\n"],"correct_choice":"\nThe elements in the collection are ordered.\n"},{"title":"ServletConfig接口默认是哪里实现的？","choices":["\nServlet\n","\nGenericServlet\n","\nHttpServlet\n","\n用户自定义servlet\n"],"correct_choice":"\nGenericServlet\n"},{"title":"下列哪个选项是Java调试器？如果编译器返回程序代码的错误，可以用它对程序进行调试。","choices":["\njava.exe\n","\njavadoc.exe\n","\njdb.exe\n","\njavaprof.exe\n"],"correct_choice":"\njdb.exe\n"},{"title":"\n  \n    给出下面的代码段:\n    \n  \n\n\n  public class Base{ int w, x, y ,z;\n    public Base(int a,int b) { x=a; y=b; }\n    public Base(int a, int b, int c, int d) {\n    // assignment x=a, y=b w=d;z=c; }}\n  \n  在代码说明// assignment x=a, y=b处写入如下哪几个代码是正确的？（）\n\n\n  \n  \n","choices":["\nBase(a,b);\n","\nx=a, y=b;\n","\nx=a; y=b;\n","\nthis(a,b);\n"],"correct_choice":"\nx=a; y=b;\n\nthis(a,b);\n"},{"title":"对于线程局部存储TLS(thread local storage)，以下表述正确的是","choices":["\n解决多线程中的对同一变量的访问冲突的一种技术\n","\nTLS会为每一个线程维护一个和该线程绑定的变量的副本\n","\n每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了\n","\nJava平台的java.lang.ThreadLocal是TLS技术的一种实现\n"],"correct_choice":"\n解决多线程中的对同一变量的访问冲突的一种技术\n\nTLS会为每一个线程维护一个和该线程绑定的变量的副本\n\nJava平台的java.lang.ThreadLocal是TLS技术的一种实现\n"},{"title":"JDK提供的用于并发编程的同步器有哪些？","choices":["\nSemaphore\n","\nCyclicBarrier\n","\nCountDownLatch\n","\nCounter\n"],"correct_choice":"\nSemaphore\n\nCyclicBarrier\n\nCountDownLatch\n"},{"title":"\n  Java\n  源程序文件的扩展名为（）\n","choices":["\n.java\n","\n.class\n","\n.exe\n","\n.jar\n"],"correct_choice":"\n.java\n"},{"title":"在\nJava\n中，存放字符串常量的对象属于（\n\n）类对象。","choices":["\nCharacter\n","\nString\n","\nStringBuffer\n","\nVector\n"],"correct_choice":"\nString\n"},{"title":"\n   在类Tester中定义方法如下，\n\n\n   public double max(int x, int y) { //\n  省略 }\n  \n\n\n  则在该类中定义如下哪个方法头是对上述方法的重载(Overload)?\n  \n","choices":["\npublic int max(int a, int b) {}\n","\npublic int max(double a, double b) {}\n","\npublic double max(int x, int y) {}\n","\nprivate double max(int a, int b) {}\n"],"correct_choice":"\npublic int max(double a, double b) {}\n"},{"title":"\n  下列符号中可以在\n  java\n  程序里表示单行注释的是（\n  ）\n","choices":["\n--\n","\n/* ……*/\n","\n//\n","\n/** ……*/\n"],"correct_choice":"\n//\n"},{"title":"\n  下面是findSum（int m.int n）方法的定义，方法调用findSum（1，5）的返回结果是( )\n\n\n  \n\n\n  int findSum（int m.int n）{\n\n\n     int sum=0；  \n     for（int i=m；i<=n；i++）{  \n  \n     sum+=i；\n  \n  \n     }\n  \n  \n    return sum；\n  \n\n\n  }\n","choices":["\n1\n","\n5\n","\n10\n","\n15\n"],"correct_choice":"\n15\n"},{"title":"\n  main\n  方法是\n  Java Application\n  程序执行的入口点，以下描述哪项是合法的（）。\n","choices":["\npublic  static  void  main（ ）\n","\npublic  static  void   main（ String  args[] ）\n","\npublic static int  main（String  [] arg ）\n","\npublic  void  main（String  arg[] ）\n"],"correct_choice":"\npublic  static  void   main（ String  args[] ）\n"},{"title":"以下哪项不是java基础类型（）","choices":["\nint\n","\nboolean\n","\nString\n","\nfloat\n"],"correct_choice":"\nString\n"},{"title":"  关于以下程序代码的说明正确的  class HasStatic{\n    private static int x = 100;\n    public static void main(String args[ ]){\n        HasStatic hs1 = new HasStatic();\n        hs1.x++;\n        HasStatic hs2 = new HasStatic();\n        hs2.x++;\n        hs1=new HasStatic();\n        hs1.x++;\n        HasStatic.x--;\n        System.out.println( \"x=\" +x);\n    }\n}    ","choices":["\n5行不能通过编译，因为引用了私有静态变量\n","\n10行不能通过编译，因为x是私有静态变量\n","\n程序通过编译，输出结果为：x=103\n","\n程序通过编译，输出结果为：x=102\n"],"correct_choice":"\n程序通过编译，输出结果为：x=102\n"},{"title":"下列整型常量 i 的定义中，正确的是(  )","choices":["\nfinal i;\n","\nstatic int i;\n","\nstatic final int  i=234;\n","\nfinal float i=3.14f;\n"],"correct_choice":"\nstatic final int  i=234;\n"},{"title":"下面代码的输出是什么？ public class Base\n{\n    private String baseName = \"base\";\n    public Base()\n    {\n        callName();\n    }\n\n    public void callName()\n    {\n        System. out. println(baseName);\n    }\n\n    static class Sub extends Base\n    {\n        private String baseName = \"sub\";\n        public void callName()\n        {\n            System. out. println (baseName) ;\n        }\n    }\n    public static void main(String[] args)\n    {\n        Base b = new Sub();\n    }\n}\n","choices":["\nnull\n","\nsub\n","\nbase\n"],"correct_choice":"\nnull\n"},{"title":"下面属于java引用类型的有？","choices":["\nString\n","\nbyte\n","\nchar\n","\nArray\n"],"correct_choice":"\nString\n\nArray\n"},{"title":"\n  关于数据库连接的程序，以下哪个语句的注释是错误的（ ）\n","choices":["\nClass.forName(“com.mysql.jdbc.Driver”); //指定MySQL JDBC驱动程序\n","\nString url=” jdbc:mysql://localhost:3306/student”; //指定驱动程序与数据源的连接\n","\ndb.executeUpdate(sql); //用于返回查询结果\n","\nwhile(rs.next())//用于遍历查询结果中的记录\n"],"correct_choice":"\ndb.executeUpdate(sql); //用于返回查询结果\n"},{"title":"  代码 的运行结果是（）   package com.sunline.java;\npublic class A implements B extends C{\n    public static void main(String args[]){\n        System.out.println(\"hello sunline!\");\n    }\n}    ","choices":["\n在控制台打印hello sunline！\n","\n报异常java.lang.NullPoninterException\n","\n编译报错\n","\n报异常java.lang.RuntimeExcception\n"],"correct_choice":"\n编译报错\n"},{"title":"\n  关于抽象类叙述正确的是？ ( \n   )\n\n\n  \n","choices":["\n抽象类不能实现接口\n","\n抽象类必须有“abstract class”修饰\n","\n抽象类必须包含抽象方法\n","\n抽象类也有类的特性，可以被实例化\n"],"correct_choice":"\n抽象类必须有“abstract class”修饰\n"},{"title":"类声明中，声明抽象类的关键字是\n ( ) ","choices":["\npublic\n","\nabstract\n","\nfinal\n","\nclass\n"],"correct_choice":"\nabstract\n"},{"title":"  下列语句序列执行后，输出结果是（） \n  public class ex{ \n  public static void main(String[]args){ \n  int a=13; \n  a=a/5； \n  System.out.println(a); \n  } \n  } ","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n2\n"},{"title":"\n\n  为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为(      )。\n","choices":["\nstatic  void  method( )\n","\npublic  void  method( )\n","\nfinal  void  method( )\n","\nabstract  void  method( )\n"],"correct_choice":"\nstatic  void  method( )\n"},{"title":"下面关于依赖注入(DI)的说法不正确的是()","choices":["\n只有通过Spring才能实现依赖注入(DI)\n","\n依赖注入的主要目的是解耦合\n","\n常见的依赖注入方式有Setter和构造方法\n"],"correct_choice":"\n只有通过Spring才能实现依赖注入(DI)\n"},{"title":"\n  程序读入用户输入的一个值，要求创建一个自定义的异常，如果输入值大于\n  10\n  ，使用\n  throw\n  语句显式地引发异常，异常输出信息为\n  ”something’swrong!”\n  ，语句为（）\n","choices":["\nif(i>10)throw new Exception(\"something’swrong!\");\n","\nif(i>10)throw Exceptione(\"something’swrong!\");\n","\nif(i>10) throw new Exceptione(\"something’swrong!\");\n","\nif(i>10)throw Exception( \"something’swrong!\");\n"],"correct_choice":"\nif(i>10)throw new Exception(\"something’swrong!\");\n"},{"title":"关于PreparedStatement与Statement描述错误的是（）","choices":["\n一般而言，PreparedStatement比Statement执行效率更高\n","\nPreparedStatement会预编译SQL语句\n","\nStatement每次都会解析/编译SQL，确立并优化数据获取路径\n","\nStatement执行扫描的结果集比PreparedStatement大\n"],"correct_choice":"\nStatement执行扫描的结果集比PreparedStatement大\n"},{"title":"关于struts框架，下面那些说法是正确的？","choices":["\nStruts中无法完成上传功能\n","\nStruts框架基于MVC模式\n","\nStruts框架容易引起流程复杂、结构不清晰等问题\n","\nStruts可以有效地降低项目的类文件数目\n"],"correct_choice":"\nStruts框架基于MVC模式\n"},{"title":"以下程序运行的结果为（）\npublic class Example extends Thread{\n     @Override\n     public void run(){\n        try{\n             Thread.sleep(1000);\n             }catch (InterruptedException e){\n             e.printStackTrace();\n             }\n             System.out.print(\"run\");\n     }\n     public static void main(String[] args){\n             Example example=new Example();\n             example.run();\n             System.out.print(\"main\");\n     }\n}\n","choices":["\nrun main\n","\nmain run\n","\nmain\n","\nrun\n","\n不能确定\n"],"correct_choice":"\nrun main\n"},{"title":"结构型模式中最体现扩展性的模式是（）","choices":["\n装饰模式\n","\n合成模式\n","\n桥接模式\n","\n适配器\n"],"correct_choice":"\n装饰模式\n"},{"title":"\n  Web客户端的编程语言JavaScript源自Java，其功能是Java SE的子集。\n","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  针对以下代码，哪些选项执行后是true的：（）   class CompareReference{\n   public static void main(String [] args){\n   float f=42.0f;\n   float f1[]=new float[2];\n   float f2[]=new float[2];\n   float[] f3=f1;\n   long x=42;\n   f1[0]=42.0f;\n  }\n} ","choices":["\nf1==f2\n","\nx==f1[0]\n","\nf1==f3\n","\nf2==f1[1]\n"],"correct_choice":"\nx==f1[0]\n\nf1==f3\n"},{"title":"在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？","choices":["\n每个中文字符占用2个字节，每个英文字符占用1个字节\n","\n假设数据库中的字符是以GBK编码的，那么显示数据库数据的网页也必须是GBK编码的。\n","\nJava的char类型，通常以UTF-16 Big Endian的方式保存一个字符。\n","\n实现国际化应用常用的手段是利用ResourceBundle类\n"],"correct_choice":"\nJava的char类型，通常以UTF-16 Big Endian的方式保存一个字符。\n\n实现国际化应用常用的手段是利用ResourceBundle类\n"},{"title":"\n  已知int a[]=new int[10]，则下列对数组元素的访问不正确的是（）\n","choices":["\na[0]\n","\na[1]\n","\na[9]\n","\na[10]\n"],"correct_choice":"\na[10]\n"},{"title":"\n  以下关于Object类的说法正确的是（）\n","choices":["\nJava中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。\n","\nJava中的接口(interface)也继承了Object类\n","\n利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。\n","\n如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。\n"],"correct_choice":"\nJava中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。\n"},{"title":"\n  类\n  ABC\n  定义如下：\n\n\n  1\n  ．\n  public  class  ABC{\n\n\n  2\n  ．\n   public  double  max( double  a, double  b) {   }\n\n\n  3\n  ．\n\n\n  4\n  ．\n  } \n\n\n  将以下哪个方法插入行\n  3\n  是不合法的。（）\n","choices":["\npublic  float  max(float  a, float  b, float  c){  }\n","\npublic  double  max (double  c,  double  d){  }\n","\npublic  float  max(float  a,  float  b){  }\n","\nprivate  int  max(int a, int b, int c){  }\n"],"correct_choice":"\npublic  double  max (double  c,  double  d){  }\n"},{"title":"\n  下列哪种说法是正确的？\n","choices":["\n实例方法可直接调用超类的实例方法\n","\n实例方法可直接调用超类的类方法\n","\n实例方法可直接调用本类的类方法\n","\n实例方法可直接调用其他类的实例方法\n"],"correct_choice":"\n实例方法可直接调用本类的类方法\n"},{"title":"下列选项中关于Java中super关键字的说法正确的是（）","choices":["\nsuper关键字是在子类对象内部指代其父类对象的引用\n","\nsuper关键字不仅可以指代子类的直接父类，还可以指代父类的父类\n","\n子类通过super关键字只能调用父类的方法，而不能调用父类的属性\n","\n子类通过super关键字只能调用父类的属性，而不能调用父类的方法\n"],"correct_choice":"\nsuper关键字是在子类对象内部指代其父类对象的引用\n"},{"title":"\n  以下程序的输出结果是\n\n\n  public class Print{\n\tstatic boolean out(char c){\n\t\tSystem.out.println(c);\n\t\treturn true;\n\t}\n\tpublic static void main(String[] argv){\n\t\tint i = 0;\n\t\tfor(out('A');out('B') && (i<2);out('C')){\n\t\t\ti++;\n\t\t\tout('D');\n\t\t}\n\t}\n}\n\n\n  \n","choices":["\nABDCBDCB\n","\nBCDABCD\n","\n编译错误\n","\n运行错误\n"],"correct_choice":"\nABDCBDCB\n"},{"title":"关于AOP错误的是？","choices":["\nAOP将散落在系统中的“方面”代码集中实现\n","\nAOP有助于提高系统可维护性\n","\nAOP已经表现出将要替代面向对象的趋势\n","\nAOP是一种设计模式，Spring提供了一种实现\n"],"correct_choice":"\nAOP已经表现出将要替代面向对象的趋势\n"},{"title":"  A,B,C,D 中哪些是 setvar的重载？ \npublic class methodover\n{\n    public void setVar(int a, int b, float c) {}\n}\n\n","choices":["\nprivate void setVar(int a， float c， int b){}\n","\nprotected void setVar(int a， int b， float c){}\n","\npublic int setVar(int a， float c， int b){return a;}\n","\npublic int setVar(int a， float c){return a;}\n"],"correct_choice":"\nprivate void setVar(int a， float c， int b){}\n\npublic int setVar(int a， float c， int b){return a;}\n\npublic int setVar(int a， float c){return a;}\n"},{"title":"下列方法中哪个是线程执行的方法？ （）","choices":["\nrun（）\n","\nstart（）\n","\nsleep（）\n","\nsuspend（）\n"],"correct_choice":"\nrun（）\n"},{"title":"有关hashMap跟hashTable的区别，说法正确的是？","choices":["\nHashMap和Hashtable都实现了Map接口\n","\nHashMap是非synchronized，而Hashtable是synchronized\n","\nHashTable使用Enumeration，HashMap使用Iterator\n","\nHashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与代替求模\n"],"correct_choice":"\nHashMap和Hashtable都实现了Map接口\n\nHashMap是非synchronized，而Hashtable是synchronized\n\nHashTable使用Enumeration，HashMap使用Iterator\n\nHashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与代替求模\n"},{"title":"  以下代码执行的结果显示是多少（）？           ","choices":["\n505000\n","\n0\n","\n运行时错误\n","\n5050\n"],"correct_choice":"\n0\n"},{"title":"\n  下面程序段执行后b的值是()。\n\n\n  Integer integ =new Integer(9)\n  ；\n\n\n  boolean b = integ  instanceof  Object;\n","choices":["\n9\n","\ntrue\n","\n1\n","\nfalse\n"],"correct_choice":"\ntrue\n"},{"title":"  如下的Java程序     public class Test {          public static void main(String[] args) {          System.out.println(args[0]);          }     }      若采用命令行“java Test one two three”调用，则程序输出的结果为： ","choices":["\nTest\n","\none\n","\ntwo\n","\njava\n"],"correct_choice":"\none\n"},{"title":"  JDK中提供的java、javac、jar等开发工具也是用Java编写的。  ","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"\n  下列循环语句序列执行完成后，i的值是（）\n\n\n  int i;\n\n\n  for(i=2;i<=10;i++){\n\n\n   System.out.println(i);\n\n\n  }\n","choices":["\n2\n","\n10\n","\n11\n","\n不确定\n"],"correct_choice":"\n11\n"},{"title":"\n  关于匿名内部类叙述正确的是？ ( \n   )\n\n\n  \n","choices":["\n匿名内部类可以继承一个基类，不可以实现一个接口\n","\n匿名内部类不可以定义构造器\n","\n匿名内部类不能用于形参\n","\n以上说法都不正确\n"],"correct_choice":"\n匿名内部类不可以定义构造器\n"},{"title":"蔺相如，司马相如；魏无忌，长孙无忌。下列哪一组对应关系与此类似()","choices":["\nPHP，Python\n","\nJSP，servlet\n","\nJava，Javascript\n","\nC，C++\n"],"correct_choice":"\nJava，Javascript\n"},{"title":"\n  以下描述不正确的有\n","choices":["\ntry块不可以省略\n","\n可以使用多重catch块\n","\nfinally块可以省略\n","\ncatch块和finally块可以同时省略\n"],"correct_choice":"\ncatch块和finally块可以同时省略\n"},{"title":"  如下哪些是 java 中有效的关键字（）  ","choices":["\nnative\n","\nNULL\n","\nfalse\n","\nthis\n"],"correct_choice":"\nnative\n\nthis\n"},{"title":"类B从类A派生，则类B可以访问类A中的（ ）成员？","choices":["\npublic成员\n","\nprivate成员\n","\nprotected成员\n","\n所有数据成员\n","\n所有函数成员\n"],"correct_choice":"\npublic成员\n\nprotected成员\n"},{"title":"\n  关于下面程序\n  ThisTest\n  .java\n  运行结果\n  说法正确的是\n  ：\n  ( \n   )\n\npublic class ThisTest {\n    \t\tpublic static void main(String args[]) {\n        \t\tString x=\"7\";       \n    \tint y = 2;\n        \t\tint z=2;              \n        System.out.println(x+y+z); \n    \t\t}  \n}\n\n  \n","choices":["\n11\n","\n722\n","\n22\n","\n程序有编译错误\n"],"correct_choice":"\n722\n"},{"title":"  transient变量和下面哪一项有关（）？ ","choices":["\nSerializable\n","\nCloneable\n","\nRunnable\n","\nThrowable\n","\nComparable\n"],"correct_choice":"\nSerializable\n"},{"title":"\n  Java\n  中的集合类包括\n  ArrayList\n  、\n  LinkedList\n  、\n  HashMap\n  等，下列关于集合类描述错误的是？\n","choices":["\nArrayList和LinkedList均实现了List接口\n","\nArrayList访问速度比LinkedList快\n","\n随机添加和删除元素时，ArrayList的表现更加快速\n","\nHashMap实现Map接口，它允许任何类型的键和值对象，并允许将NULL用作键或值\n"],"correct_choice":"\n随机添加和删除元素时，ArrayList的表现更加快速\n"},{"title":"\n  设有下面两个赋值语句：\n\n\n  a = Integer.parseInt(\"1024\");\n\n\n  b = Integer.valueOf(\"1024\").intValue();\n\n下述说法正确的是（）","choices":["\na是整数类型变量，b是整数类对象。\n","\na是整数类对象，b是整数类型变量。\n","\na和b都是整数类对象并且它们的值相等。\n","\na和b都是整数类型变量并且它们的值相等。\n"],"correct_choice":"\na和b都是整数类型变量并且它们的值相等。\n"},{"title":"\n  下列选项中，用于在定义子类时声明父类名的关键字是：( \n   )\n\n\n  \n","choices":["\ninterface\n","\npackage\n","\nextends\n","\nclass\n"],"correct_choice":"\nextends\n"},{"title":"java中，StringBuilder和StringBuffer的区别，下面说法错误的是？","choices":["\nStringBuffer是线程安全的\n","\nStringBuilder是非线程安全的\n","\nStringBuffer对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。\n","\n效率比较String<StringBuffer<StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。\n"],"correct_choice":"\nStringBuffer对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。\n"},{"title":"  代码片段：  \nbyte b1=1,b2=2,b3,b6;  \nfinal byte b4=4,b5=6;  \nb6=b4+b5;  \nb3=(b1+b2);  \nSystem.out.println(b3+b6);\n  关于上面代码片段叙述正确的是（） ","choices":["\n输出结果：13\n","\n语句：b6=b4+b5编译出错\n","\n语句：b3=b1+b2编译出错\n","\n运行期抛出异常\n"],"correct_choice":"\n语句：b3=b1+b2编译出错\n"},{"title":"Java7特性中,abstract class和interface有什么区别。","choices":["\n抽象类可以有构造方法，接口中不能有构造方法\n","\n抽象类中可以有普通成员变量，接口中没有普通成员变量\n","\n抽象类中不可以包含静态方法，接口中可以包含静态方法\n","\n一个类可以实现多个接口，但只能继承一个抽象类。\n"],"correct_choice":"\n抽象类可以有构造方法，接口中不能有构造方法\n\n抽象类中可以有普通成员变量，接口中没有普通成员变量\n\n一个类可以实现多个接口，但只能继承一个抽象类。\n"},{"title":"对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）","choices":["\nfloat\n","\nchar\n","\nshort\n","\ndouble\n"],"correct_choice":"\ndouble\n"},{"title":"Java中的集合类包括ArrayList、LinkedList、HashMap等，下列关于集合类描述错误的是？","choices":["\nArrayList和LinkedList均实现了List接口\n","\nArrayList的访问速度比LinkedList快\n","\n随机添加和删除元素时，ArrayList的表现更佳\n","\nHashMap实现Map接口，它允许任何类型的键和值对象\n"],"correct_choice":"\n随机添加和删除元素时，ArrayList的表现更佳\n"},{"title":"以下哪个不是Collection的子接口？","choices":["\nList\n","\nSet\n","\nSortedSet\n","\nMap\n"],"correct_choice":"\nMap\n"},{"title":"Math.round(11.5)\n等于：（）","choices":["\n11\n","\n11.5\n","\n12\n","\n12.5\n"],"correct_choice":"\n12\n"},{"title":"  执行下列代码的输出结果是( ) \npublic class Demo{\n　public static void main(String args[]){\n　　　int num = 10;\n　　　System.out.println(test(num));\n}\npublic static int test(int b){\n　　　try\n　　　{\n　　　　b += 10;\n　　　　return b;\n　　　}\n　　　catch(RuntimeException e)\n　　　{\n　　　}\n　　　catch(Exception e2)\n　　　{\n　　　}\n　　　finally\n　　　{\n　　　　b += 10;\n　　　　return b;\n　　　}\n　　}\n}","choices":["\n10\n","\n20\n","\n30\n","\n40\n"],"correct_choice":"\n30\n"},{"title":"在运行时，由java解释器自动引入，而不用import语句引入的包是()。","choices":["\njava.lang\n","\njava.system\n","\njava.io\n","\njava.util\n"],"correct_choice":"\njava.lang\n"},{"title":"  根据下面的程序代码，哪些选项的值返回true？ \npublic class Square {  \n    long width;  \n    public Square(long l) {   \n        width = l;  \n    }  \n    public static void main(String arg[]) {   \n        Square a, b, c;   \n        a = new Square(42L);   \n        b = new Square(42L);   \n        c = b;   \n        long s = 42L;  \n    } \n}\n","choices":["\na == b\n","\ns == a\n","\nb == c\n","\na.equals(s)\n"],"correct_choice":"\nb == c\n"},{"title":"下面哪个不属于HttpServletResponse接口完成的功能？","choices":["\n设置HTTP头标\n","\n设置cookie\n","\n读取路径信息\n","\n输出返回数据\n"],"correct_choice":"\n读取路径信息\n"},{"title":"（  ）面向对象程序设计语言不同于其他语言的主要特点。","choices":["\n继承性\n","\n消息传递\n","\n多态性\n","\n封装性\n"],"correct_choice":"\n继承性\n\n多态性\n\n封装性\n"},{"title":"  Given the following code:           import EnclosingOne.InsideOne  1.class Enclosingone\n2.{\n3.    public class InsideOne {}\n4.\n5.}\n6.public class inertest\n7.{\n8.    public static void main(string[]args)\n9.    {\n10.        EnclosingOne eo = new EnclosingOne();\n11.        //insert code here\n12.    }\n13.\n14.}\n   Which statement at line 11 constructs an instance of the inner   class? ","choices":["\nInsideOne ei=eo.new InsideOne();\n","\neo.InsideOne ei=eo.new InsideOne();\n","\nInsideOne ei=EnclosingOne.new InsideOne();\n","\nEnclosingOne.InsideOne ei=eo.new InsideOne();\n"],"correct_choice":"\nInsideOne ei=eo.new InsideOne();\n\nEnclosingOne.InsideOne ei=eo.new InsideOne();\n"},{"title":"下面选项中,哪些是interface中合法方法定义?()","choices":["\npublic void main(String [] args);\n","\nprivate int getSum();\n","\nboolean setFlag(Boolean [] test);\n","\npublic float get(int x);\n"],"correct_choice":"\npublic void main(String [] args);\n\nboolean setFlag(Boolean [] test);\n\npublic float get(int x);\n"},{"title":"\n   对于文件的描述正确的是（ ）\n","choices":["\n文本文件是以“.txt”为后缀名的文件，其他后缀名的文件是二进制文件。\n","\nFile类是Java中对文件进行读写操作的基本类。\n","\n无论文本文件还是二进制文件，读到文件末尾都会抛出EOFException异常。\n","\nJava中对于文本文件和二进制文件，都可以当作二进制文件进行操作。\n"],"correct_choice":"\nJava中对于文本文件和二进制文件，都可以当作二进制文件进行操作。\n"},{"title":"\n  如果希望某个变量只可以被类本身访问和调用，则应该使用下列哪一种访问控制修饰？\n","choices":["\npublic\n","\nprivate\n","\nprivate protected\n","\nprotected\n"],"correct_choice":"\nprivate\n"},{"title":"\n  Java语言与其它语言相比，独有的特点是（ ）\n","choices":["\n面向对象\n","\n多线程\n","\n平台无关\n","\n网络编程\n"],"correct_choice":"\n平台无关\n"},{"title":"\n  关于继承和实现说法正确的\n  是\n  ？ (    )\n\n\n  \n\n\n  \n","choices":["\n类可以实现多个接口，接口可以继承（或扩展）多个接口\n","\n类可以实现多个接口，接口不能继承（或扩展）多个接口\n","\n类和接口都可以实现多个接口\n","\n类和接口都不可以实现多个接口\n"],"correct_choice":"\n类可以实现多个接口，接口可以继承（或扩展）多个接口\n"},{"title":"BufferedReader的父类是以下哪个？","choices":["\nFilterReader\n","\nInputStreamReader\n","\nPipedReader\n","\nReader\n"],"correct_choice":"\nReader\n"},{"title":"下列哪种异常是检查型异常，需要在编写程序时声明？","choices":["\nNullPointerException\n","\nClassCastException\n","\nFileNotFoundException\n","\nIndexOutOfBoundsException\n"],"correct_choice":"\nFileNotFoundException\n"},{"title":"  方法通常存储在进程中的哪一区（）  ","choices":["\n堆区\n","\n栈区\n","\n全局区\n","\n方法区\n"],"correct_choice":"\n方法区\n"},{"title":"关于spring说法错误的是（）","choices":["\nspring是一个轻量级JAVA EE的框架集合\n","\nspring是“依赖注入”模式的实现\n","\n使用spring可以实现声明事务\n","\nspring提供了AOP方式的日志系统\n"],"correct_choice":"\nspring提供了AOP方式的日志系统\n"},{"title":"  请问以下代码运行结果是：        ","choices":["\ntry catch\n","\ntry finally  catch\n","\ntry finally\n","\ntry catch finally\n"],"correct_choice":"\ntry catch finally\n"},{"title":"\n  关于异常的编程，以下描述错误的是：（ ）\n","choices":["\n在有除法存在的代码处，为了防止分母为零，必须抛出并捕获异常\n","\nint i=Integer.parseInt(”123a”);将产生NumberFormatException\n","\nint a[]=null; a[0]=1; 将产生NullPointerException\n","\n输入输出流编程中，读和写时都要抛出IOException\n"],"correct_choice":"\n在有除法存在的代码处，为了防止分母为零，必须抛出并捕获异常\n"},{"title":"\n  在某个类A中存在一个方法：void set(int x),以下不能作为这个方法的重载的声明的是（）\n","choices":["\nvoid set(int y)\n","\nint set(int x，double y)\n","\ndouble set(int x,int y)\n","\nvoid set(int x,int y)\n"],"correct_choice":"\nvoid set(int y)\n"},{"title":"\n  若所用变量都已正确定义，以下选项中，非法的表达式是（）\n","choices":["\na!= 4||b==1\n","\n’a’ % 3\n","\n’a’ = 1/3\n","\n’A’ + 32\n"],"correct_choice":"\n’a’ = 1/3\n"},{"title":"\n  protected访问权限要小于包访问权限。（  ）\n\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"java中用()字指明继承关系.用()关键字指明对接口的实现。","choices":["\nimplements extends\n","\nextends implements\n","\nextend implement\n","\nimplement extend\n"],"correct_choice":"\nextends implements\n"},{"title":"检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。\npackage algorithms.com.guan.javajicu;  \npublic class Example {  \n  String str = new String(\"good\");  \n  char[] ch = {'a','b','c'};  \n  public static void main(String[] args) {  \n     Example ex = new Example();  \n     ex.change(ex.str, ex.ch);  \n     System.out.print(ex.str +\"and\");  \n     System.out.print(ex.ch);   \n  }  \n   \n  public void change(String str, char ch[]){  \n     str= \"test ok\";  \n     ch[0]= 'g';  \n  }  \n}  \n","choices":["\ntest okandabc\n","\ntest okandgbc\n","\ngoodandabc\n","\ngoodandgbc\n"],"correct_choice":"\ngoodandgbc\n"},{"title":"有关线程的叙述正确的是()","choices":["\n可以获得对任何对象的互斥锁定\n","\n通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定\n","\n线程通过调用对象的synchronized方法可获得对象的互斥锁定\n","\n线程调度算法是平台独立的\n"],"correct_choice":"\n线程通过调用对象的synchronized方法可获得对象的互斥锁定\n\n线程调度算法是平台独立的\n"},{"title":"以下集合对象中哪几个是线程安全的（）","choices":["\nLinkedList\n","\nArrayList\n","\nVector\n","\nHashtable\n"],"correct_choice":"\nVector\n\nHashtable\n"},{"title":"\n  以下不属于构造方法特征的是（）\n","choices":["\n构造方法名与类名相同\n","\n构造方法不返回任何值，也没有返回类型\n","\n构造方法在创建对象时调用，其他地方不能显式地直接调用\n","\n每一个类只能有一个构造方法\n"],"correct_choice":"\n每一个类只能有一个构造方法\n"},{"title":"\n  \n    下列代码的执行结果是（）\n  \n  \n    \n      \n        \n            public class Test {\n          \n          \n                public static int a = 1;\n          \n          \n                public static void main(String[] args) {\n          \n          \n                    int a = 10;\n          \n          \n                    a++; Test.a++;\n          \n          \n                    Test t=new Test();\n          \n          \n                    System.out.println(\"a=\" + a + \"\n              t.a=\" + t.a);\n          \n          \n                }\n          \n          \n            }\n          \n        \n    \n  \n\n\n  \n","choices":["\na=10 t.a=3\n","\na=11 t.a=2\n","\na=12 t.a=1\n","\na=11 t.a=1\n"],"correct_choice":"\na=11 t.a=2\n"},{"title":"\n  执行语句“int a=\n  ’\n  2\n  ’\n  ”后，a的值是（ ）\n","choices":["\n2\n","\n50\n","\n49\n","\n0\n"],"correct_choice":"\n50\n"},{"title":"  已知有下列Test类的说明，则下列哪个语句是正确的？（） \n  public class Test \n  { \n  private float f = 1.0f; \n  int m = 12; \n  static int n = 1; \n  public static void main (String args[]) \n  { \n  Test t = new Test(); \n  } \n  } ","choices":["\nt.f;\n","\nthis.n;\n","\nTest.m\n","\nTest.f\n"],"correct_choice":"\nt.f;\n"},{"title":"当点击鼠标或者拖动鼠标时，触发的事件是下列的哪一个？（）","choices":["\nKeyEvent\n","\nAxtionEvent\n","\nItemEvent\n","\nMouseEvent\n"],"correct_choice":"\nMouseEvent\n"},{"title":"定义有StringBuffer s1=new StringBuffer(10);s1.append(“1234”)则s1.length()和s1.capacity()分别是多少?","choices":["\n4　10\n","\n4　　4\n","\n10　　10\n","\n10　　4\n"],"correct_choice":"\n4　10\n"},{"title":"\n  ____技术是一种可以使音频，视频和其他多媒体信息在\n  Internet\n  及\n  Intranet\n  上以实时的，无需下载等待的方式进行播放的技术。\n","choices":["\n流媒体\n","\n多媒体\n","\n复合媒体\n","\n音视媒体\n"],"correct_choice":"\n流媒体\n"},{"title":"JSP分页代码中，哪个步骤次序是正确的？","choices":["\n先取总记录数，得到总页数，最后显示本页的数据。\n","\n先取所有的记录，得到总页数，再取总记录数，最后显示本页的数据。\n","\n先取总页数，得到总记录数，再取所有的记录，最后显示本页的数据。\n","\n先取本页的数据，得到总页数，再取总记录数，最后显示所有的记录。\n"],"correct_choice":"\n先取总记录数，得到总页数，最后显示本页的数据。\n"},{"title":"  下列java程序的输出结果为____。 \n\n  public class Example{\n    String str=new String(\"hello\");\n    char[]ch={'a','b'};\n    public static void main(String args[]){\n        Example ex=new Example();\n        ex.change(ex.str,ex.ch);\n        System.out.print(ex.str+\" and \");\n        System.out.print(ex.ch);\n    }\n    public void change(String str,char ch[]){\n        str=\"test ok\";\n        ch[0]='c';\n    }\n}\n","choices":["\nhello and ab\n","\nhello and cb\n","\nhello and a\n","\ntest ok and ab\n","\ntest ok and cb\n","\ntest ok and c\n"],"correct_choice":"\nhello and cb\n"},{"title":"\n  下面的程序段创建了BufferedReader类的对象in，以便读取本机c盘my文件夹下的文件1.txt。File构造函数中正确的路径和文件名的表示是(    )。\n\n\n  \n    \n      \n          File f = new File(\n          填代码处);\n          \n        \n        \n          file =new   FileReader(f);\n        \n        \n          in=new BufferedReader(file);\n        \n      \n  \n","choices":["\n\"./1.txt\"\n","\n\"../my/1.txt\"\n","\n\"c:\\\\my\\\\1.txt\"\n","\n\"c:\\ my\\1.txt\"\n"],"correct_choice":"\n\"c:\\\\my\\\\1.txt\"\n"},{"title":"This调用语句必须是构造函数中的第一个可执行语句。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"与未加访问控制符的缺省情况相比，public和protected修饰符扩大了类及其属性和方法的被访问范围，private修饰符则缩小了这种范围。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"编译\nJava\n源程序文件产生的字节码文件的扩展名为（）","choices":["\njava\n","\nclass\n","\nhtml\n","\nexe\n"],"correct_choice":"\nclass\n"},{"title":"下列关于功能性注释不正确的说法是()","choices":["\n功能性注释嵌在源程序中，用于说明程序段或语句的功能以及数据的状态\n","\n注释用来说明程序段，需要在每一行都要加注释\n","\n可使用空行或缩进，以便很容易区分注释和程序\n","\n修改程序也应修改注释\n"],"correct_choice":"\n注释用来说明程序段，需要在每一行都要加注释\n"},{"title":"下面有关webservice的描述，错误的是？","choices":["\nWebservice是跨平台，跨语言的远程调用技术\n","\nWebservice通信机制实质就是json数据交换\n","\nWebservice采用了soap协议（简单对象协议）进行通信\n","\nWSDL是用于描述 Web Services 以及如何对它们进行访问\n"],"correct_choice":"\nWebservice通信机制实质就是json数据交换\n"},{"title":"下列描述错误的是?","choices":["\n类只能继承一个父类，但是可以实现多个接口\n","\n抽象类自身可以定义成员而接口不可以\n","\n抽象类和接口都不能被实例化(忽略匿名内部类)\n","\n一个类可以有多个基类和多个基接口\n"],"correct_choice":"\n抽象类自身可以定义成员而接口不可以\n\n一个类可以有多个基类和多个基接口\n"},{"title":"下面描述属于java虚拟机功能的是？","choices":["\n通过 ClassLoader 寻找和装载 class 文件\n","\n解释字节码成为指令并执行，提供 class 文件的运行环境\n","\n进行运行期间垃圾回收\n","\n提供与硬件间接交互的平台\n"],"correct_choice":"\n通过 ClassLoader 寻找和装载 class 文件\n\n解释字节码成为指令并执行，提供 class 文件的运行环境\n\n进行运行期间垃圾回收\n"},{"title":"截止JDK1.8版本,java并发框架支持锁包括?","choices":["\n读写锁\n","\n自旋锁\n","\nX锁\n","\n乐观锁\n","\n排他锁\n"],"correct_choice":"\n读写锁\n\n自旋锁\n\n乐观锁\n"},{"title":"在结构化的程序设计中，模块划分的原则是（）","choices":["\n各模块硬包括尽量多的功能\n","\n各模块的规划应尽量大\n","\n各模块之间的联系尽量紧密\n","\n模块内具有高内聚度，模块间具有低耦合度\n"],"correct_choice":"\n模块内具有高内聚度，模块间具有低耦合度\n"},{"title":"\n  以下程序的运行结果是？\n\n\n  \n","choices":["\nfoobar\n","\nbarfoo\n","\nfoobar或者barfoo都有可能\n","\nBar\n","\nFoo\n","\n程序无法正常运行\n"],"correct_choice":"\nfoobar\n"},{"title":"\n  Panel\n  和\n  Applet\n  的默认布局管理器是（\n  ）\n","choices":["\nCardLayout\n","\nFlowLayout\n","\nBorderLayout\n","\nGridLayout\n"],"correct_choice":"\nFlowLayout\n"},{"title":"\n  Java\n  语言中，负责并发管理的机制是（\n  ）\n","choices":["\n垃圾回收\n","\n虚拟机\n","\n代码安全\n","\n多线程\n"],"correct_choice":"\n多线程\n"},{"title":"下列哪些语句关于内存回收的说明是正确的? (  )\n","choices":["\n程序员必须创建一个线程来释放内存\n","\n内存回收程序负责释放无用内存\n","\n内存回收程序允许程序员直接释放内存\n","\n内存回收程序可以在指定的时间释放内存对象\n"],"correct_choice":"\n内存回收程序负责释放无用内存\n"},{"title":"\n  指出下来程序运行的结果是\n\n\n  \n    \n  \n","choices":["\ngood and abc\n","\ngood and gbc\n","\ntst ok and abc\n","\ntst ok and gbc\n"],"correct_choice":"\ngood and gbc\n"},{"title":"java中，用（  ）关键字定义常量？","choices":["\nfinal\n","\n#define\n","\nfloat\n","\nconst\n"],"correct_choice":"\nfinal\n"},{"title":"提供java存取数据库能力的包是（）","choices":["\njava.sql\n","\njava.db;\n","\njava.lang\n","\njava.util\n"],"correct_choice":"\njava.sql\n"},{"title":"It is an important feature of the Java language that it always provides\na default constructor to a class.","choices":["\nFALSE\n","\nTRUE\n"],"correct_choice":"\nFALSE\n"},{"title":"下列有关java构造函数叙述正确的是（）","choices":["\n构造器的返回值为void类型\n","\n如果一个源文件中有多个类，那么构造器必须与公共类同名\n","\n构造器可以有0个，1个或一个以上的参数\n","\n每个类可以有一个以上的构造器\n"],"correct_choice":"\n构造器可以有0个，1个或一个以上的参数\n\n每个类可以有一个以上的构造器\n"},{"title":"\n  在Java中，main()方法的返回值的类型是： \n","choices":["\npublic\n","\nstatic\n","\nvoid\n","\nString\n"],"correct_choice":"\nvoid\n"},{"title":"以下语句的执行结果是什么？\n1+”10”+3+”2”","choices":["\n”11032”\n","\n“16”\n","\n16\n","\n“32101”\n"],"correct_choice":"\n”11032”\n"},{"title":"JMX是在哪一个JDK版本开始支持？（）","choices":["\n1.4\n","\n1.5\n","\n1.6\n","\n1.7\n"],"correct_choice":"\n1.4\n"},{"title":"\n  不考虑反射，String类型变量所指向内存空间中的内容是不能被改变的\n  。\n  （ ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  执行下列代码后，哪些结论是正确的（）？     String[] s=new String[10]; ","choices":["\ns[0]为未定义\n","\ns[9]为null\n","\ns.length为0\n","\ns[10]为” “\n"],"correct_choice":"\ns[9]为null\n"},{"title":"  类方法中可以直接调用对象变量。（ ）           ","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  在使用 interface 声明一个外部接口时，只可以使用（   ）修饰符修饰该接口。  ","choices":["\nprivate\n","\nprotected\n","\nprivate protected\n","\npublic\n"],"correct_choice":"\npublic\n"},{"title":"下面对JVM叙述不正确的是：","choices":["\nJVM的全称是Java Virtual Machine\n","\nJVM是一种计算机硬件技术，它是Java程序的运行平台\n","\nJVM是在计算机硬件系统上用软件实现的一台假想机\n","\nJava程序在执行时．JVM把Java字节码解释成机器码\n"],"correct_choice":"\nJVM是一种计算机硬件技术，它是Java程序的运行平台\n"},{"title":"以下（）不是合法的标识符？","choices":["\nSTRING\n","\nx3x\n","\nvoid\n","\ndeSf\n"],"correct_choice":"\nvoid\n"},{"title":"\n  下面哪些Java中的流对象是字节流?\n  \n","choices":["\nFileInputStream\n","\nBufferedInputStream\n","\nPushbackInputStream\n","\nByteArrayInputStream\n"],"correct_choice":"\nFileInputStream\n\nBufferedInputStream\n\nPushbackInputStream\n\nByteArrayInputStream\n"},{"title":"以下可以正确获取结果集的有","choices":["\nStatement sta=con.createStatement();<br>ResultSet rst=sta.executeQuery(“select * from book”);\n","\nStatement sta=con.createStatement(“select * from book”); ResultSet rst=sta.executeQuery();\n","\nPreparedStatement pst=con.prepareStatement();\nResultSet rst=pst.executeQuery(“select * from book”);\n","\nPreparedStatement pst=con.prepareStatement(“select * from book”);\nResultSet rst=pst.executeQuery();\n"],"correct_choice":"\nStatement sta=con.createStatement();<br>ResultSet rst=sta.executeQuery(“select * from book”);\n\nPreparedStatement pst=con.prepareStatement(“select * from book”);\nResultSet rst=pst.executeQuery();\n"},{"title":"  关于构造方法的说法哪个正确（）？ ","choices":["\n一个类只能有一个构造方法\n","\n一个类可以有多个不同名的构造方法\n","\n构造方法与类同名\n","\n构造方法必须自己定义，不能使用父类的构造方法\n"],"correct_choice":"\n构造方法与类同名\n"},{"title":"下列哪一项不属于Swing的顶层容器？（）","choices":["\nJApplet\n","\nJTree\n","\nJDialog\n","\nJFrame\n"],"correct_choice":"\nJTree\n"},{"title":"\n  对于同一类中的两个方法\n  ,\n  在判断它们是不是重载方法时\n  ,\n  不考虑（\n  ）\n","choices":["\n参数个数\n","\n参数类型\n","\n返回值类型\n","\n参数顺序\n"],"correct_choice":"\n返回值类型\n"},{"title":"\n  Java\n  语言中创建一个对象使用的关键字是（）\n","choices":["\nclass\n","\ninterface\n","\nnew\n","\ncreate\n"],"correct_choice":"\nnew\n"},{"title":"以下关于java封装的描述中，正确的是：","choices":["\n封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性\n","\n封装的意义不大，因此在编码中尽量不要使用\n","\n如果子类继承父类，对于父类中进行封装的方法，子类仍然可以直接调用\n","\n只能对一个类中的方法进行封装，不能对属性进行封装\n"],"correct_choice":"\n封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性\n"},{"title":"下面有关jdbc statement的说法错误的是？","choices":["\nJDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程\n","\n对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”\n","\nPreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值\n","\nPreparedStatement可以阻止常见的SQL注入式攻击\n"],"correct_choice":"\nPreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值\n"},{"title":"变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（） ","choices":["\n1\n","\n-(2^62+2^61+2^60+1)\n","\n2^62+2^61+2^60+1\n","\n2^59+(2^55+2^54+…+2^2+2^1+2^0)\n"],"correct_choice":"\n2^62+2^61+2^60+1\n"},{"title":"\n  在JAVA中，\n  下列标识符合法的是（）\n","choices":["\n3kyou\n","\n@163\n","\nname\n","\nwhile\n"],"correct_choice":"\nname\n"},{"title":"在try的括号里面有return一个值，那在哪里执行finally里的代码？","choices":["\n不执行finally代码\n","\nreturn前执行\n","\nreturn后执行\n"],"correct_choice":"\nreturn前执行\n"},{"title":"看以下代码： \n  文件名称：forward.jsp \n<html>  \n     <head><title> 跳转  </title> </head> \n     <body>  \n         <jsp:forward page=\"index.htm\"/>     \n     </body>\n </html> \n  如果运行以上jsp文件，地址栏的内容为","choices":["\nhttp://127.0.0.1:8080/myjsp/forward.jsp\n","\nhttp://127.0.0.1:8080/myjsp/index.jsp\n","\nhttp://127.0.0.1:8080/myjsp/index.htm\n","\nhttp://127.0.0.1:8080/myjsp/forward.htm\n"],"correct_choice":"\nhttp://127.0.0.1:8080/myjsp/forward.jsp\n"},{"title":"\n  以下哪项可能包含菜单条（ ）。\n","choices":["\nPanel\n","\nFrame\n","\nApplet\n","\nDialog\n"],"correct_choice":"\nFrame\n"},{"title":"从以下哪一个选项中可以获得Servlet的初始化参数?","choices":["\nServlet\n","\nServletContext\n","\nServletConfig\n","\nGenericServlet\n"],"correct_choice":"\nServletConfig\n"},{"title":"class Foo {\n    final int i;\n    int j;\n    public void doSomething() {\n        System.out.println(++j + i);\n    }\n}\n\n 的输出是？","choices":["\n0\n","\n1\n","\n2\n","\n不能执行，因为编译有错\n"],"correct_choice":"\n不能执行，因为编译有错\n"},{"title":"下面有关java的一些细节问题，描述错误的是？","choices":["\n构造方法不需要同步化\n","\n一个子类不可以覆盖掉父类的同步方法\n","\n定义在接口中的方法默认是public的\n","\n容器保存的是对象的引用\n"],"correct_choice":"\n一个子类不可以覆盖掉父类的同步方法\n"},{"title":"  下列 java 程序输出结果为______。 \nint i=0;\nInteger j = new Integer(0);\nSystem.out.println(i==j);\nSystem.out.println(j.equals(i));","choices":["\ntrue,false\n","\ntrue,true\n","\nfalse,true\n","\nfalse,false\n","\n对于不同的环境结果不同\n","\n程序无法执行\n"],"correct_choice":"\ntrue,true\n"},{"title":"\n  下列关于构造方法的叙述中，错误的是（）\n","choices":["\njava语言规定构造方法名与类名必须相同\n","\njava语言规定构造方法没有返回值，但不同void声明\n","\njava语言规定构造方法不可以重载\n","\njava语言规定构造方法只能通过new自动调用\n"],"correct_choice":"\njava语言规定构造方法不可以重载\n\njava语言规定构造方法只能通过new自动调用\n"},{"title":"要在session对象中保存属性，可以使用以下哪个语句(\n       ) ","choices":["\nsession.getAttribute(“key”，”value”)\n","\nsession.setAttribute(“key”，”value”)\n","\nsession.setAttribute(“key”)\n","\nsession.getAttribute(“key”)\n"],"correct_choice":"\nsession.setAttribute(“key”，”value”)\n"},{"title":"关键字()表明一个对象或变量的引用在初始化后不能被修改。","choices":["\nprivate\n","\nfinal\n","\nstatic\n","\n没有这种关键字\n"],"correct_choice":"\nfinal\n"},{"title":"  有这样一段程序： \npublic class Test{ \n    public static void main(String [] args){ \n        List list=new ArrayList(); \n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"a\");\n        Set set=new HashSet(); \n        set.add(\"a\"); \n        set.add(\"b\"); \n        set.add(\"a\"); \n        System.out.println(list.size()+\",\"+set.size()); \n    } \n}\n  请问运行主要的程序会打印出的是什么（） ","choices":["\n2,2\n","\n2,3\n","\n3,2\n","\n3,3\n"],"correct_choice":"\n3,2\n"},{"title":"\n  以下关于构造函数的描述错误的是\n  （\n  ）\n","choices":["\n每个类有且只能有一个构造函数。\n","\n构造函数是类的一种特殊函数，它的方法名必须与类名相同\n","\n构造函数的主要作用是完成对类的对象的初始化工作\n","\n一般在创建新对象时，系统会自动调用构造函数\n"],"correct_choice":"\n每个类有且只能有一个构造函数。\n"},{"title":"在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（）","choices":["\ninterface  A extends B，C\n","\ninterface  A eimplements  B，C\n","\nclass  A implements  B，C\n","\nclass  A implements  B，implements C\n"],"correct_choice":"\nclass  A implements  B，C\n"},{"title":"下列哪一种叙述是正确的（）","choices":["\nabstract修饰符可修饰字段、方法和类\n","\n抽象方法的body部分必须用一对大括号{ }包住\n","\n声明抽象方法，大括号可有可无\n","\n声明抽象方法不可写出大括号\n"],"correct_choice":"\n声明抽象方法不可写出大括号\n"},{"title":"  假设 A 类有如下定义，设 a 是 A 类的一个实例，下列语句调用哪个是错误的？（）     public class A     {     public int i;      static String s;      void method1(){}      static void method2(){}     }  ","choices":["\nSystem.out.println(a.i);\n","\na.method1();\n","\nA.method1();\n","\nA.method2();\n"],"correct_choice":"\nA.method1();\n"},{"title":" 装箱、拆箱操作发生在: ()\n","choices":["\n类与对象之间\n","\n对象与对象之间\n","\n引用类型与值类型之间\n","\n引用类型与引用类型之间\n"],"correct_choice":"\n引用类型与值类型之间\n"},{"title":"public class contained in a Java program file must have the same name as\nthe file, except for the extension \".java\".","choices":["\nFALSE\n","\nTRUE\n"],"correct_choice":"\nFALSE\n"},{"title":"\n  Java\n  多线程有几种实现方法？（\n  ）\n","choices":["\n继承Thread类\n","\n实现Runnable接口\n","\n实现Thread接口\n","\n以上都不正确\n"],"correct_choice":"\n继承Thread类\n\n实现Runnable接口\n"},{"title":"\n  一个文件中的字符要写到另一个文件中，首先需要（ ）。\n","choices":["\nSystem.out.print (buffer[i]);\n","\nFileOutputStream fout = new FileOutputStream(this.filename);\n","\nFileInputStream fin = new FileInputStream(this.filename);。\n","\nSystem.in.read(buffer)。\n"],"correct_choice":"\nFileInputStream fin = new FileInputStream(this.filename);。\n"},{"title":"  在Java中，关于HashMap类的描述，以下错误的是（）？ ","choices":["\nHashMap能够保证其中元素的顺序\n","\nHashMap允许将null用作值\n","\nHashMap允许将null用作键\n","\nHashMap使用键/值得形式保存数据\n"],"correct_choice":"\nHashMap能够保证其中元素的顺序\n"},{"title":"\n  如果一个接口Cup有个方法use()，有个类SmallCup实现接口Cup，则在类SmallCup中正确的是？  ( \n   )\n\n\n  \n","choices":["\nvoid use() { …}\n","\nprotected void use() { …}\n","\npublic void use() { …}\n","\n以上语句都可以用在类SmallCup中\n"],"correct_choice":"\npublic void use() { …}\n"},{"title":"  如下语句通过算术运算和逻辑运算之后i和 j的结果是（ ）   int i=0;\nint j=0;\nif((++i>0)||(++j>0))\n{\n//打印出i和j的值。\n}            ","choices":["\ni=0;j=0\n","\ni=1;j=1\n","\ni=0;j=1\n","\ni=1;j=0\n"],"correct_choice":"\ni=1;j=0\n"},{"title":"以下说法错误的是（）","choices":["\n其他选项均不正确\n","\njava线程类优先级相同\n","\nThread和Runnable接口没有区别\n","\n如果一个类继承了某个类，只能使用Runnable实现线程\n"],"correct_choice":"\njava线程类优先级相同\n\nThread和Runnable接口没有区别\n\n如果一个类继承了某个类，只能使用Runnable实现线程\n"},{"title":"java中下面哪些是Object类的方法（）","choices":["\nnotify()\n","\nnotifyAll()\n","\nsleep\n","\nwait()\n"],"correct_choice":"\nnotify()\n\nnotifyAll()\n\nwait()\n"},{"title":"下面代码在main()方法中第八行后可以正常使用的是（      ） public class Test\n{ \n    private int a=10; \n    int b=20; \n    static int c=1; \n    public static void main(String arg[])\n    { \n        Test t = new Test(); \n    } \n }  ","choices":["\nt.a\n","\nthis.c\n","\nTest.b\n","\nTest.c\n"],"correct_choice":"\nt.a\n\nTest.c\n"},{"title":"\n  以下为\n  java\n  语法保留不能作为类名和方法名使用的是\n","choices":["\ndefault\n","\nint\n","\nimplements\n","\nthrows\n"],"correct_choice":"\ndefault\n\nint\n\nimplements\n\nthrows\n"},{"title":"\n  下列叙述错误的是( )\n","choices":["\njava提供了丰富的类库\n","\njava很好的利用了网络资源\n","\njava支持多线程\n","\njava不支持TCP/IP协议\n"],"correct_choice":"\njava不支持TCP/IP协议\n"},{"title":"一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？","choices":["\n表对应类\n","\n记录对应对象\n","\n表的字段对应类的属性\n","\n表之间的参考关系对应类之间的依赖关系\n"],"correct_choice":"\n表之间的参考关系对应类之间的依赖关系\n"},{"title":"  假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（） \npublic static void main(String[]args)throws Exception {\n    final Object obj = new Object();\n    Thread t1 = new Thread() {\n        public void run() {\n            synchronized (obj) {\n                try {\n                    obj.wait();\n                    System.out.println(\"Thread 1 wake up.\");\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n    };\n    t1.start();\n    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.\n    Thread t2 = new Thread() {\n        public void run() {\n            synchronized (obj) {\n                obj.notifyAll();\n                System.out.println(\"Thread 2 sent notify.\");\n            }\n        }\n    };\n    t2.start();\n}\n\n","choices":["\nThread 1 wake up\nThread 2 sent notify.\n","\nThread 2 sent notify.\nThread 1 wake up\n","\nA、B皆有可能\n","\n程序无输出卡死\n"],"correct_choice":"\nThread 2 sent notify.\nThread 1 wake up\n"},{"title":"在java7中，下列不能做switch()的参数类型是？","choices":["\n整型\n","\n枚举类型\n","\n字符串\n","\n浮点型\n"],"correct_choice":"\n浮点型\n"},{"title":"在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"欲定义类字段或类方法（静态方法），应该使用下列哪一个修饰符修饰（）","choices":["\npublic\n","\nstatic\n","\nprotected\n","\nsynchronized\n"],"correct_choice":"\nstatic\n"},{"title":"  下面的程序输出的结果是( )        public class A implements B{        public static void main（String args[]）{        int i；        A a1=new  A（）；       i =a1.k；        System.out.println（“i=”+i）；       }       }       interface B       {        int k=10；        }     ","choices":["\ni=0\n","\ni=10\n","\n程序有编译错误\n","\ni=true\n"],"correct_choice":"\ni=10\n"},{"title":"\n\n  如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？\n     ( \n   )\n\n\n  \n\n","choices":["\nprotected void setColor() { …}\n","\nvoid setColor() { …}\n","\npublic void setColor() { …}\n","\n以上语句都可以用在类BlueGlass中\n"],"correct_choice":"\npublic void setColor() { …}\n"},{"title":"下列关于构造函数的描述正确的是?","choices":["\n构造函数可以声明返回类型\n","\n构造函数不可以用private修饰\n","\n构造函数必须与类名相同\n","\n构造函数不能带参数\n"],"correct_choice":"\n构造函数必须与类名相同\n"},{"title":"Which is not Java primitive types?","choices":["\nshort\n","\nBoolean\n","\nbyte\n","\nfloat\n"],"correct_choice":"\nBoolean\n"},{"title":"  检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。 \n\n  public class HelloB extends HelloA \n{\n public HelloB()\n {\n }\n {\n     System.out.println(\"I’m B class\");\n }\n static\n {\n     System.out.println(\"static B\");\n }\n public static void main(String[] args)\n {\n     new HelloB();\n }\n}\nclass HelloA\n{\n public HelloA()\n {\n }\n {\n     System.out.println(\"I’m A class\");\n }\n static\n {\n     System.out.println(\"static A\");\n }\n}\n  \n","choices":["\nstatic A\nI’m A class\nstatic B\nI’m B class\n","\nI’m A class\nI’m B class\nstatic A\nstatic B\n","\nstatic A\nstatic B\nI’m A class\nI’m B class\n","\nI’m A class\nstatic A\nI’m B class\nstatic B\n"],"correct_choice":"\nstatic A\nstatic B\nI’m A class\nI’m B class\n"},{"title":"下列语句正确的是（ ）","choices":["\n形式参数可被视为local variable\n","\n形式参数可被所有的字段修饰符修饰\n","\n形式参数为方法被调用时，是真正被传递的参数\n","\n形式参数不可以是对象\n"],"correct_choice":"\n形式参数可被视为local variable\n"},{"title":"  下列说法正确的是（）？         ","choices":["\n我们直接调用Thread对象的run方法会报异常，所以我们应该使用start方法来开启一个线程\n","\n一个进程是一个独立的运行环境，可以被看做一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源\n","\nsynchronized可以解决可见性问题，volatile可以解决原子性问题\n","\nThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的\n"],"correct_choice":"\n一个进程是一个独立的运行环境，可以被看做一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源\n\nThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的\n"},{"title":"如果子类要调用父类的构造函数，则通过super（）调用来实现。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"@SuppressWarnings(“deprecation”)的功能是什么？","choices":["\n屏蔽不赞同使用的类和方法的警告\n","\n屏蔽在强制类型转换的时候编译器给出的警告\n","\n关闭所有警告信息\n","\n当在可序列化的类上缺少serialVersionUID定义的警告\n"],"correct_choice":"\n屏蔽不赞同使用的类和方法的警告\n"},{"title":" 一个完整的URL地址由(),(),端口和文件四部分组成。","choices":["\n协议 用户名\n","\n协议 主机名\n","\n主机名 ip\n","\n以上都不正确\n"],"correct_choice":"\n协议 主机名\n"},{"title":"\n  下面哪几个函数\n  public void example(){....}\n  的重载函数？（）\n","choices":["\npublic void example(int m){...}\n","\npublic int example(){..}\n","\npublic void example2(){..}\n","\npublic int example(int m,float f){...}\n"],"correct_choice":"\npublic void example(int m){...}\n\npublic int example(int m,float f){...}\n"},{"title":"int，String，*point，union哪些不是 Java 的数据类型？","choices":["\nint\n","\nString\n","\n*point\n","\nunion\n"],"correct_choice":"\n*point\n\nunion\n"},{"title":"  以下 json 格式数据，错误的是  ","choices":["\n{company：4399}\n","\n{\"company\":{\"name\":[4399,4399,4399]}}\n","\n{[4399,4399,4399]}\n","\n{\"company\":[4399,4399,4399]}\n","\n{\"company\":{\"name\":4399}}\n"],"correct_choice":"\n{company：4399}\n\n{[4399,4399,4399]}\n"},{"title":"\n  下列关于Java类中方法的定义，正确的是（）\n","choices":["\n若代码执行到return语句，则将当前值返回，而且继续执行return语句后面的语句。\n","\n. 只需要对使用基本数据类型定义的属性使用getter和setter，体现类的封装性。\n","\n方法的返回值只能是基本数据类型。\n","\n在同一个类中定义的方法，允许方法名称相同而形参列表不同，并且返回值数据类型也不同。\n"],"correct_choice":"\n在同一个类中定义的方法，允许方法名称相同而形参列表不同，并且返回值数据类型也不同。\n"},{"title":"\n  定义一个\n  接口\n  必须使用的关键字是\n  ？\n  （\n   ）\n\n\n  \n","choices":["\npublic\n","\nclass\n","\ninterface\n","\nstatic\n"],"correct_choice":"\ninterface\n"},{"title":"\n  关于抽象类和接口叙述正确的是？ ( \n   )\n\n\n  \n","choices":["\n抽象类和接口都能实例化的\n","\n抽象类不能实现接口\n","\n抽象类方法的访问权限默认都是public\n","\n接口方法的访问权限默认都是public\n"],"correct_choice":"\n接口方法的访问权限默认都是public\n"},{"title":"下列程序的运行结果\npublic static void main(String args[]) {\n   Thread t = new Thread() {\n            public void run() {\n                pong();\n            }\n        };\n        t.run();\n        System.out.print(\"ping\");\n    }\n    static void pong() {\n        System.out.print(\"pong\");\n    }\n","choices":["\npingpong\n","\npongping\n","\npingpong和pongping都有可能\n","\n都不输出\n"],"correct_choice":"\npongping\n"},{"title":"下列代码执行结果为（） \npublic static void main(String argv[])throws InterruptedException{\n\t    \tThread t=new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(2000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.print(\"2\");\n\t\t\t\t}\n\t\t\t});\n\t    \tt.start();\n\t    \t\n\t    \tt.join();\n\t    \tSystem.out.print(\"1\");\n\t    }\n","choices":["\n21\n","\n12\n","\n可能为12，也可能为21\n","\n以上答案都不对\n"],"correct_choice":"\n21\n"},{"title":"关于Java和C/C++的比较，下列哪个描述是错误的？","choices":["\nJava不支持指针，C/C++支持\n","\nJava程序不需要显式地关心内存释放，而C/C++需要\n","\nJava和C++一样，是纯编译型语言，因此它们的class都是在编译时静态联编(static binding)的\n","\nJava数组、字符串不可能溢出，C/C++数组、字符串则有可能溢出边界\n"],"correct_choice":"\nJava和C++一样，是纯编译型语言，因此它们的class都是在编译时静态联编(static binding)的\n\nJava数组、字符串不可能溢出，C/C++数组、字符串则有可能溢出边界\n"},{"title":"下列正确的有（ ）","choices":["\ncall by value不会改变实际参数的数值\n","\ncall by reference能改变实际参数的参考地址\n","\ncall by reference不能改变实际参数的参考地址\n","\ncall by reference能改变实际参数的内容\n"],"correct_choice":"\ncall by value不会改变实际参数的数值\n\ncall by reference不能改变实际参数的参考地址\n\ncall by reference能改变实际参数的内容\n"},{"title":"\n  面向对象程序设计语言的三个基本特征是封装、继承、多态。（   ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  为Test类的一个无形式参数无返回值的方法method书写方法头，使得使用类名Test作为前缀就可以调用它，该方法头的形式为( )\n","choices":["\nstatic  void  method（）\n","\npublic void  method\n","\nprotected  void  method（）\n","\nabstract  void method（）\n"],"correct_choice":"\nstatic  void  method（）\n"},{"title":"\n  关于\n  Java\n  线程，下面说法错误的是（）。\n","choices":["\n创建线程的方法有两种：实现Runnable接口和继承Thread类\n","\njava利用线程使整个系统成为异步\n","\n新线程一旦被创建，它将自动开始运行\n"],"correct_choice":"\n新线程一旦被创建，它将自动开始运行\n"},{"title":"  java7后关键字 switch 支不支持字符串作为条件：（）  ","choices":["\n支持\n","\n不支持\n"],"correct_choice":"\n支持\n"},{"title":"  A派生出子类B，B派生出子类C，并且在java源代码中有如下声明： \n1.A a0=new A();\n2.A a1=new B();\n3.A a2=new C();\n  以下哪个说法是正确的？ ","choices":["\n第1行,第2行和第3行的声明都是正确的\n","\n第1,2,3行都能通过编译，但第2,3行运行时出错\n","\n第1,2行能通过编译，但第3行编译出错\n","\n只有第1行能通过编译\n"],"correct_choice":"\n第1行,第2行和第3行的声明都是正确的\n"},{"title":"  给定以下JAVA代码，这段代码运行后输出的结果是（）   public class Test\n{  \n    public static int aMethod(int i)throws Exception\n    {\n        try{\n            return i/10;\n        }\n        catch (Exception ex)\n        {\n            throw new Exception(\"exception in a aMethod\");\n        }finally{\n      System.out.printf(\"finally\");\n        }\n} \n    public static void main(String[] args){\n        try\n        {\n            aMethod(0);\n        }\n        catch (Exception ex)\n        {\n            System.out.printf(\"exception in main\");\n        }\n        System.out.printf(\"finished\");\n    }\n} ","choices":["\nexception in main finished\n","\nfinally finished\n","\nexception in main finally\n","\nfinally exception in main finally\n"],"correct_choice":"\nfinally finished\n"},{"title":"\n  一个类的构造器不能调用这个类中的其他构造器。（ ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"  执行以下程序，最终输出可能是：        ","choices":["\n010 2123012 3434\n","\n01201 340124 2334\n","\n0012314 01223344\n","\n12345 12345 12345\n"],"correct_choice":"\n0012314 01223344\n"},{"title":"\n  创建一个标识有“关闭”标签的语句是\n  (      )\n  。\n","choices":["\nTextField  b = new  TextField(“关闭”);\n","\nLabel  b = new  Label(“关闭”);\n","\nCheckbox  b = new  Checkbox(“关闭”);\n","\nButton   b = new  Button(“关闭”);\n"],"correct_choice":"\nLabel  b = new  Label(“关闭”);\n"},{"title":"  以下方法，哪个不是对add方法的重载? \npublic class Test\n{\n    public void add( int x,int y,int z){}\n}","choices":["\npublic int add(int x,int y,float z){return 0;}\n","\npublic int add(int x,int y,int z){return 0;}\n","\npublic void add(int x,int y){}\n","\n以上都不是\n"],"correct_choice":"\npublic int add(int x,int y,int z){return 0;}\n"},{"title":"  mysql数据库，game_order表表结构如下，下面哪些sql能使用到索引（）？     ","choices":["\nselect * from game_order where plat_game_id=5 and plat_id=134\n","\nselect * from game_order where plat_id=134 and\nplat_game_id=5 and plat_order_id=’100’\n","\nselect * from game_order where plat_order_id=’100’\n","\nselect * from game_order where plat_game_id=5 and\nplat_order_id=’100’ and plat_id=134\n","\nselect * from game_order where plat_game_id=5 and plat_order_id=’100’\n"],"correct_choice":"\nselect * from game_order where plat_id=134 and\nplat_game_id=5 and plat_order_id=’100’\n\nselect * from game_order where plat_game_id=5 and\nplat_order_id=’100’ and plat_id=134\n"},{"title":"  以下哪些方法可以取到http请求中的cookie值（）? ","choices":["\nrequest.getAttribute\n","\nrequest.getHeader\n","\nrequest.getParameter\n","\nrequest.getCookies\n"],"correct_choice":"\nrequest.getHeader\n\nrequest.getCookies\n"},{"title":"\n  执行如下代码段后，变量s1引用的字符串值是(    )。\n\n\n  \n    \n      \n          String s1 =   \"ABCD\";\n        \n        \n          String s2 =   \"1234\";\n        \n        \n          System.out.println(s1   + s2);\n        \n      \n  \n\n\n  \n","choices":["\nABCD\n","\n1234\n","\nABCD1234\n","\n1234ABCD\n"],"correct_choice":"\nABCD\n"},{"title":"若有定义：byte[]x={11,22,33,﹣66}；其中0≤k≤3，则对x数组元素错误的引用是（）","choices":["\nx[5-3]\n","\nx[k]\n","\nx[k+5]\n","\nx[0]\n"],"correct_choice":"\nx[k+5]\n"},{"title":"下列语句哪一个正确（ ）","choices":["\nJava程序经编译后会产生machine code\n","\nJava程序经编译后会产生byte code\n","\nJava程序经编译后会产生DLL\n","\n以上都不正确\n"],"correct_choice":"\nJava程序经编译后会产生byte code\n"},{"title":"关于JAVA的垃圾回收机制，下面哪些结论是正确？","choices":["\n程序可以任意指定释放内存的时间\n","\nJAVA程序不能依赖于垃圾回收的时间或者顺序\n","\n程序可明确地标识某个局部变量的引用不再被使用\n","\n程序可以显式地立即释放对象占有的内存\n"],"correct_choice":"\nJAVA程序不能依赖于垃圾回收的时间或者顺序\n"},{"title":"Java程序的种类有（ ）","choices":["\n类（Class）\n","\nApplet\n","\nApplication\n","\nServlet\n"],"correct_choice":"\nApplet\n\nApplication\n\nServlet\n"},{"title":"\n  如果要建立一个java.scut.computer的包，叙述正确的是？  ( \n   )\n\n\n  \n","choices":["\n只需在代码中加入“package java.scut.computer;”一个语句\n","\n只需在代码中加入“package java.scut;”一个语句\n","\n必须在代码中加入“package java.scut;”和“package java.scut.computer;”两个语句\n","\n在代码中，不一定是第一句，只要是类定义前，加入package语句即可\n"],"correct_choice":"\n只需在代码中加入“package java.scut.computer;”一个语句\n"},{"title":"  以下代码输出的是： \npublic class SendValue{\n\tpublic String str=\"6\";\n\tpublic static void main(String[] args) {\n\t\tSendValue sv=new SendValue();\n\t\tsv.change(sv.str);\n\t\tSystem.out.println(sv.str);\n\t}\n\tpublic void change(String str) {\n\t\tstr=\"10\";\n\t}\n}\n","choices":["\n6\n","\n10\n","\n都不对\n","\n16\n"],"correct_choice":"\n6\n"},{"title":"下面有关maven和ant的描述，描述错误的是？","choices":["\nAnt 没有正式的约定如一个一般项目的目录结构，你必须明确的告诉 Ant 哪里去找源代码\n","\nMaven 拥有约定，因为你遵循了约定，它已经知道你的源代码在哪里\n","\nmaven和ant都有“生命周期”的概念，当你输入一个命令后，maven或者ant会执行一系列的有序的步骤，直到到达你指定的生命周期\n","\nAnt构建文件默认命名为build.xml，Maven默认构建文件为pom.xml\n"],"correct_choice":"\nmaven和ant都有“生命周期”的概念，当你输入一个命令后，maven或者ant会执行一系列的有序的步骤，直到到达你指定的生命周期\n"},{"title":"\n  Test.main()\n  函数执行后的输出是（）\n\n\n  \n\n\n  \n","choices":["\n11 17 34\n","\n22 74 74\n","\n6 7 7\n","\n22 34 17\n"],"correct_choice":"\n22 34 17\n"},{"title":"有关finally语句块说法正确的是（      ）","choices":["\n不管 try 语句块正常结束还是异常结束，finally语句块都是要被执行的\n","\n在try语句块或catch语句块中执行到System.exit(0)直接退出程序\n","\nfinally块中的return语句会覆盖try块中的return返回\n","\nfinally 语句块在 catch语句块中的return语句之前执行\n"],"correct_choice":"\n不管 try 语句块正常结束还是异常结束，finally语句块都是要被执行的\n\n在try语句块或catch语句块中执行到System.exit(0)直接退出程序\n\nfinally块中的return语句会覆盖try块中的return返回\n\nfinally 语句块在 catch语句块中的return语句之前执行\n"},{"title":"类中的数据域使用private修饰为私有变量，所以任何方法均不能访问它。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"扩展方法是否能访问被扩展对象的成员？判断这句话是否正确","choices":["\n能\n","\n不能\n"],"correct_choice":"\n不能\n"},{"title":"下列Java常见事件类中哪个是鼠标事件类？（） \n\n","choices":["\nInputEvent\n","\nKeyEvent\n","\nMouseEvent\n","\nWindowEvent\n"],"correct_choice":"\nMouseEvent\n"},{"title":"下面有关final, finally, finalize的区别描述错误的是？","choices":["\n如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承\n","\n如果一个方法被声明为final，可以被覆盖\n","\nfinally在异常处理时提供 finally 块来执行任何清除操作。\n","\nJava使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作\n"],"correct_choice":"\n如果一个方法被声明为final，可以被覆盖\n"},{"title":"  J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（   \n    ）方法\n","choices":["\nservice\n","\ndoget\n","\ndopost\n","\ninit\n"],"correct_choice":"\nservice\n"},{"title":"下面有关JAVA swing的描述，说法错误的是？","choices":["\nSwing是一个基于Java的跨平台MVC框架。使用单线程模式。\n","\nSwing 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的\n","\nSwing优化了AWT，运行速度比AWT快\n","\nSwing是一个基于组件的框架，所有的组件都是从javax.swing.JComponent类继承来的\n"],"correct_choice":"\nSwing优化了AWT，运行速度比AWT快\n"},{"title":"  有关静态初始化块说法正确的是？ ","choices":["\n无法直接调用静态初始化块\n","\n在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化\n","\n静态初始化块既没有访问修饰符，也没有参数\n","\n在程序中，用户可以控制合适执行静态初始化块\n"],"correct_choice":"\n无法直接调用静态初始化块\n\n在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化\n\n静态初始化块既没有访问修饰符，也没有参数\n"},{"title":"  JAVA中，下列语句哪一个正确（） ","choices":["\nclass中的constructor不可省略\n","\nconstructor必须与class同名，但方法不能与class同名\n","\nconstructor在一个对象被new时执行\n","\n一个class只能定义一个constructor\n"],"correct_choice":"\nconstructor在一个对象被new时执行\n"},{"title":"\n  关于\n  Socket\n  通信编程，以下描述正确的是：（ ）\n","choices":["\n客户端通过new ServerSocket()创建TCP连接对象\n","\n客户端通过TCP连接对象调用accept()方法创建通信的Socket对象\n","\n客户端通过new Socket()方法创建通信的Socket对象\n","\n服务器端通过new ServerSocket()创建通信的Socket对象\n"],"correct_choice":"\n客户端通过new Socket()方法创建通信的Socket对象\n"},{"title":"已知\n声明并初始化二维数组\nint a[ ][ ]={{1,2},{3,4},{5,6}}\n，则\na[1][1]\n的值为（）","choices":["\n1\n","\n2\n","\n4\n","\n5\n"],"correct_choice":"\n4\n"},{"title":"  以下哪些继承自 Collection 接口（）  ","choices":["\nList\n","\nSet\n","\nMap\n","\nArray\n"],"correct_choice":"\nList\n\nSet\n"},{"title":"  You have the following code.Which numbers will cause “Test2” to\n  be printed? \nswitch (x)\n{\n    case 1: System.out.println(\"Test1\");\n    case 2:\n    case 3:\n        System.out.println(\"Test2\");\n        break;\n    default:\n    System.out.println(\"Test3\");\n    break;\n}\n\n\t\n\n\n","choices":["\n0\n","\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n1\n\n2\n\n3\n"},{"title":"在J2EE中，使用Servlet过滤器，需要在web.xml中配置（）元素","choices":["\n<filter>\n","\n<filter-mapping>\n","\n<servlet-filter>\n","\n<filter-config>\n"],"correct_choice":"\n<filter>\n\n<filter-mapping>\n"},{"title":"\n  在使用\n  interface\n  声明一个接口时，只可以使用（）修饰符修饰该接口\n","choices":["\nprivate\n","\nprotected\n","\nprivate protected\n","\npublic\n"],"correct_choice":"\npublic\n"},{"title":"下面有关JSP内置对象的描述，说法错误的是？","choices":["\nsession对象：session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止\n","\nrequest对象：客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应\n","\napplication对象：多个application对象实现了用户间数据的共享，可存放全局变量\n","\nresponse对象：response对象包含了响应客户请求的有关信息\n"],"correct_choice":"\napplication对象：多个application对象实现了用户间数据的共享，可存放全局变量\n"},{"title":"下列不属于算法结构的是（）","choices":["\n输入数据\n","\n处理数据\n","\n存储数据\n","\n输出结果\n"],"correct_choice":"\n存储数据\n"},{"title":"对Collection和Collections描述正确的是","choices":["\nCollection是java.util下的类，它包含有各种有关集合操作的静态方法\n","\nCollection是java.util下的接口，它是各种集合结构的父接口\n","\nCollections是java.util下的接口，它是各种集合结构的父接口\n","\nCollections是java.util下的类，它包含有各种有关集合操作的静态方法\n"],"correct_choice":"\nCollection是java.util下的接口，它是各种集合结构的父接口\n\nCollections是java.util下的类，它包含有各种有关集合操作的静态方法\n"},{"title":"\n  在Java中，对于不再使用的内存资源，如调用完成的方法，“垃圾回收器”会自动将其释放。（  ）\n\n\n\n  \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  java\n  中哪个关键字可以对对象加互斥锁？\n","choices":["\ntransient\n","\nsynchronized\n","\nserialize\n","\nstatic\n"],"correct_choice":"\nsynchronized\n"},{"title":"\n  以下哪项是错误的（ \n  ）。\n","choices":["\nJPanel中不能包含按钮。\n","\nFrame 中可以设置Panel。\n","\nApplet 中可以包含按钮。\n","\nDialog 中不可以设置菜单条。\n"],"correct_choice":"\nJPanel中不能包含按钮。\n"},{"title":"关于 java 的异常处理机制的叙述哪些正确？","choices":["\n不论程序是否发生错误及捕捉到异常情况，都会执行finally部分\n","\n当try区段的程序发生异常时，才会执行catch区段的程序\n","\ncatch部分捕捉到异常情况时，才会执行finally部分\n","\n其它选项都不正确\n"],"correct_choice":"\n不论程序是否发生错误及捕捉到异常情况，都会执行finally部分\n\n当try区段的程序发生异常时，才会执行catch区段的程序\n"},{"title":"\n  下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（\n  ）\n","choices":["\npublic\n","\nprivate\n","\nstatic\n","\nfinal\n"],"correct_choice":"\nstatic\n"},{"title":"通过HttpServletRequest. getParameter获取的参数.","choices":["\n总是采用UTF-8编码\n","\n总是采用lS08859-1编码\n","\n由客户端浏览器和Web容器配置共同决定编码\n","\n由服务器所在的操作系统决定编码\n"],"correct_choice":"\n由客户端浏览器和Web容器配置共同决定编码\n"},{"title":"  下面程序的输出是什么？ \npackage algorithms.com.guan.javajicu;\npublic class TestDemo\n{\n    public static String output = ””;\n    public static void foo(inti)\n    {\n        try\n        {\n            if (i == 1)\n            {\n                throw new Exception();\n            }\n        }\n        catch (Exception e)\n        {\n            output += “2”;\n            return ;\n        } finally\n        {\n            output += “3”;\n        }\n        output += “4”;\n    }\n    public static void main(String[] args)\n    {\n        foo(0);\n        foo(1);\n        System.out.println(output);\n    }\n}\n\n","choices":["\n342\n","\n3423\n","\n34234\n","\n323\n"],"correct_choice":"\n3423\n"},{"title":"下面哪项技术可以用在WEB开发中实现会话跟踪实现？","choices":["\nsession\n","\nCookie\n","\n地址重写\n","\n隐藏域\n"],"correct_choice":"\nsession\n\nCookie\n\n地址重写\n\n隐藏域\n"},{"title":"\n  以下哪个接口的定义是正确的？（ ）\n","choices":["\ninterface  B\n{  void print()  {  } ;}\n","\ninterface  B\n{ static void print() ;}\n","\nabstract  interface  B  extends  A1, A2  //A1、A2为已定义的接口\n{ abstract  void  print(){  };}\n","\ninterface  B\n {  void  print();}\n"],"correct_choice":"\ninterface  B\n {  void  print();}\n"},{"title":"\n  面向对象程序设计语言的三个基本特征是？(    )\n\n\n  \n","choices":["\n封装、接口和多态\n","\n继承、接口和动态\n","\n跨平台、接口和动态\n","\n封装、继承和多态\n"],"correct_choice":"\n封装、继承和多态\n"},{"title":"以下Java程序运行的结果是: public class Tester{\npublic static void main(String[] args){\n   Integer var1=new Integer(1);\n   Integer var2=var1;\n   doSomething(var2);\n   System.out.print(var1.intValue());\n   System.out.print(var1==var2);\n}\npublic static void doSomething(Integer integer){\n    integer=new Integer(2);\n    }\n}\n","choices":["\n1true\n","\n2true\n","\n1false\n","\n2false\n"],"correct_choice":"\n1true\n"},{"title":"  以下哪个不属于JVM堆内存中的区域（）？ ","choices":["\nsurvivor区\n","\n常量池\n","\neden区\n","\nold区\n"],"correct_choice":"\n常量池\n"},{"title":"  下面代码的执行结果是 :    class Chinese{        private static  Chinese objref =new Chinese();        private Chinese(){}        public static Chinese getInstance() {         return objref;     }    }        public class TestChinese {        public static void main(String [] args)       {        Chinese obj1 = Chinese.getInstance();        Chinese obj2 = Chinese.getInstance();        System.out.println(obj1 == obj2);    }    } ","choices":["\ntrue\n","\nfalse\n","\nTRUE\n","\nFALSE\n"],"correct_choice":"\ntrue\n"},{"title":"  有如下代码：请写出程序的输出结果。 \npublic class Test\n{\n    public static void main(String[] args)\n    {\n        int x = 0;\n        int y = 0;\n        int k = 0;\n        for (int z = 0; z < 5; z++) { \n            if ((++x > 2) && (++y > 2) && (k++ > 2))\n            {\n                x++;\n                ++y;\n                k++;\n            }\n        }\n        System.out.println(x + ”” +y + ”” +k);\n    }\n}\n\n","choices":["\n432\n","\n531\n","\n421\n","\n523\n"],"correct_choice":"\n531\n"},{"title":"\n  一个抽象类并不需要其中所有的方法都是抽象的。（   ）\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  Java中equal和==的区别是什么？ \npublic class Test1{\n    public static void main(String args[]){\n            String a=\"1234\";\n            String b=\"1234\";\n            String c = new String(\"1234\");\n            System.out.println(a==b);\n            System.out.println(a==c);\n            System.out.println(a.equals(c));\n    }\n}\n\n","choices":["\ntrue\nfalse\ntrue\n","\ntrue\ntrue\nfalse\n","\ntrue\nfalse\nfalse\n","\ntrue\ntrue\ntrue\n"],"correct_choice":"\ntrue\nfalse\ntrue\n"},{"title":"\n  一个文件中的数据要在控制台上显示，首先需要（ ）。\n","choices":["\n使用标准输出流System.out.println()。\n","\n建立文件输出流。\n","\n建立文件输入流。\n","\n标准输入流System.in.read()。\n"],"correct_choice":"\n建立文件输入流。\n"},{"title":"请问所有的异常类皆直接继承于哪一个类？（）","choices":["\njava.applet.Applet\n","\njava.lang.Throwable\n","\njava.lang.Exception\n","\njava.lang.Error\n"],"correct_choice":"\njava.lang.Exception\n"},{"title":"在（    ）情况下适宜采用内联函数。","choices":["\n函数代码小，频繁调用\n","\n函数代码多，频繁调用\n","\n函数体含有递归语句\n","\n函数体含有循环语句\n"],"correct_choice":"\n函数代码小，频繁调用\n"},{"title":"Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段，以下过程属于初始化阶段是（）。","choices":["\n加载Servlet类及.class对应的数据\n","\n创建serletRequest和servletResponse对象\n","\n创建ServletConfig对象\n","\n创建Servlet对象\n"],"correct_choice":"\n加载Servlet类及.class对应的数据\n\n创建ServletConfig对象\n\n创建Servlet对象\n"},{"title":"\n  要表示10个学生的成绩，下列声明并初始化数组正确的是（）\n","choices":["\nint[] score=new int[ ]\n","\nint score[10]\n","\nint score[]=new int[9]\n","\nint score[]=new int[10]\n"],"correct_choice":"\nint score[]=new int[10]\n"},{"title":"在Java中，以下关于方法重载和方法重写描述正确的是？","choices":["\n方法重载和方法的重写实现的功能相同\n","\n方法重载出现在父子关系中，方法重写是在同一类中\n","\n方法重载的返回值类型必须一致，参数项必须不同\n","\n方法重写的返回值类型必须相同或相容。\n"],"correct_choice":"\n方法重写的返回值类型必须相同或相容。\n"},{"title":"下面哪个语句是创建数组的正确语句？( )\n","choices":["\nfloat f[][] = new float[6][6];\n","\nfloat []f[] = new float[6][6];\n","\nfloat f[][] = new float[][6];\n","\nfloat [][]f = new float[6][6];\n","\nfloat [][]f = new float[6][];\n"],"correct_choice":"\nfloat f[][] = new float[6][6];\n\nfloat []f[] = new float[6][6];\n\nfloat [][]f = new float[6][6];\n\nfloat [][]f = new float[6][];\n"},{"title":"以下集合对象中哪几个是线程安全的？(       )","choices":["\nArrayList\n","\nVector\n","\nHashtable\n","\nStack\n"],"correct_choice":"\nVector\n\nHashtable\n\nStack\n"},{"title":"\n  类Parent和Child定义如下：\n\n\n  \n    \n      \n          1\n          ．class  Parent{\n          \n        \n        \n          2.         public    float  aFun(float a, float b) {   }\n        \n        \n          3\n          ．}\n          \n        \n        \n          4\n          ．class  Child    extends  Parent{\n          \n        \n        \n          5\n          ．\n        \n        \n          6\n          ．}\n          \n        \n      \n  \n\n\n  将以下哪种方法插入行5是不合法的。（    ）\n","choices":["\nfloat aFun(float  a,  float  b){ }\n","\npublic int aFun(int a, int b) { }\n","\npublic float aFun(float  p,  float q){ }\n","\nprivate int aFun(int a,  int  b){ }\n"],"correct_choice":"\nfloat aFun(float  a,  float  b){ }\n"},{"title":"\n  main\n  方法是\n  Java Application\n  程序执行的入口点，关于\n  main\n  方法的方法头以下哪项是合法的（\n  ）？\n","choices":["\npublic static void main()\n","\npublic static void main(String args[])\n","\npublic static int main(String [] arg)\n","\npublic void main(String arg[])\n"],"correct_choice":"\npublic static void main(String args[])\n"},{"title":"一个Java源程序文件中定义几个类和接口，则编译该文件后生成几个以.class为后缀的字节码文件。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"下面关于垃圾收集的描述哪个是错误的？","choices":["\n使用垃圾收集的程序不需要明确释放对象\n","\n现代垃圾收集能够处理循环引用问题\n","\n垃圾收集能提高程序员效率\n","\n使用垃圾收集的语言没有内在泄漏问题\n"],"correct_choice":"\n使用垃圾收集的语言没有内在泄漏问题\n"},{"title":"  关于以下程序代码的说明正确的是() \n public class HasStatic {// 1\n\tprivate static int x = 100;// 2\n\tpublic static void main(String args[]) {// 3\n\t\tHasStatic hsl = new HasStatic();// 4\n\t\thsl.x++;// 5\n\t\tHasStatic hs2 = new HasStatic();// 6\n\t\ths2.x++;// 7\n\t\thsl = new HasStatic();// 8\n\t\thsl.x++;// 9\n\t\tHasStatic.x--;// 10\n\t\tSystem.out.println(\" x=\" + x);// 11\n\t}\n}","choices":["\n程序通过编译，输出结果为:x=102\n","\n程序通过编译，输出结果为:x=103\n","\n10行不能通过编译.因为x星私有静态变量\n","\n5行不能通过编译.因为引用了私有静态变量\n"],"correct_choice":"\n程序通过编译，输出结果为:x=102\n"},{"title":"jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些","choices":["\n栈空间满\n","\n年轻代空间满\n","\n老年代满\n","\n持久代满\n","\nSystem.gc()\n"],"correct_choice":"\n老年代满\n\n持久代满\n\nSystem.gc()\n"},{"title":"在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？","choices":["\n封装\n","\n多态\n","\n继承\n","\n抽象\n"],"correct_choice":"\n封装\n"},{"title":"执行如下代码后输出结果为（      ）\npublic class Test {\n public static void main(String[] args) {\n     System.out.println(\"return value of getValue(): \" + getValue());\n }\n public static int getValue() {\n     int i = 1;\n     try {\n         i = 4;\n     } finally{\n         i++;\n         return i;\n     }\n     }\n }","choices":["\nreturn value of getValue(): 1\n","\nreturn value of getValue(): 4\n","\nreturn value of getValue(): 5\n","\n其他几项都不对\n"],"correct_choice":"\nreturn value of getValue(): 5\n"},{"title":"  下面的对象创建方法中哪些会调用构造方法 （）？ ","choices":["\nnew语句创建对象\n","\n调用Java.io.ObjectInputStream的readObject方法\n","\njava反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法\n","\n调用对象的clone()方法\n"],"correct_choice":"\nnew语句创建对象\n\njava反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法\n"},{"title":"下面有关java classloader说法错误的是?","choices":["\nJava默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader\n","\nClassLoader使用的是双亲委托模型来搜索类的\n","\nJVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关\n","\nClassLoader就是用来动态加载class文件到内存当中用的\n"],"correct_choice":"\nJVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关\n"},{"title":"Java是从（）语言改进重新设计","choices":["\nAda\n","\nC++\n","\nPascal\n","\nBASIC\n"],"correct_choice":"\nC++\n"},{"title":"下列关于容器集合类的说法正确的是？","choices":["\nLinkedList继承自List\n","\nAbstractSet继承自Set\n","\nHashSet继承自AbstractSet\n","\nWeakMap继承自HashMap\n"],"correct_choice":"\nHashSet继承自AbstractSet\n"},{"title":"Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。","choices":["\nstop\n","\nsleep\n","\nwait\n","\nsuspend\n"],"correct_choice":"\nsuspend\n"},{"title":"若需要定义一个类，下列哪些修饰符是允许被使用的？（\n）","choices":["\nstatic\n","\npackage\n","\nprivate\n","\npublic\n"],"correct_choice":"\nstatic\n\nprivate\n\npublic\n"},{"title":"\n  如果int x=20, y=5，则语句System.out.println(x+y\n    +\"\"+(x+y)+y);  的输出结果是（）\n","choices":["\n2530\n","\n55\n","\n2052055\n","\n25255\n"],"correct_choice":"\n25255\n"},{"title":"  给出以下代码 \n  public class TestObj{ \n    public static void main(String[] args){\n        Object o=new Object(){\n            public boolean equals(Object obj){\n                return true;\n            }\n        }; \n        System.out.println(o.equals(“Fred”));\n    }\n} \n  请给出结果：（） ","choices":["\n运行时抛出异常\n","\ntrue\n","\nFred\n","\n第三行编译错误\n"],"correct_choice":"\ntrue\n"},{"title":"下列哪个是合法的\nJava\n标识符？（\n\n）","choices":["\nTree&Glasses\n","\nFirstJavaApplet\n","\nFirstJavaApplet\n","\n273.5\n"],"correct_choice":"\nFirstJavaApplet\n\nFirstJavaApplet\n"},{"title":"\n  阅读以下\n  foo\n  函数，请问它的时间复杂度是：\n\n\n  int foo(intarray[], int n, int key) \n\n\n  { \n\n\n   int n1=0,n2=n-1,m; \n\n\n   while(n1<=n2) \n\n\n  { \n\n\n   m=(n1+n2)/2; \n\n\n   if(array[m]==key) \n\n\n   return m; \n\n\n   if(array[m]>key) \n\n\n   n2=m-1; \n\n\n   else \n\n\n   n1=m+1; \n\n\n  } \n\n\n  return -1; \n\n\n  } \n","choices":["\nO(n2)\n","\nO(n)\n","\nO(log(n))\n","\nO(n)\n"],"correct_choice":"\nO(log(n))\n"},{"title":"下面的方法，当输入为2的时候返回值是多少?\npublic static int getValue(int i) {\n        int result = 0;\n        switch (i) {\n        case 1:\n            result = result + i;\n        case 2:\n            result = result + i * 2;\n        case 3:\n            result = result + i * 3;\n        }\n        return result;\n}\n","choices":["\n0\n","\n2\n","\n4\n","\n10\n"],"correct_choice":"\n10\n"},{"title":"以下JAVA程序的输出是什么（）\npublic class HelloSogou{\n     public static synchronized void main(String[] a){\n         Thread t=new Thread(){\n             public void run(){Sogou();}\n     };\n     t.run();\n     System.out.print(\"Hello\");\n     }\n     static synchronized void Sogou(){\n     System.out.print(\"Sogou\");\n    }\n}","choices":["\nHelloSogou\n","\nSogouHello\n","\nHello\n","\n结果不确定\n"],"correct_choice":"\nSogouHello\n"},{"title":"  如下代码的输出是 \npackage Test;\npublic class Test {\n    private static void test(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            try {\n                if (arr[i] % 2 == 0) {\n                    throw new NullPointerException();\n                } else {\n                    System.out.print(i);\n                }\n            } finally {\n                System.out.print(\"e\");\n            }\n        }\n    }\n\n    public static void main(String[]args) {\n        try {\n            test(new int[] {0, 1, 2, 3, 4, 5});\n        } catch (Exception e) {\n            System.out.print(\"E\");\n        }\n    }\n\n}\n\n  可以得到的结论是（ ） ","choices":["\n编译出错\n","\neE\n","\nEe\n","\neE1eE3eE5\n","\nEe1Ee3Ee5\n"],"correct_choice":"\neE\n"},{"title":"void waitForSignal()\n{\n    Object obj = new Object();\n    synchronized(Thread.currentThread())\n    {\n        obj.wait();\n        obj.notify();\n    }\n}\n\n  Which statement is true? \n","choices":["\nThis code may throw an InterruptedException\n","\nThis code may throw an IllegalStateException\n","\nThis code may throw a TimeOutException after ten minutes\n","\nThis code will not compile unless”obj.wait()”is replaced with”(Thread)obj).wait()”\n","\nReversing the order of obj.wait()and obj.notify()may cause this method to complete normally\n"],"correct_choice":"\nThis code may throw an InterruptedException\n"},{"title":"\n  下面哪几个语句正确的声明一个整型的二维数组（）\n","choices":["\nint a[][]=new int[][]\n","\nint b[10][10]=new int[][]\n","\nint c[][]=new int[10][10]\n","\nint []d[]=new int[10][10]\n"],"correct_choice":"\nint c[][]=new int[10][10]\n\nint []d[]=new int[10][10]\n"},{"title":"\n  关于下面的程序Test.java说法正确的是(    )。\n\n\n  \n    \n      \n          public class Test {\n        \n        \n          static String x=\"1\"; \n        \n        \n          static int y=1;\n        \n        \n          public static void main(String args[]) { \n        \n        \n          static int z=2; \n        \n        \n          System.out.println(x+y+z);\n        \n        \n          } \n        \n        \n          }\n        \n      \n  \n","choices":["\n3\n","\n112\n","\n13\n","\n程序有编译错误\n"],"correct_choice":"\n程序有编译错误\n"},{"title":"JUnit主要用来完成什么","choices":["\n发送HTTP请求\n","\n建立TCP连接\n","\n集成测试\n","\n单元测试\n"],"correct_choice":"\n单元测试\n"},{"title":"有如下一段代码，请选择其运行结果（）\npublic class StringDemo{\n  private static final String MESSAGE=\"taobao\";\n  public static void main(String [] args) {\n    String a =\"tao\"+\"bao\";\n    String b=\"tao\";\n    String c=\"bao\";\n    System.out.println(a==MESSAGE);\n    System.out.println((b+c)==MESSAGE);\n  }\n}  ","choices":["\ntrue true\n","\nfalse false\n","\ntrue false\n","\nfalse true\n"],"correct_choice":"\ntrue false\n"},{"title":"下面有关servlet和cgi的描述，说法错误的是？","choices":["\nservlet处于服务器进程中，它通过多线程方式运行其service方法\n","\nCGI对每个请求都产生新的进程，服务完成后就销毁\n","\nservlet在易用性上强于cgi，它提供了大量的实用工具例程，例如自动地解析和解码HTML表单数据、读取和设置HTTP头、处理Cookie、跟踪会话状态等\n","\ncgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi\n"],"correct_choice":"\ncgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi\n"},{"title":"  Given: \npublic class IfTest{\n    public static void main(string[]args){\n        int x=3;\n        int y=1;\n        if(x=y)\n            System.out.println(“Not equal”);\n        else\n            System.out.println(“Equal”);\n     }\n}\n What is the result?","choices":["\nThe output is “Equal”\n","\nThe output in “Not Equal”\n","\nAn error at line 5 causes compilation to fall.\n","\nThe program executes but does not print a message.\n"],"correct_choice":"\nAn error at line 5 causes compilation to fall.\n"},{"title":"Java语言中，方法的重写（Overriding）和重载（Overloading）是多态性的不同表现。下边哪些说法是对的？","choices":["\n重写是父类与子类之间多态性的一种表现\n","\n重写是一个类中多态性的一种表现\n","\n重载是一个类中多态性的一种表现\n","\n重载是父类与子类之间多态性的一种表现\n"],"correct_choice":"\n重写是父类与子类之间多态性的一种表现\n\n重载是一个类中多态性的一种表现\n"},{"title":"\n  关于\n  访问权限说法正确\n  的是\n  ？\n   (    )\n","choices":["\n类定义前面可以修饰public,protected和private\n","\n内部类前面可以修饰public,protected和private\n","\n局部内部类前面可以修饰public,protected和private\n","\n以上说法都不正确\n"],"correct_choice":"\n内部类前面可以修饰public,protected和private\n"},{"title":"\n  关于构造\n  器\n  的说法哪个正确？（\n  ）\n\n\n  \n","choices":["\n一个类只能有一个构造器\n","\n一个类可以有多个不同名的构造器\n","\n构造器与类同名\n","\n构造器必须自己定义，不能使用父类的构造器\n"],"correct_choice":"\n构造器与类同名\n"},{"title":"  下列哪种情况可以终止当前线程的运行？  ","choices":["\n当一个优先级高的线程进入就绪状态时\n","\n当该线程调用sleep()方法时\n","\n当创建一个新线程时\n","\n抛出一个异常时\n"],"correct_choice":"\n抛出一个异常时\n"},{"title":"\n  在JAVA中，下列哪些是Object类的方法（）\n","choices":["\nsynchronized()\n","\nwait()\n","\nnotify()\n","\nnotifyAll()\n","\nsleep()\n"],"correct_choice":"\nwait()\n\nnotify()\n\nnotifyAll()\n"},{"title":"\n  下面这三条语句\n\nSystem.out.println(“is ”+ 100 + 5)；\nSystem.out.println(100 + 5 +“ is”)；\nSystem.out.println(“is ”+ (100 + 5))；\n\n  的输出结果分别是？ ( \n   )\n\n\n  \n","choices":["\nis 1005, 1005 is, is 1005\n","\nis 105, 105 is, is 105\n","\nis 1005, 1005 is, is 105\n","\nis 1005, 105 is, is 105\n"],"correct_choice":"\nis 1005, 105 is, is 105\n"},{"title":"\n  现有一变量声明为\n  boolean aa;\n  下面赋值语句中正确的是\n  （\n  ）\n","choices":["\naa=false;\n","\naa=False;\n","\naa=\"true\";\n","\naa=0;\n"],"correct_choice":"\naa=false;\n"},{"title":"  以下程序段的输出结果为： \npublic class EqualsMethod\n{\n    public static void main(String[] args)\n    {\n        Integer n1 = new Integer(47);\n        Integer n2 = new Integer(47);\n        System.out.print(n1 == n2);\n        System.out.print(\",\");\n        System.out.println(n1 != n2);\n    }\n}\n\n","choices":["\nfalse，false\n","\nfalse，true\n","\ntrue，false\n","\ntrue，true\n"],"correct_choice":"\nfalse，true\n"},{"title":"java中提供了哪两种用于多态的机制","choices":["\n通过子类对父类抽象方法的覆盖实现多态\n","\n利用重载来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。\n","\n利用覆盖来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。\n","\n通过子类对父类抽象方法的重载实现多态\n"],"correct_choice":"\n通过子类对父类抽象方法的覆盖实现多态\n\n利用重载来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。\n"},{"title":"子类要调用继承自父类的方法，必须使用super关键字。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"类声明中，声明一个类不能再被继承的关键字是（）","choices":["\npublic\n","\nabstract\n","\nfinal\n","\nstatic\n"],"correct_choice":"\nfinal\n"},{"title":"ArrayList和LinkList的描述，下面说法错误的是？","choices":["\nLinkedeList和ArrayList都实现了List接口\n","\nArrayList是可改变大小的数组，而LinkedList是双向链接串列\n","\nLinkedList不支持高效的随机元素访问\n","\n在LinkedList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在ArrayList的中间插入或删除一个元素的开销是固定的\n"],"correct_choice":"\n在LinkedList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在ArrayList的中间插入或删除一个元素的开销是固定的\n"},{"title":"\n  Java的跨平台特性是指它的源代码可以在多个平台运行。\n","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  关于依赖注入，下列选项中说法错误的是（）？ ","choices":["\n依赖注入能够独立开发各组件，然后根据组件间关系进行组装\n","\n依赖注入提供使用接口编程\n","\n依赖注入使组件之间相互依赖，相互制约\n","\n依赖注入指对象在使用时动态注入\n"],"correct_choice":"\n依赖注入使组件之间相互依赖，相互制约\n"},{"title":"给定以下JAVA代码，这段代码运行后输出的结果是（）\npublic class Test\n{\n    public static int aMethod(int i)throws Exception\n    {\n        try{\n            return i / 10;\n        }\n        catch (Exception ex)\n        {\n            throw new Exception(\"exception in a Method\");\n        } finally{\n            System.out.printf(\"finally\");\n        }\n    }\n\n    public static void main(String [] args)\n    {\n        try\n        {\n            aMethod(0);\n        }\n        catch (Exception ex)\n        {\n            System.out.printf(\"exception in main\");\n        }\n        System.out.printf(\"finished\");\n    }\n}\n\n\t\n\n\n","choices":["\nexception in main finished\n","\nfinally finished\n","\nexception in main finally\n","\nfinally exception in main finished\n"],"correct_choice":"\nfinally finished\n"},{"title":"\n  java\n  的字符类型采用的是\n  Unicode\n  编码方案，每个\n  Unicode\n  码占用（）个比特位。\n","choices":["\n8\n","\n16\n","\n32\n","\n64\n"],"correct_choice":"\n16\n"},{"title":"经过强制类型转换以后，变量a, b的值分别为（  ）short a = 128; byte b = (byte) a;","choices":["\n128  127\n","\n128  -128\n","\n128  128\n","\n编译错误\n"],"correct_choice":"\n128  -128\n"},{"title":"以下对继承的描述错误的是（）","choices":["\nJava中的继承允许一个子类继承多个父类\n","\n父类更具有通用性，子类更具体\n","\nJava中的继承存在着传递性\n","\n当实例化子类时会递归调用父类中的构造方法\n"],"correct_choice":"\nJava中的继承允许一个子类继承多个父类\n"},{"title":"\n  覆盖与重载的关系是（ \n   ）\n\n\n  \n","choices":["\n覆盖只有发生在父类与子类之间，而重载可以发生在同一个类中\n","\n覆盖方法和重载方法都可以不同名，也可以同名\n","\nfinal修饰的方法可以被覆盖，但不能被重载\n","\n覆盖与重载是同一回事\n"],"correct_choice":"\n覆盖只有发生在父类与子类之间，而重载可以发生在同一个类中\n"},{"title":"  在Java中,下列说法错误的有（ ） ","choices":["\n数组是一种对象\n","\n数组属于一种原生类\n","\nint number = []{31,23,33,43,35,63};\n","\n数组的大小可以任意改变\n"],"correct_choice":"\n数组属于一种原生类\n\nint number = []{31,23,33,43,35,63};\n\n数组的大小可以任意改变\n"},{"title":"\n  如果一个接口Cow有个方法drink()，有个类Calf实现接口Cow，则在类Calf中正确的是？  ( \n   )\n\n\n  \n","choices":["\nvoid drink() { …}\n","\nprotected void drink() { …}\n","\npublic void drink() { …}\n","\n以上语句都可以用在类Calf中\n"],"correct_choice":"\npublic void drink() { …}\n"},{"title":"\n  类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  (    )\n\n\n  \n","choices":["\nclass\n","\nstatic\n","\npublic\n","\nfinal\n"],"correct_choice":"\nstatic\n"},{"title":"在基本\nJAVA\n类型中，如果不明确指定，整数型的默认是\n__\n类型，带小数的默认是\n__\n类型？\n(  )","choices":["\nint float\n","\nint double\n","\nlong float\n","\nlong double\n"],"correct_choice":"\nint double\n"},{"title":"\n  下列叙述中，错误的是（\n  ）\n","choices":["\nFile类能够存储文件属性\n","\nFile类能够读写文件\n","\nFile类能够建立文件\n","\nFile类能够获取文件目录信息\n"],"correct_choice":"\nFile类能够读写文件\n"},{"title":"在使用super 和this关键字时，以下描述正确的是","choices":["\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n","\nsuper（）和this（）不一定要放在构造方法内第一行\n","\nthis（）和super（）可以同时出现在一个构造函数中\n","\nthis（）和super（）可以在static环境中使用，包括static方法和static语句块\n"],"correct_choice":"\n在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过\n"},{"title":"  下面的代码运行的结果是： \nclass B extends Object\n{\n    static\n    {\n        System.out.println(\"Load B\");\n    }\n    public B()\n    {\n        System.out.println(\"Create B\");\n    }\n}\nclass A extends B\n{\n    static\n    {\n        System.out.println(\"Load A\");\n    }\n    public A()\n    {\n        System.out.println(\"Create A\");\n    }\n}\n\npublic class Testclass\n{\n    public static void main(String[] args)\n    {\n        new A();\n    }\n}\n\n","choices":["\nLoad B ->Create B->Load A -> Create A\n","\nLoad B -> Load A  ->Create B  ->Create A\n","\nLoad B -> Create B-> Create A -> Load A\n","\nCreate B ->Create A ->Load B ->Load A\n"],"correct_choice":"\nLoad B -> Load A  ->Create B  ->Create A\n"},{"title":"java接口的方法修饰符可以为？(忽略内部接口)","choices":["\nprivate\n","\nprotected\n","\nfinal\n","\nabstract\n"],"correct_choice":"\nabstract\n"},{"title":"在如下所示的类Test中，共有（）个构造方法。\n\npublic class Test\n{\n    private int x;\n    public Test()\n    {\n        x = 35;\n    }\n\n    public void Test(double f)\n    {\n        this.x = (int)f;\n    }\n\n    public Test(double f)\n    {\n        this.x = (int)f;\n    }\n\n    public Test(String s) {}\n}\n\n\t\n\n\n","choices":["\n0\n","\n1\n","\n2\n","\n3\n"],"correct_choice":"\n3\n"},{"title":"\n  对于Java中异常的描述正确的是（ ）\n","choices":["\n用throws定义了方法可能抛出的异常，那么调用此方法时一定会抛出此异常。\n","\n如果try块中没有抛出异常，finally块中的语句将不会被执行。\n","\n抛出异常意味着程序发生运行时错误，需要调试修改\n","\nJava中所有的可不检测（unchecked）异常都来自RuntimeException类或其子类。\n"],"correct_choice":"\nJava中所有的可不检测（unchecked）异常都来自RuntimeException类或其子类。\n"},{"title":"  在Java线程状态转换时，下列转换不可能发生的有（）？     ","choices":["\n初始态->运行态\n","\n就绪态->运行态\n","\n阻塞态->运行态\n","\n运行态->就绪态\n"],"correct_choice":"\n初始态->运行态\n\n阻塞态->运行态\n"},{"title":"假定AB为一个类，则执行 “AB ab = new AB(a,5);”语句时将自动调用该类的(    )。","choices":["\n带参构造函数\n","\n无参构造函数\n","\n拷贝构造函数\n","\n重载赋值运算\n"],"correct_choice":"\n带参构造函数\n"},{"title":"\n  若\n  a\n  的值为\n  3\n  时，下列程序段被执行后，\n  c\n  的值是多少？（\n  ）\n\n\n  \n    \n      int c = 1;\n    \n  \n  \n    \n       if ( a>0 ) \n    \n  \n  \n    \n      if ( a>3 )\n    \n  \n  \n    \n      c = 2;\n    \n  \n  \n    \n      else\n    \n  \n  \n    \n      c = 3;\n    \n  \n  \n    \n      else\n    \n  \n  \n    \n      c = 4;\n    \n  \n","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"\n  \n  Java Application(Java\n  应用程序)源程序文件编译后的字节码文件的扩展名是(    )。\n","choices":["\njava\n","\nclass\n","\nexe\n","\njar\n"],"correct_choice":"\nclass\n"},{"title":"\n  下列关于\n  java\n  语言的特点，描述错误的是（）\n","choices":["\njava是跨平台的编程语言\n","\njava支持分布式计算\n","\njava是面向过程的编程语言\n","\njava支持多线程\n"],"correct_choice":"\njava是面向过程的编程语言\n"},{"title":"从运行层面上来看，从四个选项选出不同的一个。","choices":["\nJAVA\n","\nPython\n","\nobjectC\n","\nC#\n"],"correct_choice":"\nPython\n"},{"title":"\n  访问权限控制从最大权限到最小权限依次为：public、\n  包访问权限、protected和private\n  。（   ）\n\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  下面关于构造方法的说法不正确的是\n  ()\n","choices":["\n构造方法也属于类的方法，用于创建对象的时候给成员变量赋值\n","\n构造方法不可以重载\n","\n构造方法没有返回值\n","\n构造方法一定要和类名相同\n"],"correct_choice":"\n构造方法不可以重载\n"},{"title":"下列命令中，用来运行\nJava\n程序的是（）","choices":["\njava\n","\njavadoc\n","\njar\n","\njavac\n"],"correct_choice":"\njava\n"},{"title":"  Consider the following code: \nInteger s=new Integer(9);\nInteger t=new Integer(9);\nLong u=new Long(9);\n  Which test would return true? ","choices":["\n(s==u)\n","\n(s==t)\n","\n(s.equals(t))\n","\n(s.equals(9))\n","\n(s.equals(new Integer(9))\n"],"correct_choice":"\n(s.equals(t))\n\n(s.equals(9))\n\n(s.equals(new Integer(9))\n"},{"title":"JAVA属于（   ）。","choices":["\n操作系统\n","\n办公软件\n","\n数据库系统\n","\n计算机语言\n"],"correct_choice":"\n计算机语言\n"},{"title":"Java\n程序中使用赋值运算符进行对象赋值时，可以得到两个完全相同的对象。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"一般有两种用于创建线程对象的方法,一是(),二是()。","choices":["\n从Java.lang.Thread类派生一个新的线程类，重写它的runnable()方法\n","\n从Java.lang.Thread类派生一个新的线程类，重写它的run()方法\n","\n实现Thread接口，重写Thread接口中的run()方法\n","\n实现Runnable接口，重写Runnable接口中的run()方法\n"],"correct_choice":"\n从Java.lang.Thread类派生一个新的线程类，重写它的run()方法\n\n实现Runnable接口，重写Runnable接口中的run()方法\n"},{"title":"\n  以下哪个接口的定义是正确的？（\n  \n    \n      \n    \n  \n  ）\n","choices":["\ninterface  B\n{ public abstract void print()  {  } ;}\n","\ninterface  B\n{ static void print() ;}\n","\nabstract  interface  B  extends  A1, A2  //A1、A2为已定义的接口\n{private abstract  void  print();}\n","\ninterface  B\n      {  void  print();}\n"],"correct_choice":"\ninterface  B\n      {  void  print();}\n"},{"title":"  以下程序执行的结果是： \nclass X{\n\tY y=new Y();\n\tpublic X(){\n\t\tSystem.out.print(\"X\");\n\t}\n}\nclass Y{\n\tpublic Y(){\n\t\tSystem.out.print(\"Y\");\n\t}\n}\npublic class Z extends X{\n\tY y=new Y();\n\tpublic Z(){\n\t\tSystem.out.print(\"Z\");\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Z();\n\t}\n}","choices":["\nZYXX\n","\nZYXY\n","\nYXYZ\n","\nXYZX\n"],"correct_choice":"\nYXYZ\n"},{"title":"\n  A \n  是抽象父类或接口，\n  B \n  ，\n  C\n  派生自\n  A\n  ，或实现\n  A\n  ，现在\n  Java\n  源代码中有如下声明：\n\n\n  1.\n  A  a0=new  A();\n\n\n  2.\n  A  a1 =new  B();\n\n\n  3.\n  A  a2=new  C();\n\n\n  问以下哪个说法是正确的？（ ）\n","choices":["\n只有第1行不能通过编译\n","\n第1、2行能通过编译，但第3行编译出错\n","\n第1、2、3行能通过编译，但第2、3行运行时出错\n","\n第1行、第2行和第3行的声明都是正确的\n"],"correct_choice":"\n只有第1行不能通过编译\n"},{"title":"\n  为AB类的一个无形式参数无返回值的方法method书写方法头，可以用AB.method()方式调用，该方法头的形式为(    )。\n","choices":["\nstatic void method( )\n","\npublic void method( )\n","\nfinal void method( )\n","\nabstract void method( )\n"],"correct_choice":"\nstatic void method( )\n"}]