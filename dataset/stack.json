[{"title":"若已有一个栈，进栈顺序为ABCD，出栈顺序序列是BCDA，若用I表示进栈，O表示出栈，则进操作的顺序是（）","choices":["\nIOIOIIOO\n","\nIIOOIIOO\n","\nIIOIOIOO\n","\nIIOIOOIO\n"],"correct_choice":"\nIIOIOIOO\n"},{"title":"\n  在栈中存取数据的原则是______\n  。\n","choices":["\n先进先出\n","\n先进后出\n","\n后进后出\n","\n随意进出\n"],"correct_choice":"\n先进后出\n"},{"title":"栈和队列都是线性表，只是在插入和删除时受到了一些限制。","choices":["\nT\n","\nF\n"],"correct_choice":"\nT\n"},{"title":"\n  一个栈的入栈序列是A,B,C,D,E,则栈的不可能输出序列是（）\n","choices":["\nEDCBA\n","\nDECBA\n","\nDCEAB\n","\nABCDE\n"],"correct_choice":"\nDCEAB\n"},{"title":"\n  栈是一种对所有插入、删除操作限于在表的一端进行的线性表，是一种后进先出型结构。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"栈和队列是一种非线性数据结构（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"下述有关栈和队列的区别，说法错误的是？","choices":["\n栈是限定只能在表的一端进行插入和删除操作。\n","\n队列是限定只能在表的一端进行插入和在另一端进行删除操作。\n","\n栈和队列都属于线性表\n","\n栈的插入操作时间复杂度都是o(1)，队列的插入操作时间复杂度是o(n)\n"],"correct_choice":"\n栈的插入操作时间复杂度都是o(1)，队列的插入操作时间复杂度是o(n)\n"},{"title":"下列关于栈的叙述正确的是（  ）。","choices":["\n栈按“先进先出”组织数据\n","\n栈按“先进后出”组织数据\n","\n只能在栈底插入数据\n","\n不能删除数据\n"],"correct_choice":"\n栈按“先进后出”组织数据\n"},{"title":"和顺序栈相比，链栈有一个比较明显的优势是         。","choices":["\n通常不会出现栈满的情况\n","\n通常不会出现栈空的情况\n","\n插入操作更容易实现\n","\n删除操作更容易实现\n"],"correct_choice":"\n通常不会出现栈满的情况\n"},{"title":"  设用链表作为栈的存储结构则退栈操作（  ）。 ","choices":["\n必须判别栈是否为满\n","\n必须判别栈是否为空\n","\n判别栈元素的类型\n","\n对栈不作任何判别\n"],"correct_choice":"\n必须判别栈是否为空\n"},{"title":"  一个栈的入栈序列是a,b,c,d,e，则栈的不可能的输出序列是（ ）\n","choices":["\ne d c b a\n","\nd e c b a\n","\nd c e a b\n","\na b c d e\n"],"correct_choice":"\nd c e a b\n"},{"title":"设将整数1,2,3,4,5依次进栈，最后都出栈，出栈可以在任何时刻（只要栈不空）进行，则出栈序列不可能是　___________。 ","choices":["\n23415\n","\n54132\n","\n23145\n","\n15432\n"],"correct_choice":"\n54132\n"},{"title":"  设将整数 1,2,3,4,5 依次进栈，最后都出栈，出栈可以在任何时刻（只要栈不空）进行，则出栈序列不可能是（ ）  ","choices":["\n23415\n","\n54132\n","\n23145\n","\n15432\n"],"correct_choice":"\n54132\n"},{"title":"队列和栈有什么区别？","choices":["\n队列先进先出，栈后进先出\n","\n队列和栈都是先进先出\n","\n队列和栈都是后进先出\n","\n栈先进先出，队列后进先出\n"],"correct_choice":"\n队列先进先出，栈后进先出\n"},{"title":"若让元素A、B、C依次进栈，则出栈次序不可能出现（）种情况","choices":["\nC，A，B\n","\nB，A，C\n","\nC、B、A\n","\nA，C，B\n"],"correct_choice":"\nC，A，B\n"},{"title":"一个栈的入栈序列是a,b,c,d,e,f,则不可能的出栈序列是（）","choices":["\nfedcba\n","\ndefbca\n","\ndefcba\n","\nabcdef\n"],"correct_choice":"\ndefbca\n"},{"title":"某堆栈的输入序列为a,b,c,d,下面的四个序列中,不可能是它的输出序列的是()","choices":["\na,c,b,d\n","\nb,c,d,a\n","\nc,d,b,a\n","\nd,c,a,b\n"],"correct_choice":"\nd,c,a,b\n"},{"title":"下列哪些不是线性表？","choices":["\n队列\n","\n栈\n","\n关联数组\n","\n链表\n"],"correct_choice":"\n关联数组\n"},{"title":"下列叙述中正确的是（\n）。","choices":["\n在栈中，栈中元素随栈底指针与栈顶指针的变化而动态变化\n","\n在栈中，栈顶指针不变，栈中元素随栈底指针的变化而动态变化\n","\n在栈中，栈底指针不变，栈中元素随栈顶指针的变化而动态变化\n","\n以上说法均不正确\n"],"correct_choice":"\n在栈中，栈底指针不变，栈中元素随栈顶指针的变化而动态变化\n"},{"title":"栈通常采用的两种存储结构是什么？","choices":["\n顺序存储结构和链表存储结构\n","\n散列方式和索引方式\n","\n链表存储结构和数组\n","\n线性存储结构和非线性存储结构\n"],"correct_choice":"\n顺序存储结构和链表存储结构\n"},{"title":"通常使用队列来处理函数或过程的调用()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"  下列叙述中正确的是？ ","choices":["\n线性表是线性结构；\n","\n栈与队列是非线性结构；\n","\n线性链表是非线性结构；\n","\n二叉树是线性结构\n"],"correct_choice":"\n线性表是线性结构；\n"},{"title":"栈是先进后出的数据结构。给定一个大小为3的初始状态为空的栈，已知一组数据经过这个栈后，最终的数据顺序依次为：1 3 2 4 ，问原始的进栈数据不可能是以下的那组?","choices":["\n2 3 1 4\n","\n1 4 2 3\n","\n4 2 3 1\n","\n3 1 2 4\n"],"correct_choice":"\n4 2 3 1\n"},{"title":"数据流图中带有箭头的线段表示的是（  ）。","choices":["\n控制流\n","\n事件驱动\n","\n模块调用\n","\n数据流\n"],"correct_choice":"\n数据流\n"},{"title":"若一个栈以向量V[1…n]存储,初始栈顶指针top为n+1,则下面x入栈的正确操作是()","choices":["\ntop:=top+1;V[top]:=x\n","\nV[top]:=x;top:=top+1\n","\ntop:=top-1;V[top]:=x\n","\nV[top]:=x;top:=top-1\n"],"correct_choice":"\ntop:=top-1;V[top]:=x\n"},{"title":"下列叙述中错误的是（\n）","choices":["\n二叉链表是二叉树的存储结构\n","\n循环链表是循环队列的存储结构\n","\n栈是线性结构\n","\n循环队列是队列的存储结构\n"],"correct_choice":"\n循环链表是循环队列的存储结构\n"},{"title":"表达式3*2^(4+2*2-6*3)-5求值过程中当扫描到6时,对象栈和运算符栈为(),其中^为乘幂","choices":["\n3,2,4,1,1;(*^(+*-\n","\n3,2,8;(*^-\n","\n3,2,4,2,2;(*^(-\n","\n3,2,8;(*^(-\n"],"correct_choice":"\n3,2,8;(*^(-\n"},{"title":"下列说法错误的是 ()","choices":["\n利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素,这种形式的栈也称为顺序栈\n","\ntop=0 时为空栈,元素进栈时指针 top 不断地减 1\n","\n当top等于数组的最大下标值时则栈满\n","\n栈不能对输入序列部分或全局起求逆作用\n"],"correct_choice":"\ntop=0 时为空栈,元素进栈时指针 top 不断地减 1\n\n栈不能对输入序列部分或全局起求逆作用\n"},{"title":"  以下哪些对象是分配在栈上的 ","choices":["\n函数内局部变量\n","\n函数内局部指针变量\n","\n函数内动态申请的对象\n","\n函数内指向动态申请的对象的局部指针变量\n"],"correct_choice":"\n函数内局部变量\n\n函数内局部指针变量\n\n函数内指向动态申请的对象的局部指针变量\n"},{"title":"便于插入和删除的容器是（）","choices":["\nlist\n","\nvector\n","\nmap\n","\nset\n"],"correct_choice":"\nlist\n\nmap\n\nset\n"},{"title":"设有一个栈，元素依次进栈的顺序为 A 、 B 、 C 、 D 、 E 。下列         是不可能的出栈序列。","choices":["\nA,B,C,D,E\n","\nB,C,D,E,A\n","\nE,A,B,C,D\n","\nE,D,C,B,A\n"],"correct_choice":"\nE,A,B,C,D\n"},{"title":"\n  若让元素\n  1,\n  2,\n  3\n  依次进栈，则出栈次序不可能出现\n  ___\n  种情况。\n","choices":["\n3,2,1\n","\n2,1,3\n","\n3,1,2\n","\n1,3,2\n"],"correct_choice":"\n3,1,2\n"},{"title":"\n  一个栈的初始状态为空。现将元素\n  1,2,3,A,B,C\n  依次入栈，然后再依次出栈，则元素出栈的顺序是（）\n","choices":["\n1,2,3,A,B,C\n","\nC,B,A,1,2,3\n","\nC,B,A,3,2,1\n","\n1,2,3,C,B,A\n"],"correct_choice":"\nC,B,A,3,2,1\n"},{"title":"\n  判定一个栈ST（最多元素为m0）为空的条件是（）。\n\n","choices":["\nST->top<>0\n","\nST->top=0\n","\nST->top<>m0\n","\nST->top=m0\n"],"correct_choice":"\nST->top=0\n"},{"title":"  一个栈的入栈序列为ABCDE，则栈的不可能的输出序列为（）     ","choices":["\nDCEAB\n","\nEDCBA\n","\nDECBA\n","\nABCDE\n"],"correct_choice":"\nDCEAB\n"},{"title":"已知一个栈的入栈序列是m、n、x、y、z，则不可能出现的出栈顺序是？","choices":["\nmnxyz\n","\nxnyzm\n","\nnymxz\n","\nnmyzx\n"],"correct_choice":"\nnymxz\n"},{"title":"以下哪一个数据结构是非线性的（）","choices":["\n二叉树\n","\n链表\n","\n线性表\n","\n栈\n"],"correct_choice":"\n二叉树\n"},{"title":"在一个具有n个单元的顺序栈中，假定以地址低端（即0单元）作为栈底，以top作为栈顶指针，当做出栈处理时，top变化为______。    ","choices":["\ntop不变\n","\ntop=0\n","\ntop--\n","\ntop++\n"],"correct_choice":"\ntop--\n"},{"title":"\n  元素\n  3,1,2\n  依次放入一个栈后，顺序取出的结果是（）\n","choices":["\n3,2,1\n","\n3,1,2\n","\n1,2,3\n","\n2,1,3\n"],"correct_choice":"\n2,1,3\n"},{"title":"若进栈序列为 a,b,c,d，进栈过程中可以出栈，那么()是不可能的出栈序列","choices":["\ncbad\n","\nbdca\n","\nadbc\n","\ncdba\n"],"correct_choice":"\nadbc\n"},{"title":"判定一个顺序栈 st （最多元素为 MaxSize ）为空的条件是         。","choices":["\nst->top != -1\n","\nst->top == -1\n","\nst->top != MaxSize\n","\nst->top ==  MaxSize\n"],"correct_choice":"\nst->top == -1\n"},{"title":"\n  栈和队列是一种非线性数据结构。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  向一个栈顶指针为top的带头结点的非空的链栈中删除结点，则其操作步骤是（ 　　） \n","choices":["\ntop->next=s;\n","\ns->next=top->next;top->next=s; free(s)\n","\ns = top;top= top->next;free(s)\n","\ns = top->next;top= top->next;free(s)\n"],"correct_choice":"\ns = top;top= top->next;free(s)\n"},{"title":"  栈和队列的共同点是（）。 ","choices":["\n都是先进先出\n","\n都是先进后出\n","\n只允许在端点处插入和删除元素\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"\n\n  有六个元素6，5，4，3，2，1 的顺序进栈，问下列哪一个不是合法的出栈序列？（）\n","choices":["\n5 4 3 6 1 2\n","\n4 5 3 1 2 6\n","\n3 4 6 5 2 1\n","\n2 3 4 1 5 6\n"],"correct_choice":"\n3 4 6 5 2 1\n"},{"title":"支持子程序调用的数据结构是（  ）。","choices":["\n栈\n","\n树\n","\n队列\n","\n二叉树\n"],"correct_choice":"\n栈\n"},{"title":"在栈中，（）保持不变。","choices":["\n栈的顶\n","\n栈的底\n","\n栈指针\n","\n栈中的数据\n"],"correct_choice":"\n栈的底\n"},{"title":"一个栈的初始状态为空。首先将元素5，4，3，2，1 依次入栈，然后退栈一次，再将元素A,B,C,D依次入栈，之后将所有元素全部退栈，则所有元素退栈（包括中间退栈的元素）的顺序为？","choices":["\n1DCAB2345\n","\n1DCBA2345\n","\n54321ABCD\n","\nDCBA12345\n"],"correct_choice":"\n1DCBA2345\n"},{"title":"只有那种使用了局部变量的递归过程在转换成非递归过程时才必须使用栈()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"有n个数顺序(依次)入栈,出栈序列有Cn种,Cn=[1/(n+1)]*(2n)!/[(n!)*(n!)]()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"若用数组S[0. .n-1]做为两个栈S1和S2的共同存储结构，对任何一个栈，只有当S全满时才不能作入栈操作。为这两个栈分配空间的最佳方案是（ ）。","choices":["\nS1的栈底位置为0，S2的栈底位置为n-1\n","\nS1的栈底位置为0，S2的栈底位置为n/2\n","\nS1的栈底位置为1，S2的栈底位置为n/2\n"],"correct_choice":"\nS1的栈底位置为0，S2的栈底位置为n-1\n"},{"title":"\n  下面（）数据结构常用于函数调用。\n","choices":["\n队列\n","\n栈\n","\n链表\n","\n数组\n"],"correct_choice":"\n栈\n"},{"title":"设输入序列是1,3,5....m,经过栈的作用后输出序列的第一个元素是m,则输出序列中第i个输出元素是()","choices":["\nm-2(i-1)\n","\nm-i\n","\nm-1-i\n","\nm+1-i\n"],"correct_choice":"\nm-2(i-1)\n"},{"title":"某表达式的前缀形式为\"+-*^ABCD/E/F+GH\",它的中缀形式为()","choices":["\nA^B*C-D+E/F/G+H\n","\nA^B*(C-D)+(E/F)/G+H\n","\nA^B*C-D+E/(F/(G+H))\n","\nA^B*(C-D)+E/(F/(G+H))\n"],"correct_choice":"\nA^B*C-D+E/(F/(G+H))\n"},{"title":"  下列关于堆和栈的区别描述错误的有？ ","choices":["\n申请方式的不同，堆是系统自动分配，栈是自己申请\n","\n栈的大小是固定的，堆的大小受限于系统中有效的虚拟内存\n","\n栈的空间由系统决定何时释放，堆需要自己决定何时去释放\n","\n堆的使用容易产生碎片，但是用起来最方便\n"],"correct_choice":"\n申请方式的不同，堆是系统自动分配，栈是自己申请\n"},{"title":"若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（）","choices":["\n41\n","\n42\n","\n43\n","\n44\n"],"correct_choice":"\n42\n"},{"title":"全局变量和局部变量在内存中的区别是什么？","choices":["\n二者没有区别\n","\n生存周期不同\n","\n作用范围不同\n","\n占用的内存大小一样\n"],"correct_choice":"\n生存周期不同\n\n作用范围不同\n"},{"title":"\n  若要删除\n  book\n  表中的所有数据，如下哪些语法是错误的？\n","choices":["\ndrop table book;\n","\ntruncate table book;\n","\ndelete from book;\n","\ndelelet *from book;\n"],"correct_choice":"\ndrop table book;\n\ndelelet *from book;\n"},{"title":"\n  一个栈的输入序列为12345，则下列序列中是栈的输出序列的是（    ）。\n","choices":["\n23415\n","\n54132\n","\n31245\n","\n14253\n"],"correct_choice":"\n23415\n"},{"title":"  若已知一个栈的进栈序列是 1 ， 2 ， 3 ，， n ，其输出序列为 p1 ， p2 ， p3 ，…， pn ，若 p1 ＝ n ，则 pi 为         。  ","choices":["\ni\n","\nn－i\n","\nn－i＋1\n","\n不确定\n"],"correct_choice":"\nn－i＋1\n"},{"title":"\n  栈和队列的存储方式既可是顺序方式，也可是链接方式。 \n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"  若进栈系列为：a，b，c，d，则下列哪一个不可能是出栈系列（ ）。  ","choices":["\na，b，c，d\n","\nc，d，b，a\n","\na，c，d，b\n","\nc，a，b，d\n"],"correct_choice":"\nc，a，b，d\n"},{"title":"\n  设依次进入一个栈的元素序列为\n  d, a, c, b,\n  得不到出栈的元素序列为（    ）\n  \n","choices":["\ndcba\n","\nacdb\n","\nabcd\n","\ncbda\n"],"correct_choice":"\ncbda\n"},{"title":"  设有输入序列a，b，c，经过入栈、出栈、入栈、入栈、出栈操作后，从堆栈中弹出的元素的序列是（） ","choices":["\na，c\n","\nb，c\n","\na，b\n","\nb，a\n"],"correct_choice":"\na，c\n"},{"title":"以下数据结构中,()是非线性数据结构","choices":["\n树\n","\n字符串\n","\n队\n","\n栈\n"],"correct_choice":"\n树\n"},{"title":"\n  栈和队列都是线性表，只是在插入和删除时受到了一些限制。\n\n\n  \n\n\n  \n    \n  \n","choices":["\n是\n","\n否\n"],"correct_choice":"\n是\n"},{"title":"设有一个栈，元素依次进栈的顺序是A,B,C,D,E。下列不可能的出栈顺序有?","choices":["\nABCDE\n","\nBCDEA\n","\nEABCD\n","\nEDCBA\n"],"correct_choice":"\nEABCD\n"},{"title":"  假设栈的输入序列是7,6,2,1,4，则以下不可能是其出栈序列（ ）？  ","choices":["\n6,7,4,1,2\n","\n其它都不是\n","\n7,6,2,1,4\n","\n6,7,4,2,1\n"],"correct_choice":"\n6,7,4,2,1\n"},{"title":"设a，b，c三个元素的进栈次序是a，b，c，请指出不可能出现的出栈序列 。","choices":["\nacb\n","\nbac\n","\nbca\n","\ncab\n"],"correct_choice":"\ncab\n"},{"title":"\n  在递归算法执行过程中，计算机系统必定会用到的数据结构是（\n  ） \n","choices":["\n队列\n","\n链表\n","\n栈\n","\n二叉树\n"],"correct_choice":"\n栈\n"},{"title":"设入栈顺序为A,B,C,D,E.则出栈序列不可能为（）","choices":["\nEDCBA\n","\nADEBC\n","\nABCDE\n","\nABDCE\n"],"correct_choice":"\nADEBC\n"},{"title":"以下那种结构，平均来讲获取任意一个指定值最快？()","choices":["\n二叉排序树\n","\n队列\n","\n栈\n","\n哈希表\n"],"correct_choice":"\n哈希表\n"},{"title":"\n  已知程序如下：\n\nint S(int n)\n{  \n    return (n<=0)?0: S (n-1)+n;\n}\nvoid main(\n{  \n    cout<< S(1);\n}\n\n  程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是\n  （）\n  。\n","choices":["\nmain()→S(1)→S(0)\n","\nS(0)→S(1)→main()\n","\nmain()→S(0)→S(1)\n","\nS(1)→S(0)→main()\n"],"correct_choice":"\nmain()→S(1)→S(0)\n"},{"title":"栈是实现过程和函数等子程序所必需的结构()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"设栈采用顺序存储结构,若已有i-1个元素入栈,则将第i个元素入栈时,入栈算法的时间复杂性为O(i)()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"栈在()中应用","choices":["\n递归调用\n","\n子程序调用\n","\n表达式求值\n","\n以上答案均正确\n"],"correct_choice":"\n以上答案均正确\n"},{"title":"下面有关c++静态数据成员，说法正确的是？","choices":["\n不能在类内初始化\n","\n不能被类的对象调用\n","\n不能受private修饰符的作用\n","\n可以直接用类名调用\n"],"correct_choice":"\n可以直接用类名调用\n"},{"title":"\n  设栈的存储空间为\n   S(1:50)\n  ，初始状态为\n   top=51\n  。现经过一系列正常的入栈与退栈操作后，\n  top=50\n  ，则栈中的元素个数为（\n  ）\n","choices":["\n1\n","\n0\n","\n50\n","\n49\n"],"correct_choice":"\n1\n"},{"title":"以下与数据的存储结构无关的术语是()","choices":["\n循环队列\n","\n链表\n","\n哈希表\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"  表达式3*2^(4+2*2-6*3)-5，求值过程中当扫描到6时，对象栈和算符栈为（），其中^为乘幂。  ","choices":["\n3，2，8;*^-\n","\n3，2，4，2，2;*^+*-\n","\n3，2，4，2，2,;*^(+*-\n","\n3，2，8;*^(-\n"],"correct_choice":"\n3，2，8;*^(-\n"},{"title":"一个栈的输入序列为1 2 3 4 5，则下列序列中不可能是栈的输出序列的是","choices":["\n1 5 4 3 2\n","\n2 3 1 4 5\n","\n2 3 4 1 5\n","\n5 4 1 3 2\n"],"correct_choice":"\n5 4 1 3 2\n"},{"title":"\n  若已知一个栈的入栈序列是1，2，3，…，n，其输出序列为\n  p1\n  ，\n  p2\n  ，\n  p3\n  ，…，\n  pn\n  ，若p1=n，则pi为（）\n","choices":["\ni\n","\nn=i\n","\nn-i+1\n","\n不确定\n"],"correct_choice":"\nn-i+1\n"},{"title":"设栈S和队列Q的初始状态为空，元素e1，e2，e3，e4，e5，e6依次压入栈S,一个元素出栈后即进入队列Q，若出队列的顺序为e2,e4,e3,e6,e5,e1则栈S的容量要求最小值为","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"入栈操作和入队列操作在链式存储结构上实现时不需要考虑栈溢出的情况。(  )","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"栈和队列的存储方式既可是顺序方式,也可是链接方式（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"堆栈和队列的共同点是（        ）","choices":["\n都是先进后出\n","\n都是先进先出\n","\n只允许在端点处插入和删除元素\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"若栈采用顺序存储方式存储，现两栈共享空间 V[1 m] ， top[1] 、 top[2] 分别代表第 1 和第 2 个栈的栈顶，栈 1 的底在 V[1] ，栈 2 的底在 V[m] ，则栈满的条件是         。","choices":["\n|top[2]-top[1]|=0\n","\ntop[1]+1=top[2]\n","\ntop[1]+top[2]=m\n","\ntop[1]=top[2]\n"],"correct_choice":"\ntop[1]+1=top[2]\n"},{"title":"栈和队列都是线性表,只是在插入和删除时受到了一些限制()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"下面哪一种操作不是stack的基本操作？","choices":["\n入栈\n","\n出栈\n","\n检查是否为空\n","\n排序栈中元素\n"],"correct_choice":"\n排序栈中元素\n"},{"title":"有六个元素6，5，4，3，2，1的顺序进栈，请问下列哪一个不是合法的出栈顺序？（）","choices":["\n543612\n","\n453126\n","\n346521\n","\n234156\n"],"correct_choice":"\n346521\n"},{"title":"已知-算术表达式的中缀表达式为a-(b+c/d)*e,其后缀形式为()","choices":["\n-a+b*c/d\n","\n-a+b*cd/e\n","\n-+*abc/de\n","\nabcd/+e*-\n"],"correct_choice":"\nabcd/+e*-\n"},{"title":"如果一个堆栈的入栈序列是A,B,C,D,E,则堆栈的不可能输出顺序是（）。","choices":["\nEDCBA\n","\nDECBA\n","\nDCEAB\n","\nABCDE\n"],"correct_choice":"\nDCEAB\n"},{"title":"输入序列是ABC,输出序列变为BCA时，经过的栈操作为()","choices":["\npush,push,push,pop,pop,pop\n","\npush,push,pop,push,pop,pop\n","\npush,pop,push,push,pop,pop\n","\npush,push,pop,pop,push,pop\n"],"correct_choice":"\npush,push,pop,push,pop,pop\n"},{"title":"下列数据结构不是多型数据类型的是（）","choices":["\n堆\n","\n栈\n","\n字符串\n","\n有向图\n"],"correct_choice":"\n字符串\n"},{"title":"设栈S和队列Q的初始状态均为空，元素a,b,c,d,e,f,g依次进入栈S。若每个元素出栈后立即进入推列Q，且7个元素出队的顺序是b,d,,c,f,e,a,g，则栈S的容量至少是？","choices":["\n1\n","\n2\n","\n3\n","\n4\n"],"correct_choice":"\n3\n"},{"title":"将一个递归算法改为对应的非递归算法时，通常需要使用（  ）。","choices":["\n优先队列\n","\n队列\n","\n循环队列\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"和顺序栈相比,链栈有一个比较明显的优势是()","choices":["\n通常不会出现栈满的情况\n","\n通常不会出现栈空的情况\n","\n插入操作更容易实现\n","\n删除操作更容易实现\n"],"correct_choice":"\n通常不会出现栈满的情况\n"},{"title":"消除递归不一定需要使用栈,此说法()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"\n  已知操作符包括‘ +’、‘ -’、‘ *’、‘ /’、‘ (’和‘ )’。将中缀表达式 a+b-a*((c+d)/e-f)+g\n    转换为后缀表达式\n    ab+acd+e/f-*-g+时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空，则转换过程中同时保存在栈中的操作符的最大个数是（ ）。\n  \n    \n  \n","choices":["\n5\n","\n7\n","\n8\n","\n11\n"],"correct_choice":"\n5\n"},{"title":"\n  一个栈的入栈序列为1,2,3,...,n ，其出栈序列是 p\n  \n    1\n  \n  ,p\n  \n    2\n  \n  ,p\n  \n    3\n  \n  ,...p\n  \n    n\n  \n  。若p\n  \n    2\n  \n   = 3，则 p\n  \n    3\n  \n  可能取值的个数是（）\n","choices":["\nn-3\n","\nn-2\n","\nn-1\n","\n无法确定\n"],"correct_choice":"\nn-1\n"},{"title":"递归式的先序遍历一个n节点，深度为d的二叉树，需要栈空间的大小为______。","choices":["\nO（n）\n","\nO（d）\n","\nO（logn）\n","\nO（nlogn）\n"],"correct_choice":"\nO（d）\n"},{"title":"\n  一个栈的输入序列是12345，则栈的输出序列不可能是12345。\n\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"设将整数1,2,3,4,5依次进栈，最后都出栈，出栈可以在任何时刻（只要栈不空）进行，则出栈序列不可能是（）","choices":["\n23415\n","\n54132\n","\n23145\n","\n15432\n"],"correct_choice":"\n54132\n"},{"title":"\n  栈中元素的进出原则是 \n\n","choices":["\n先进先出\n","\n后进先出\n","\n栈空则进\n","\n栈满则出\n"],"correct_choice":"\n后进先出\n"},{"title":"\n  设栈最大长度为 3 ，入栈序列为 1 ， 2\n      ， 3 ， 4 ， 5 ，\n      6 ，则不可能得出栈序列是（）\n","choices":["\n1 ， 2 ， 3 ， 4 ， 5 ， 6\n","\n2 ， 1 ， 3 ， 4 ， 5 ， 6\n","\n3 ， 4 ， 2 ， 1 ， 5 ， 6\n","\n4 ， 3 ， 2 ， 1 ， 5 ， 6\n"],"correct_choice":"\n4 ， 3 ， 2 ， 1 ， 5 ， 6\n"},{"title":"下面的描述错误的是","choices":["\n栈只能在一端进行入栈和出栈操作\n","\n队列在一端进行入队操作，另一端进行出队操作\n","\n栈和队列都是“先进后出”\n","\n链表的各个元素在内存中的保持位置可以是不连续的\n"],"correct_choice":"\n栈和队列都是“先进后出”\n"},{"title":"\n  \n  设栈的输入序列为\n  123…..n\n  ，输出序列为\n  a1,a2,a3,……,an\n  \n  ，若存在\n  1<=k<=n\n  ，使得\n  ak=n\n  ，则当\n  k<=i<=n\n  时，\n  ai\n  \n  为\n  \n  。\n","choices":["\nn-i+1\n","\nn-(i-k)\n","\ni\n","\n不确定\n"],"correct_choice":"\n不确定\n"},{"title":"向一个栈顶指针为 h 的带头结点的链栈中插入指针 s 所指的结点时，应执行         操作。","choices":["\nh->next=s ;\n","\ns->next=h ;\n","\ns->next=h ;h =s ;\n","\ns->next=h->next ;h->next=s ;\n"],"correct_choice":"\ns->next=h->next ;h->next=s ;\n"},{"title":"设有一个顺序表S，元素s1,s2,s3,s4,s5,s6依次进栈，如果六个元素的出栈顺序为s2,s3,s4,s6,s5,s1,则顺序栈的容量至少应为（）","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"栈是一种对所有插入、删除操作限于在表的一端进行的线性表,是一种后进先出型结构（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"一个栈的入栈序列是A、B、C、D、E，则栈的不可能输出序列是：（）","choices":["\nDCEAB\n","\nABCDE\n","\nEDCBA\n","\nDECBA\n"],"correct_choice":"\nDCEAB\n"},{"title":"若栈采用顺序存储方式存储,现两栈共享空间v[1…m],top[i]代表第i个栈(i=1,2)栈顶,栈1的底在v[1],栈2的底在V[m],则栈满的条件是()","choices":["\n|top[2]-top[1]|=0\n","\ntop[1]+1=top[2]\n","\ntop[1]+top[2]=m\n","\ntop[1]=top[2]\n"],"correct_choice":"\ntop[1]+1=top[2]\n"},{"title":"当很频繁地对序列中部进行插入和删除操作时，应该选择使用的容器是（）","choices":["\nvector\n","\nlist\n","\ndeque\n","\nstack\n"],"correct_choice":"\nlist\n"},{"title":"若栈采用顺序存储方式存储，现两栈共享空间V[1..m]，top[i]代表第i个栈( i\n=1,2)栈顶，栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是（   ）。","choices":["\ntop[1]+top[2]=m\n","\ntop[1]+1=top[2]\n","\ntop[2]-top[1]|=0\n","\ntop[1]=top[2]\n"],"correct_choice":"\ntop[1]+1=top[2]\n"},{"title":"下列数据结构具有记忆功能的是？","choices":["\n队列\n","\n循环队列\n","\n栈\n","\n顺序表\n"],"correct_choice":"\n栈\n"},{"title":"下列叙述中正确的是（\n）","choices":["\n在循环队列中，队头指针和队尾指针的动态变化决定队列的长度\n","\n在循环队列中，队尾指针的动态变化决定队列的长度\n","\n在带链的队列中，队头指针与队尾指针的动态变化决定队列的长度\n","\n在带链的栈中，栈顶指针的动态变化决定栈中元素的个数\n"],"correct_choice":"\n在循环队列中，队头指针和队尾指针的动态变化决定队列的长度\n\n在带链的栈中，栈顶指针的动态变化决定栈中元素的个数\n"},{"title":"  如果进栈的顺序为X、Y、Z则下列哪个出栈顺序是不可能的？（）  ","choices":["\nXYZ\n","\nXZY\n","\nZXY\n","\nZYX\n"],"correct_choice":"\nZXY\n"},{"title":"递归过程或函数调用时,处理参数及返回地址,要用一种称为()的数据结构","choices":["\n队列\n","\n多维数组\n","\n栈\n","\n线性表\n"],"correct_choice":"\n栈\n"},{"title":"设栈S和队列Q的初始状态为空,元素e1, e2,e3,e4, e5和e6依次通过栈S,一个元素出栈后即进队列Q,若6个元素出队的序列是e2,\ne4, e3, e6, e5, e1,则栈S的容量至少应该是()","choices":["\n6\n","\n4\n","\n3\n","\n2\n"],"correct_choice":"\n3\n"},{"title":"\n  若已知一个栈的入栈序列是1,2,3,…,n，其输出序列为p\n  \n    1\n  \n  ,p\n  \n    2\n  \n  , p\n  \n    3\n  \n  ,…,p\n  \n    \n      n\n    \n  \n  ，若p\n  \n    1\n  \n  =n，则p\n  \n    \n      i\n    \n  \n  为\n  。（注：\n  p1=n意味着进栈的中间过程中没有任何元素出栈\n  ）\n\n\n  \n","choices":["\ni\n","\nn=i\n","\nn-i+1\n","\n不确定\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n  一个栈的输入序列为1 2 3 4 5，则下列序列中不可能是栈的输出序列的是\n  (     )。\n\n\n  \n    \n  \n","choices":["\n2 3 4 1 5\n","\n5 4 1 3 2\n","\n2 3 1 4 5\n","\n1 5 4 3 2\n"],"correct_choice":"\n5 4 1 3 2\n"},{"title":"\n  下列叙述中正确的是（\n  ）。\n","choices":["\n在栈中，栈顶指针的动态变化决定栈中元素的个数\n","\n在循环队列中，队尾指针的动态变化决定队列的长度\n","\n在循环链表中，头指针和链尾指针的动态变化决定链表的长度\n","\n在线性链表中，头指针和链尾指针的动态变化决定链表的长度\n"],"correct_choice":"\n在栈中，栈顶指针的动态变化决定栈中元素的个数\n"},{"title":"下列关于栈叙述正确的是（  ）。","choices":["\n算法就是程序\n","\n设计算法时只需要考虑数据结构的设计\n","\n设计算法时只需要考虑结果的可靠性\n","\n以上三种说法都不对\n"],"correct_choice":"\n以上三种说法都不对\n"},{"title":"判定一个顺序栈 st （最多元素为 MaxSize ）为满的条件是        ","choices":["\nst->top != -1\n","\nst->top == -1\n","\nst->top != MaxSize\n","\nst->top ==  MaxSize\n"],"correct_choice":"\nst->top ==  MaxSize\n"},{"title":"下列数据结构中，按先进后出原则组织数据的是？","choices":["\n线性链表\n","\n栈\n","\n循环链表\n","\n顺序表\n"],"correct_choice":"\n栈\n"},{"title":"一个栈的入栈序列为A B C D E 则不可能的输出序列为?","choices":["\nDECBA\n","\nDCEBA\n","\nECDBA\n","\nABCDE\n"],"correct_choice":"\nECDBA\n"},{"title":"栈也是一种线性表，也同样有顺序存储结构和链式存储结构，这种说法（）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"设A、B、C三个字符按先后顺序依次进栈且出栈顺序随意；下面哪个序列为不可能的出栈序列（）。","choices":["\nABC\n","\nACB\n","\nBAC\n","\nBCA\n","\nCAB\n","\nCBA\n"],"correct_choice":"\nCAB\n"},{"title":"\n  设有一个顺序栈S，元素a b c d e\n      f依次进栈，如果6个元素出栈的顺序是b d c f e a，则栈的容量至少应该是（　　）\n","choices":["\n2\n","\n3\n","\n5\n","\n6\n"],"correct_choice":"\n3\n"},{"title":"栈是一种对所有插入、删除操作限于在表的一端进行的线性表，是一种后进先出型结构。 请问这句话的说法是正确的吗？","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  若进栈序列为\n  1,2,3,4\n  ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）\n","choices":["\n1,4,3,2\n","\n2,3,4,1\n","\n3,1,4,2\n","\n3,4,2,1\n"],"correct_choice":"\n3,1,4,2\n"},{"title":"4个圆盘的Hanoi塔,总的移动次数为()","choices":["\n7\n","\n8\n","\n15\n","\n16\n"],"correct_choice":"\n15\n"},{"title":"栈的输入序列是1,2,…,n,输出序列是a1\n  ,a2\n  ,…,an\n  ,若ai\n  =n(1<=i<=n),则有:ai\n  >ai+1\n  >…>an\n  ()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"输入序列ABCABC经过栈操作变成ABCCBA，下面哪些是可能的栈操作？","choices":["\npush pop push pop push pop push push push pop pop pop\n","\npush push push push push push pop pop pop pop pop pop\n","\npush push push pop pop pop pushpush pop pop push pop\n","\npush push push push pop pushpop push pop pop pop pop\n"],"correct_choice":"\npush pop push pop push pop push push push pop pop pop\n\npush push push push pop pushpop push pop pop pop pop\n"},{"title":"以下哪个选项中可能应用到栈。","choices":["\n递归\n","\n快速排序（非递归程序用栈实现）\n","\n表达式求值\n","\n树的遍历\n"],"correct_choice":"\n递归\n\n快速排序（非递归程序用栈实现）\n\n表达式求值\n\n树的遍历\n"},{"title":"栈和队列的共同点是","choices":["\n都是先进后出\n","\n都是先进先出\n","\n没有共同点\n","\n只允许在端点处插入和删除元素\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"\n  栈和链表一定是两种不同的数据结构。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"若进栈序列为1,2,3.4假定进栈和出栈可以穿插进行，则可能的出栈序列是()","choices":["\n2,4,1,3\n","\n3,1,4,2\n","\n3,4,1,2\n","\n1,2,3,4\n"],"correct_choice":"\n1,2,3,4\n"},{"title":"栈是一种后进先出的线性表，因此，元素的进栈序列和出栈序列不可能相同。（    ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"元素3，6，9按顺序依次进栈，则该栈的不可能输出序列是（   ）（进栈出栈可以交替进行）。","choices":["\n9，3，6\n","\n9，6，3\n","\n6，3，9\n","\n3，9，6\n"],"correct_choice":"\n9，3，6\n"},{"title":"往一个栈顺序push下列元素：ABCDE，其pop可能的顺序，下列不正确的是（）","choices":["\nBACDE\n","\nACDBE\n","\nAEBCD\n","\nAEDCB\n"],"correct_choice":"\nAEBCD\n"},{"title":"表达式“X=A+B*（C--D）/E”的后缀表示形式可以为","choices":["\nXAB+CDE/-*=\n","\nXA+BC-DE/*=\n","\nXABCD-*E/+=\n","\nXABCDE+*/=\n"],"correct_choice":"\nXABCD-*E/+=\n"},{"title":"设有四个元素A、B、C、D顺序进栈，在进栈过程中可以出栈，出栈次序错误的排列是","choices":["\nABCD\n","\nDCBA\n","\nACBD\n","\nBCDA\n","\nACDB\n","\nDCAB\n"],"correct_choice":"\nDCAB\n"},{"title":"\n  有一个正整数序列1,2,3，......，n和一个最多能容纳m个数字的栈，数字按序列顺序进栈，但出栈顺序是随机的；例如，n=2，m=3，则出栈顺序可能是1,2或者2,1；若n=7，m=5时，则出栈序列可能是下列的哪些选项（）\n","choices":["\n1，7，6，5，4，3，2\n","\n1，2，3，4，5，6，7\n","\n7，6，5，4，3，2，1\n","\n5，6，4，3，7，2，1\n"],"correct_choice":"\n1，2，3，4，5，6，7\n\n5，6，4，3，7，2，1\n"},{"title":"There is a sequence of n numbers 1, 2, 3,.., n and a stack which\n  can keep m numbers at most. Push the n numbers into the stack\n  following the sequence and pop out randomly.  Suppose n is 2 and m is\n  3, the output sequence may be 1, 2 or 2, 1, so we get 2 different\n  sequences. Suppose n is 7 and m is 5, please choose the output\n  sequences of the stack:","choices":["\n1, 2, 3, 4, 5, 6, 7\n","\n7, 6, 5, 4, 3, 2, 1\n","\n5, 6, 4, 3, 7, 2, 1\n","\n4, 5, 6, 3, 7, 2, 1\n","\n1, 7, 6, 5, 4, 3, 2\n","\n3, 2, 1, 7, 6,5, 4\n"],"correct_choice":"\n1, 2, 3, 4, 5, 6, 7\n\n5, 6, 4, 3, 7, 2, 1\n\n4, 5, 6, 3, 7, 2, 1\n\n3, 2, 1, 7, 6,5, 4\n"},{"title":"一个栈的入栈序列为ABCDE,则不可能的出栈序列为（）","choices":["\nECDBA\n","\nDCEAB\n","\nDECBA\n","\nABCDE\n"],"correct_choice":"\nECDBA\n\nDCEAB\n"},{"title":"需要频繁的插入删除操作使用什么结构比较合适?","choices":["\n数组\n","\n队列\n","\n链表\n","\n栈\n"],"correct_choice":"\n链表\n"},{"title":"若让元素 1, 2, 3 依次进栈，则出栈次序 1, 3, 2 是不可能出现的情况 。（    ）","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"","choices":["\nedcba\n","\ndecba\n","\ndceab\n","\nabcde\n"],"correct_choice":"\ndceab\n"},{"title":"\n  设输入序列1、2、3、…、n经过栈作用后，输出序列中的第一个元素是n，则输出序列中的第i个输出元素是（）。\n","choices":["\nn-i\n","\nn-1-i\n","\nn+l -i\n","\n不能确定\n"],"correct_choice":"\nn+l -i\n"},{"title":"两个栈共享一片连续内存空间时,为提高内存利用率,减少溢出机会,应把两个栈的栈底分别设在这片内存空间的两端（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"一个栈的输入序列为连续整数1，2，3...n，若输出序列的第一个元素是n，输出第  i（1<=i<=n）个元素是（  ）。","choices":["\n不确定\n","\nn-i+1\n","\nI\n","\nN-i\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n  栈是特殊的线性表，它\n  的插入和删除分别在线性表的两端进行\n  。\n  ( \n   )\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"一个栈的输入序列为123、、、、、n，若输出序列的第一个元素是n，输出第i（1<=i<=n）个元素是（）","choices":["\n不确定\n","\nn-i+1\n","\ni\n","\nn-i\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n  假设栈初始为空，将中缀表达式\n  \n  转换为等价后缀表达式的过程中，当扫描到f时，栈中的元素依次是\n  （）\n","choices":["\n+(*-\n","\n+(-*\n","\n/+(*-*\n","\n/+-*\n"],"correct_choice":"\n+(-*\n"},{"title":"图的广度优先搜索算法需使用的辅助数据结构为（）","choices":["\n三元组\n","\n队列\n","\n二叉树\n","\n栈\n"],"correct_choice":"\n队列\n"},{"title":"如果进栈序列为el,e2,e3,e4，则可能的出栈序列是 (    ) \n","choices":["\ne3，el，e4，e2\n","\ne2，e4，e3，el\n","\ne3，e4，e1，e2\n","\n任意顺序\n"],"correct_choice":"\ne2，e4，e3，el\n"},{"title":"一个栈的输入序列为1 2 3 4 5，则下列序列中不可能是栈的输出序列的是(     )。","choices":["\n2 3 4 1 5\n","\n5 4 1 3 2\n","\n2 3 1 4 5\n","\n1 5 4 3 2\n"],"correct_choice":"\n5 4 1 3 2\n"},{"title":"设栈S和队列Q的初始状态为空，元素ABCDEF依次进栈S，出栈后立即进入队列Q，若6个元素出列的顺序为CDBFEA,则栈S的容量至少为（）","choices":["\n3\n","\n4\n","\n6\n","\n2\n"],"correct_choice":"\n3\n"},{"title":"一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（  ）。","choices":["\n12345ABCDE\n","\nEDCBA54321\n","\nABCDE12345\n","\n54321EDCBA\n"],"correct_choice":"\nEDCBA54321\n"},{"title":"设计一个判别表达式中左、右括号是否配对出现的算法，采用             数据结构最佳。","choices":["\n线性表的顺序存储结构\n","\n队列\n","\n线性表的链式存储结构\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"一个栈的入栈序列是a,b,c,d,e,则栈的输出序列不可能是______。","choices":["\ndceab\n","\ndecba\n","\nedcba\n","\nabcde\n"],"correct_choice":"\ndceab\n"},{"title":"一个栈的入栈顺序是a b c d e,则不可能的出栈顺序是：","choices":["\ne d c b a\n","\nd e c b a\n","\nd c e a b\n","\na b c d e\n"],"correct_choice":"\nd c e a b\n"},{"title":"输入序列为 ABC ，可以变为 CBA 时，经过的栈操作为          。","choices":["\npush，pop，push，pop，push，pop\n","\npush，push，push，pop， pop， pop\n","\npush，push，pop， pop，push，pop\n","\npush，pop，push，push，pop， pop\n"],"correct_choice":"\npush，push，push，pop， pop， pop\n"},{"title":"在表结构中最常用的是线性表，栈和队列不太常用。请问这句话的说法是正确的吗？ ","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  以下数据结构中，（）是非线性数据结构\n","choices":["\n树\n","\n字符串\n","\n队\n","\n栈\n"],"correct_choice":"\n树\n"},{"title":"采用顺序存储的栈，执行入栈运算，栈顶指针的变化是（）","choices":["\ntop++\n","\ntop--\n","\n不变\n","\n(top++)++\n"],"correct_choice":"\ntop++\n"},{"title":"设abcdef以所给的次序进栈，若在进栈操作时，允许退栈操作，则下面得不到的序列为（）","choices":["\nfedcba\n","\nbcafed\n","\ndcefba\n","\ncabdef\n"],"correct_choice":"\ncabdef\n"},{"title":"设栈\nS\n和队列\nQ\n的初始状态为空，元素\ne1\n、\ne2\n、\ne3\n、\ne4\n、\ne5\n和\ne6\n依次通过栈\nS\n，一个元素出栈后即进入队列\nQ\n，若\n6\n个元素出队的顺序是\ne2\n、\ne4\n、\ne3\n、\ne6\n、\ne5\n、和\ne1\n，则栈\nS\n容量至少应该是\n","choices":["\n6\n","\n4\n","\n3\n","\n2\n"],"correct_choice":"\n3\n"},{"title":"若用数组S[0…n]作为两个栈S1和S2的存储结构，对任何一个栈只有当S全满时才不能做入栈操作。为这两个栈分配空间的最佳方案是","choices":["\nS1的栈底位置为0，S2的栈底位置为n\n","\nS1的栈底位置为0，S2的栈底位置为n/2\n","\nS1的栈底位置为1，S2的栈底位置为n/2\n"],"correct_choice":"\nS1的栈底位置为0，S2的栈底位置为n\n"},{"title":"如果进栈序列为e1,e2,e3,e4,e5,则可能的出栈序列是：","choices":["\ne3,e2,e5,e4,e1\n","\ne2,e3,e5,e4,e1\n","\ne3,e2,e4,e5,e1\n","\n以上都有可能\n"],"correct_choice":"\n以上都有可能\n"},{"title":"队列和栈都是运算受限的线性表,只允许在表的两端进行运算()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"\n  设栈的顺序存储空间为\n  S(0:49)\n  ，栈底指针\n  bottom=49\n  ，栈顶指针\n  top=30\n  （指向栈顶元素）。则栈中的元素个数为（ ）。\n","choices":["\n30\n","\n29\n","\n20\n","\n19\n"],"correct_choice":"\n20\n"},{"title":"栈和链表是两种不同的数据结构（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":" 栈中元素的进出原则是（）","choices":["\n后进先出\n","\n后进后出\n","\n栈空则进\n","\n栈满则出\n"],"correct_choice":"\n后进先出\n"},{"title":"判定一个栈 ST(最多元素为 m0)为空的条件是（）\n","choices":["\nST->top<>0\n","\nST->top=0\n","\nST->top<>m0\n","\nST->top=m0\n"],"correct_choice":"\nST->top=0\n"},{"title":"栈S最多能容纳4个元素。现在6个元素按A、B、C、D、E、F的顺序进栈，下列哪一个序列不是可能的出栈序列？","choices":["\nA、B、C、D、E、F\n","\nA、F、E、D、C、B\n","\nC、B、E、D、A、F\n","\nC、D、B、E、F、A\n"],"correct_choice":"\nA、F、E、D、C、B\n"},{"title":"以下哪个数据结构不是多型数据类型()","choices":["\n栈\n","\n广义表\n","\n有向图\n","\n字符串\n"],"correct_choice":"\n字符串\n"},{"title":"解析XML时，需要校验节点是否闭合，如必须有与之对应，用（）数据结构实现比较好","choices":["\n链表\n","\n树\n","\n队列\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"()的遍历仍需要栈的支持","choices":["\n前序线索树\n","\n中序线索树\n","\n后序线索树\n"],"correct_choice":"\n后序线索树\n"},{"title":"一个栈的入栈序列为A,B,C,D,E,则栈的不可能的出栈序列是()","choices":["\nABCDE\n","\nEDCBA\n","\nDECBA\n","\nDCEAB\n"],"correct_choice":"\nDCEAB\n"},{"title":"如果进栈序列为e1,e2,e3,e4，则不可能的出栈序列是( )","choices":["\ne2,e4,e3,e1\n","\ne4,e3,e2,e1\n","\ne1,e2,e3,e4\n","\ne3,e1,e4,e2\n"],"correct_choice":"\ne3,e1,e4,e2\n"},{"title":"  下列叙述中正确的是（  ）。 \n\n  \n","choices":["\n栈是“先进先出”的线性表\n","\n队列是“先进后出”的线性表\n","\n循环队列是非线性结构\n","\n有序线性表既可以采用顺序存储结构，也可以采用链式存储结构\n"],"correct_choice":"\n有序线性表既可以采用顺序存储结构，也可以采用链式存储结构\n"},{"title":"栈和队列的共同特点是：","choices":["\n都是先进先出\n","\n都是先进后出\n","\n只允许在端点处插入和删除元素\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"往一个栈顺序push下列元素：ABCDE，其pop可能的顺序，下列不正确的是（） ","choices":["\nBACDE\n","\nACDBE\n","\nAEBCD\n","\nAEDCB\n"],"correct_choice":"\nAEBCD\n"},{"title":"\n\n  若一个栈的输入顺序是1，2，…，n，输出序列的第一个元素是n，则第i（1≤i≤n）个输出元素是（ ）\n  \n","choices":["\nn-i\n","\nn-i-1\n","\ni+1\n","\nn-i+1\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n  元素a， b， c， d， e\n    依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有的元素都出栈，则在所有可能的出栈序列中，以元素 d 开头的序列个数是（ ）。\n","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n4\n"},{"title":"算术表达式a+b*(c+d/e)转为后缀表达式后为()","choices":["\nab+cde/*\n","\nabcde/+*+\n","\nabcde/*++\n","\nabcde*/++\n"],"correct_choice":"\nabcde/+*+\n"},{"title":"单链表实现的栈，栈顶指针为Top(仅仅是一个指针)，入栈一个P节点时，其操作步骤为：","choices":["\nTop->next=p;\n","\np->next=Top->next;Top->next=p;\n","\np->next=Top;Top=p->next;\n","\np->next=Top;Top=Top->next;\n"],"correct_choice":"\np->next=Top->next;Top->next=p;\n"},{"title":"一个栈的入栈序列为ABCDE，则不可能的出栈序列为？","choices":["\nECDBA\n","\nDCEAB\n","\nDECBA\n","\nABCDE\n","\nEDCBA\n"],"correct_choice":"\nECDBA\n\nDCEAB\n"},{"title":"一个栈的输入序列为12345，则下列序列中是栈的输出序列的是（）。","choices":["\n23415\n","\n54132\n","\n31245\n","\n14253\n"],"correct_choice":"\n23415\n"},{"title":"栈和队的共同点是()","choices":["\n都是先进后出\n","\n都是后进先出\n","\n只允许在端点处插入和删除元素\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"一个栈的入栈序列是A,B,C,D,E，则栈的不可能的输出序列是？（）","choices":["\nEDCBA\n","\nDECBA\n","\nDCEAB\n","\nABCDE\n"],"correct_choice":"\nDCEAB\n"},{"title":"\n  栈和队列共同具有的特点是（　　）\n","choices":["\n都是先进后出\n","\n都是先进先出\n","\n只允许在端点进行操作运算\n","\n既能先进先出，也能先进后出\n"],"correct_choice":"\n只允许在端点进行操作运算\n"},{"title":"一个栈的入栈队列 a,b,c,d,e 则栈的不可能的输出序列是______。","choices":["\nedcba\n","\ndceab\n","\ndecba\n","\nabcde\n","\n以上都不是\n"],"correct_choice":"\ndceab\n"},{"title":"一个栈的入栈序列式ABCDE则不可能的出栈序列是:","choices":["\nDECBA\n","\nDCEBA\n","\nECDBA\n","\nABCDE\n"],"correct_choice":"\nECDBA\n"},{"title":"\n  设栈的存储空间为\n   S(1:60)\n  ，初始状态为\n   top=61\n  。现经过一系列正常的入栈与退栈操作后，\n  top=1\n  ，则栈中的元素个数为（\n  ）\n","choices":["\n60\n","\n59\n","\n0\n","\n1\n"],"correct_choice":"\n60\n"},{"title":"若栈采用链式存储结构,则下列说法中正确的是()","choices":["\n需要判断栈满但不需要判断栈空\n","\n不需要判断栈满也不需要判断栈空\n","\n需要判断栈满且需要判断栈空\n","\n不需要判断栈满但需要判断栈空\n"],"correct_choice":"\n不需要判断栈满但需要判断栈空\n"},{"title":"有六个元素6,5,4,3,2,1顺序入栈,问下列哪一个不是合法的出栈序列?()","choices":["\n5 4 3 6 2 1\n","\n4 5 3 1 2 6\n","\n3 4 6 5 2 1\n","\n2 3 4 1 5 6\n"],"correct_choice":"\n3 4 6 5 2 1\n"},{"title":"\n  设栈的初始状态为空，当字符序列a3_作为栈的输入时，输出长度为3的且可以用作C语言标识符的字符串序列有（）个。\n","choices":["\n4\n","\n6\n","\n3\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"如果进栈序列为e1,e2,e3,e4,则不可能的出栈序列是：","choices":["\ne2,e4,e3,e1\n","\ne4,e3, e2, e1\n","\ne1,e2,e3,e4\n","\ne3,e1, e4, e2\n"],"correct_choice":"\ne3,e1, e4, e2\n"},{"title":"若已知一个栈的入栈序列是 1,2,3,„,n,其输出序列为 p1,p2,p3,„,pn,若 p1=n,则pi 为（）","choices":["\ni\n","\nn=i\n","\nn-i+1\n","\n不确定\n"],"correct_choice":"\nn-i+1\n"},{"title":"\n    若进栈序列为a,b,c，则通过入出栈操作可能得到的a,b,c的出栈的不同排列个数为( \n       )\n","choices":["\n4\n","\n5\n","\n6\n","\n7\n"],"correct_choice":"\n5\n"},{"title":"设若入栈序列的元素顺序为X，Y，Z，判断下列哪一个出栈序列是不可能的（）。","choices":["\nXYZ\n","\nYZX\n","\nZXY\n","\nZYX\n"],"correct_choice":"\nZXY\n"},{"title":"中序遍历二叉链存储的二叉树时,一般要用堆栈;中序遍历检索二叉树时,也必须使用堆栈()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"下列数据结构中，能够按照“先进后出”原则存取数据的是（  ）。","choices":["\n循环队列\n","\n栈\n","\n队列\n","\n二叉树\n"],"correct_choice":"\n栈\n"},{"title":"  经过以下栈运算后， x 的值是（ ）。     InitStack(s); Push(s,a); Push(s,b); Pop(s,x); GetTop(s,x);  ","choices":["\na\n","\nb\n","\n1\n","\n0\n"],"correct_choice":"\na\n"},{"title":"一个栈的入栈序列是ABCDE,则出栈序列不可能是（）\n","choices":["\nEDCBA\n","\nDCEAB\n","\nABCDE\n","\nDECBA\n"],"correct_choice":"\nDCEAB\n"},{"title":"入栈序列是：a1,a3,a5,a2,a4,a6,出栈序列是：a5,a4,a2,a6,a3,a1，则栈的容量最小是（）","choices":["\n5\n","\n3\n","\n6\n","\n4\n"],"correct_choice":"\n4\n"},{"title":"已知一个栈的入栈序列是m，n ,x,y,z,则不可能出现的出栈顺序是？","choices":["\nmnxyz\n","\nxnyzm\n","\nnymxz\n","\nnmyzx\n"],"correct_choice":"\nnymxz\n"},{"title":"\n  若元素a,b,c,d,e,f依次进栈，允许进栈\n  、\n  退栈操作交替进行。但不允许连续三次进行退栈\n  操\n  作，则不可能得到的出栈序列是（   ）\n","choices":["\nd， c， e， b， f， a\n","\nc， b， d， a， e， f\n","\nb， c， a， e， f， d\n","\na， f， e， d， c， b\n"],"correct_choice":"\na， f， e， d， c， b\n"},{"title":"任何一个递归过程都可以转换成非递归过程()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"任何二叉树的后序线索树进行后序遍历时都必须用栈()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"堆栈溢出一般是由什么原因导致的？","choices":["\n函数代码长度过长\n","\n循环的递归调用\n","\n大数据结构的局部变量\n","\n代码运行时错误\n"],"correct_choice":"\n循环的递归调用\n\n大数据结构的局部变量\n"},{"title":"链栈与顺序栈相比，其特点之一是通常不会出现栈满的情况。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"\n  对于不同的使用者，一个表结构既可以是栈，也可以是队列，也可以是线性表。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"栈是一种智能在某一端插入和删除的特殊线性表，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，若6元素为A、B、C、D、E、F出栈顺序为B、D、C、F、E、A，则S栈的最小容量为（）。","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n3\n"},{"title":"如入栈序列为1,2,3,4,5,则可能得到的出栈序列为()","choices":["\n1,2,5,3,4\n","\n3,1,2,5,4\n","\n3,2,5,4,1\n","\n1,4,2,3,5\n","\n都不可能\n"],"correct_choice":"\n3,2,5,4,1\n"},{"title":"\n  在表结构中最常用的是线性表，栈和队列不太常用。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"\n  栈和队列的共同特点是\n  (      )\n  。\n\n\n  \n","choices":["\n只允许在端点处插入和删除元素\n","\n都是先进后出\n","\n都是先进先出\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"后缀式 ab+cd+/可用表达式（ ）来表示","choices":["\na+b/c+d\n","\n(a+b)/c+d\n","\na+b/(c+d)\n","\n(a+b)/(c+d)\n"],"correct_choice":"\n(a+b)/(c+d)\n"},{"title":"下列数据中,()是非线性数据结构","choices":["\n栈\n","\n队列\n","\n完全二叉树\n","\n堆\n"],"correct_choice":"\n完全二叉树\n\n堆\n"},{"title":"以下关于栈的说法错误的是：","choices":["\n在栈空的情况下，一定不能作出栈操作，否则产生溢出。\n","\n栈一定是顺序存储的线性结构。\n","\n空栈是所有元素都为0的栈。\n","\n一个栈的输入序列为：A,B,C,D，可以得到输出序列：C,A,B,D。\n"],"correct_choice":"\n栈一定是顺序存储的线性结构。\n\n空栈是所有元素都为0的栈。\n\n一个栈的输入序列为：A,B,C,D，可以得到输出序列：C,A,B,D。\n"},{"title":"队列在程序调用时必不可少,因此递归离不开队列()","choices":["\n对\n","\n错\n"],"correct_choice":"\n错\n"},{"title":"输入序列为ABC,可以变为CBA时,经过的栈操作为()","choices":["\npush,pop,push,pop,push,pop\n","\npush,push,push,pop,pop,pop\n","\npush,push,pop,pop,push,pop\n","\npush,pop,push,push,pop,pop\n"],"correct_choice":"\npush,push,push,pop,pop,pop\n"},{"title":"对于不同的使用者,一个表结构既可以是栈,也可以是队列,也可以是线性表（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"一个栈的入栈列序是a,b,c,d,e，出栈的不可能的输出序列是（        ）","choices":["\nedcba\n","\ndecba\n","\ndceab\n","\nabcde\n"],"correct_choice":"\ndceab\n"},{"title":"栈是一种依赖于以下哪种实现的结构?","choices":["\n先进／后出\n","\n先来先用\n","\n先进／先出\n","\n后进／后出\n"],"correct_choice":"\n先进／后出\n"},{"title":"假定有一个栈， 输入的顺序为”QUDIAN”，那么输出的顺序不可能是？","choices":["\nQUDIAN\n","\nNAIDUQ\n","\nDIANUQ\n","\nDIANQU\n"],"correct_choice":"\nDIANQU\n"},{"title":"下列关于栈的叙述中正确的是（）","choices":["\n在栈中只能插入数据\n","\n在栈中只能删除数据\n","\n栈是先进先出的线性表\n","\n栈是先进后出的线性表\n"],"correct_choice":"\n栈是先进后出的线性表\n"},{"title":"下列情况中，不能使用栈（stack）来解决问题的是？","choices":["\n将数学表达式转换为后辍形式\n","\n实现递归算法\n","\n高级编程语言的过程调用\n","\n操作系统分配资源（如CPU）\n"],"correct_choice":"\n操作系统分配资源（如CPU）\n"},{"title":"下面数据结构能够支持随机的插入和删除操作、并具有较好的性能的是____。","choices":["\n数组和链表\n","\n链表和哈希表\n","\n哈希表和队列\n","\n队列和堆栈\n","\n堆栈和双向队列\n","\n双向队列和数组\n"],"correct_choice":"\n链表和哈希表\n"},{"title":"栈和队列的共同点是（）。","choices":["\n都是先进后出\n","\n都是先进先出\n","\n只允许在端点处插入和删除元素\n","\n没有共同点\n"],"correct_choice":"\n只允许在端点处插入和删除元素\n"},{"title":"栈和队列的存储方式,既可以是顺序方式,又可以是链式方式()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"下列关于栈叙述正确的是（\n）。","choices":["\n栈顶元素最先能被删除\n","\n栈顶元素最后才能被删除\n","\n栈底元素永远不能被删除\n","\n栈底元素最先被删除\n"],"correct_choice":"\n栈顶元素最先能被删除\n"},{"title":"\n  设输入序列为1、2、3、4、5、6，则通过栈的作用后可以得到的输出序列为（）。\n","choices":["\n5，3，4，6，1，2\n","\n3，2，5，6，4，1\n","\n3，1，2，5，4，6\n","\n1，5，4，6，2，3\n"],"correct_choice":"\n3，2，5，6，4，1\n"},{"title":"两个栈共享一片连续内存空间时,为提高内存利用率,减少溢出机会,应把两个栈的栈底分别设在这片内存空间的两端()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"下列关于栈的叙述中正确的是？","choices":["\n在栈中只能插入数据\n","\n在栈中只能删除数据\n","\n栈是先进先出的线性表\n","\n栈是先进后出的线性表\n"],"correct_choice":"\n栈是先进后出的线性表\n"},{"title":"设栈S初始状态为空。元素a,b,c,d,e,f依次通过栈S，若出栈的顺序为c,f,e,d,b,a，则栈S的容量至少应该为？","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n5\n"},{"title":"\n  设栈的顺序存储空间为\n   S(1:m)\n  ，初始状态为\n  top=m+1\n  。现经过一系列正常的入栈与退栈操作后，\n  top=0\n  ，则栈中的元素个数为（\n  ）\n","choices":["\n不可能\n","\nm+1\n","\n1\n","\nm\n"],"correct_choice":"\n不可能\n"},{"title":"一个栈的入栈序列是\nA\n、\nB\n、\nC\n、\nD\n、\nE\n，则栈的不可能的输出序列是（）","choices":["\nEDCBA\n","\nDECBA\n","\nDCEAB\n","\nABCDE\n"],"correct_choice":"\nDCEAB\n"},{"title":"下列关于栈的叙述正确的是（）","choices":["\n栈是非线性结构\n","\n栈是一种树状结构\n","\n栈具有先进先出的特征\n","\n栈有后进先出的特征\n"],"correct_choice":"\n栈有后进先出的特征\n"},{"title":"两个栈共用静态存储空间,对头使用也存在空间溢出问题()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"对于栈操作数据的原则是()","choices":["\n先进先出\n","\n后进先出\n","\n后进后出\n","\n不分顺序\n"],"correct_choice":"\n后进先出\n"},{"title":"\n  若进栈序列为\n  1,2,3,4\n  ，进栈过程中可以出栈，则下列不可能的一个出栈序列是\n  ________\n","choices":["\n1,4,3,2\n","\n2,3,4,1，\n","\n3,1,4,2\n","\n3,4,2,1\n"],"correct_choice":"\n3,1,4,2\n"},{"title":"字符 A 、 B 、 C 依次进入一个栈，按出栈的先后顺序组成不同的字符串，至多可以组成 (     ) 个不同的字符串？","choices":["\n14\n","\n5\n","\n6\n","\n8\n"],"correct_choice":"\n5\n"},{"title":"表达式a*(b+c)-d的后缀表达式是()","choices":["\nabcd*+-\n","\nabc+*d-\n","\nabc*+d-\n","\n-+*abcd\n"],"correct_choice":"\nabc+*d-\n"},{"title":"如果进栈序列是el，e2，e3，e4，e5，则可能的出栈序列是","choices":["\ne3，e2，e5，e4，e1\n","\ne2，e4，e1，e3，e5\n","\ne3，e2，e4，e5，e1\n","\n以上皆不可能\n"],"correct_choice":"\ne3，e2，e5，e4，e1\n\ne3，e2，e4，e5，e1\n"},{"title":"\n  设一个栈的输入序列是 1，2，3，4，5，则下列序列中，栈的合法输出序列的是（）。\n","choices":["\n5 1 2 3 4\n","\n4 5 1 3 2\n","\n4 3 1 2 5\n","\n3 2 1 5 4\n"],"correct_choice":"\n3 2 1 5 4\n"},{"title":"\n  设指针变量top指向当前链式栈的栈顶，则删除栈顶元素的操作序列为（）。\n","choices":["\ntop=top+1;\n","\ntop=top-1;\n","\ntop->next=top;\n","\ntop=top->next;\n"],"correct_choice":"\ntop=top->next;\n"},{"title":"栈和队列都是限制存取点的线性结构()","choices":["\n对\n","\n错\n"],"correct_choice":"\n对\n"},{"title":"某火车站要通过一条栈道（先进后出）来调换进入车站的列车顺序，若进站的列车顺序为A、B、C，则下列哪个出站顺序不可能？（）","choices":["\nABC\n","\nACB\n","\nCAB\n","\nCBA\n"],"correct_choice":"\nCAB\n"},{"title":"若有一个栈的输入序列是1,2,3，...，n，输出序列的第一个元素是n，则第i个输出元素是（）","choices":["\nn-i\n","\nn-i-1\n","\nn-i+1\n","\n不确定\n"],"correct_choice":"\nn-i+1\n"},{"title":"一个栈的输入序列是 12345,则栈的输出序列不可能是 12345（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"在表结构中最常用的是线性表,栈和队列不太常用（）。","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"一个栈的输入序列为：\nA\n，\nB\n，\nC\n，\nD\n，可以得到输出序列：\nC\n，\nA\n，\nB\n，\nD\n。这一说法是否正确\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n错误\n"},{"title":"设入栈顺序为A，B，C，D，E，则出栈序列不可能是（        ）","choices":["\nEDCBA\n","\nADEBC\n","\nABCDE\n","\nABDCE\n"],"correct_choice":"\nADEBC\n"},{"title":"向一个栈顶指针为hs的链栈中插入一个s结点时，应执行______。","choices":["\nhs->next=s;\n","\ns->next=hs;   hs=s;\n","\ns->next=hs->next;hs->next=s;\n","\ns->next=hs; hs=hs->next;\n"],"correct_choice":"\ns->next=hs;   hs=s;\n"},{"title":"向一个栈顶指针为h的带头结点的链栈中插入指针s所指的结点时,应执行()","choices":["\nh->next=s;\n","\ns->next=h;\n","\ns->next=h;h->next=s;\n","\ns->next=h->next;h->next=s;\n"],"correct_choice":"\ns->next=h->next;h->next=s;\n"},{"title":"入栈序列是：a1,\n  a3, a5, a2, a4, a6，出栈序列是：a5, a4, a2, a6, a3, a1，则栈的容量最小是多少（）","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n4\n"},{"title":"设输入序列为1,2,3，则经过栈的作用后可以得到（）中不同的输出序列。","choices":["\n3\n","\n7\n","\n8\n","\n5\n"],"correct_choice":"\n5\n"},{"title":"\n  两个栈共享一片连续内存空间时，为提高内存利用率，减少溢出机会，应把两个栈的栈底分别设在这片内存空间的两端。\n","choices":["\n正确\n","\n错误\n"],"correct_choice":"\n正确\n"},{"title":"以下哪一个不是栈的基本运算？","choices":["\n删除栈顶元素\n","\n删除栈底元素\n","\n判定栈是否为空\n","\n将栈置为空栈\n"],"correct_choice":"\n删除栈底元素\n"},{"title":"设栈的输入序列是1,2,3,4,则()不可能是其出栈序列","choices":["\n1,2,4,3\n","\n2,1,3,4\n","\n1,4,3,2\n","\n4,3,1,2\n","\n3,2,1,4\n"],"correct_choice":"\n4,3,1,2\n"},{"title":"下设栈S的初始状态为空，元素a,b,c,d,e,f依次入栈S，出栈的序列为b,d,c,f,e,a则栈S的容量至少为（）","choices":["\n6\n","\n5\n","\n4\n","\n3\n"],"correct_choice":"\n3\n"},{"title":"假设栈S和队列Q的初始状态为空，元素a、b、c、d、e、f依次通过S和Q，即每一个元素必须先进栈，之后再出栈进入队列。若这6个元素出队的顺序是b、d、c、f、e、a，则栈S的容量至少应该为______。","choices":["\n3\n","\n4\n","\n5\n","\n6\n"],"correct_choice":"\n3\n"},{"title":"栈底至栈顶一次存放A,B,C,D四个元素，在第五个元素E入栈前，栈中元素可以出栈，则出栈序列可能是（）","choices":["\nABCDE\n","\nDECAB\n","\nDCEBA\n","\nCDEAB\n"],"correct_choice":"\nDCEBA\n"},{"title":"依次读入数据元素序列{a,b,c,d,e,f,g}入栈,每进一个元素,机器可要求下一个元素入栈或弹栈,如此进行,则栈空时弹出的元素构成的序列是以下()序列?","choices":["\n{d,e,c,f,b,g,a}\n","\n{f,e,g,d,a,c,b}\n","\n{e,f,d,g,b,c,a}\n","\n{c,d,b,e,f,a,g}\n"],"correct_choice":"\n{d,e,c,f,b,g,a}\n\n{c,d,b,e,f,a,g}\n"},{"title":"栈应用的典型实例是（        ）","choices":["\n排队\n","\n查找\n","\n归并\n","\n用“算符优先法进行表达式求值”\n"],"correct_choice":"\n用“算符优先法进行表达式求值”\n"},{"title":"下面关于队列和栈的描述正确的是______。","choices":["\n栈是先进先出的数据结构\n","\n队列是先进先出的数据结构\n","\n栈内元素可以随机访问\n","\n队列内的元素可以随机访问\n"],"correct_choice":"\n队列是先进先出的数据结构\n"},{"title":"有栈S，按顺序ABCD进栈，则出栈顺序不可能存在的是______。","choices":["\nDCBA\n","\nBACD\n","\nBADC\n","\nCABD\n"],"correct_choice":"\nCABD\n"},{"title":"设有一个顺序栈S，元素s1、s2、s3、s4、s5、s6依次进栈，如果6个元素的出栈顺序为s2、s3、s4、s6、s5、s1，则顺序栈的容量至少应为多少？","choices":["\n2\n","\n3\n","\n4\n","\n5\n"],"correct_choice":"\n3\n"},{"title":"下列叙述中正确的是？","choices":["\n线性表是线性结构\n","\n栈与队列是非线性结构\n","\n线性链表是非线性结构\n","\n二叉树是线性结构\n"],"correct_choice":"\n线性表是线性结构\n"},{"title":"输入序列为ABC，可以变成CBA时，经过的栈操作为","choices":["\npush,pop,push,pop,push,pop\n","\npush,push,push,pop,pop,pop\n","\npush,push,pop,pop,push,pop\n","\nposh,pop,push,push,pop,pop\n"],"correct_choice":"\npush,push,push,pop,pop,pop\n"},{"title":"\n  设计一个判别表达式中左右括号是否匹配对出现的算法，采用（）数据结构最佳。\n","choices":["\n线性表的顺序存储结构\n","\n队列\n","\n线性表的链式存储结构\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"\n  以下数据结构中哪一个是非线性结构？\n  (   )\n\n","choices":["\n队列\n","\n栈\n","\n线性表\n","\n二叉树\n"],"correct_choice":"\n二叉树\n"},{"title":"\n  \n  以下数据结构中，属于线性结构的是（\n  ） \n","choices":["\n图\n","\n栈\n","\n二分查找树\n","\n森林\n"],"correct_choice":"\n栈\n"},{"title":"下列关于栈的叙述中,正确的是","choices":["\n栈底元素一定是最后入栈的元素\n","\n栈顶元素一定是最先入栈的元素\n","\n栈操作遵循先进后出的原则\n","\n以上说法均错误\n"],"correct_choice":"\n栈操作遵循先进后出的原则\n"},{"title":"设栈的存储空间为\n S(1:60)\n，初始状态为\n top=61\n。现经过一系列正常的入栈与退栈操作后，\ntop=1\n，则栈中的元素个数为（\n）。","choices":["\n60\n","\n59\n","\n0\n","\n1\n"],"correct_choice":"\n60\n"},{"title":"设计一个判别表达式中左、右括号是否配对出现的算法,采用()数据结构最佳","choices":["\n线性表的顺序存储结构\n","\n队列\n","\n线性表的链式存储结构\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"一个栈的初始状态为空。现将元素1,2,3,A,B,C依次入栈,然后再依次出栈,则元素出栈的顺序是","choices":["\n1,2,3,A,B,C\n","\nC,B,A,1,2,3\n","\nC,B,A,3,2,1\n","\n1,2,3,C,B,A\n"],"correct_choice":"\nC,B,A,3,2,1\n"},{"title":"\n  设栈的顺序存储空间为\n   S(1:m)\n  ，初始状态为\n  top=0\n  。现经过一系列正常的入栈与退栈操作后，\n  top=m+1\n  ，则栈中的元素个数为（\n  ）\n","choices":["\n不可能\n","\nm+1\n","\n0\n","\nm\n"],"correct_choice":"\n不可能\n"},{"title":"解析XML时，需要校验节点是否闭合，如必须有与之对应，用（）数据结构实现比较好（）","choices":["\n链表\n","\n树\n","\n队列\n","\n栈\n"],"correct_choice":"\n栈\n"},{"title":"\n  栈中元素的进出原则是（）\n\n\n","choices":["\n先进先出\n","\n后进先出\n","\n栈空则进\n","\n栈满则出\n"],"correct_choice":"\n后进先出\n"},{"title":"从一个栈顶指针为top的链栈中删除一个结点时，用x保存被删除的结点，应执行下列 (         )命令。","choices":["\nx=top;top=top->next;\n","\ntop=top->next;x=top->data;\n","\nx=top->data;\n","\nx=top->data;top=top->next;\n"],"correct_choice":"\nx=top->data;top=top->next;\n"},{"title":"一个栈的入栈序列为ABCDE，则不可能的出栈序列为?","choices":["\nECDBA\n","\nDCEAB\n","\nDECBA\n","\nABCDE\n","\nEDCBA\n"],"correct_choice":"\nECDBA\n\nDCEAB\n"},{"title":"\n  下列关于栈的叙述中，正确的是（）\n","choices":["\n栈底元素一定是最后入栈的元素\n","\n栈顶元素一定是最先入栈的元素\n","\n栈操作遵循先进后出的原则\n","\n以上说法均错误\n"],"correct_choice":"\n栈操作遵循先进后出的原则\n"},{"title":"按e1，e2，e3，e4的次序进栈（中间可能有出栈操作，例如e1进栈后出栈，e2再进栈），则可能的出栈系列是        ：","choices":["\ne3，e1，e4，e2\n","\ne2，e4，e3，e1\n","\ne3，e4，e1，e2\n","\n任意系列\n"],"correct_choice":"\ne2，e4，e3，e1\n"}]